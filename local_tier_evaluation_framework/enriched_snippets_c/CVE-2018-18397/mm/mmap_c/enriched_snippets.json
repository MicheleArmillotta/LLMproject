[
  {
    "function_name": "init_reserve_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3754-3760",
    "snippet": "static int __meminit init_reserve_notifier(void)\n{\n\tif (register_hotmemory_notifier(&reserve_mem_nb))\n\t\tpr_err(\"Failed registering memory add/remove notifier for admin reserve\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block reserve_mem_nb = {\n\t.notifier_call = reserve_mem_notifier,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed registering memory add/remove notifier for admin reserve\\n\""
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_hotmemory_notifier",
          "args": [
            "&reserve_mem_nb"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct notifier_block reserve_mem_nb = {\n\t.notifier_call = reserve_mem_notifier,\n};\n\nstatic int __meminit init_reserve_notifier(void)\n{\n\tif (register_hotmemory_notifier(&reserve_mem_nb))\n\t\tpr_err(\"Failed registering memory add/remove notifier for admin reserve\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reserve_mem_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3711-3748",
    "snippet": "static int reserve_mem_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tunsigned long tmp, free_kbytes;\n\n\tswitch (action) {\n\tcase MEM_ONLINE:\n\t\t/* Default max is 128MB. Leave alone if modified by operator. */\n\t\ttmp = sysctl_user_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 17))\n\t\t\tinit_user_reserve();\n\n\t\t/* Default max is 8MB.  Leave alone if modified by operator. */\n\t\ttmp = sysctl_admin_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 13))\n\t\t\tinit_admin_reserve();\n\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\t\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\t\tif (sysctl_user_reserve_kbytes > free_kbytes) {\n\t\t\tinit_user_reserve();\n\t\t\tpr_info(\"vm.user_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_user_reserve_kbytes);\n\t\t}\n\n\t\tif (sysctl_admin_reserve_kbytes > free_kbytes) {\n\t\t\tinit_admin_reserve();\n\t\t\tpr_info(\"vm.admin_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_admin_reserve_kbytes);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"vm.admin_reserve_kbytes reset to %lu\\n\"",
            "sysctl_admin_reserve_kbytes"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_admin_reserve",
          "args": [],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "init_admin_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3682-3690",
          "snippet": "static int init_admin_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_admin_reserve_kbytes = min(free_kbytes / 32, 1UL << 13);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int init_admin_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_admin_reserve_kbytes = min(free_kbytes / 32, 1UL << 13);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"vm.user_reserve_kbytes reset to %lu\\n\"",
            "sysctl_user_reserve_kbytes"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_user_reserve",
          "args": [],
          "line": 3733
        },
        "resolved": true,
        "details": {
          "function_name": "init_user_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3661-3669",
          "snippet": "static int init_user_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_user_reserve_kbytes = min(free_kbytes / 32, 1UL << 17);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int init_user_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_user_reserve_kbytes = min(free_kbytes / 32, 1UL << 17);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int reserve_mem_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tunsigned long tmp, free_kbytes;\n\n\tswitch (action) {\n\tcase MEM_ONLINE:\n\t\t/* Default max is 128MB. Leave alone if modified by operator. */\n\t\ttmp = sysctl_user_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 17))\n\t\t\tinit_user_reserve();\n\n\t\t/* Default max is 8MB.  Leave alone if modified by operator. */\n\t\ttmp = sysctl_admin_reserve_kbytes;\n\t\tif (0 < tmp && tmp < (1UL << 13))\n\t\t\tinit_admin_reserve();\n\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\t\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\t\tif (sysctl_user_reserve_kbytes > free_kbytes) {\n\t\t\tinit_user_reserve();\n\t\t\tpr_info(\"vm.user_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_user_reserve_kbytes);\n\t\t}\n\n\t\tif (sysctl_admin_reserve_kbytes > free_kbytes) {\n\t\t\tinit_admin_reserve();\n\t\t\tpr_info(\"vm.admin_reserve_kbytes reset to %lu\\n\",\n\t\t\t\tsysctl_admin_reserve_kbytes);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "init_admin_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3682-3690",
    "snippet": "static int init_admin_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_admin_reserve_kbytes = min(free_kbytes / 32, 1UL << 13);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "free_kbytes / 32",
            "1UL << 13"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int init_admin_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_admin_reserve_kbytes = min(free_kbytes / 32, 1UL << 13);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_user_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3661-3669",
    "snippet": "static int init_user_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_user_reserve_kbytes = min(free_kbytes / 32, 1UL << 17);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "free_kbytes / 32",
            "1UL << 17"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int init_user_reserve(void)\n{\n\tunsigned long free_kbytes;\n\n\tfree_kbytes = global_zone_page_state(NR_FREE_PAGES) << (PAGE_SHIFT - 10);\n\n\tsysctl_user_reserve_kbytes = min(free_kbytes / 32, 1UL << 17);\n\treturn 0;\n}"
  },
  {
    "function_name": "mmap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3643-3649",
    "snippet": "void __init mmap_init(void)\n{\n\tint ret;\n\n\tret = percpu_counter_init(&vm_committed_as, 0, GFP_KERNEL);\n\tVM_BUG_ON(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "ret"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&vm_committed_as",
            "0",
            "GFP_KERNEL"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init mmap_init(void)\n{\n\tint ret;\n\n\tret = percpu_counter_init(&vm_committed_as, 0, GFP_KERNEL);\n\tVM_BUG_ON(ret);\n}"
  },
  {
    "function_name": "mm_drop_all_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3621-3638",
    "snippet": "void mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(mm_all_locks_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mm_all_locks_mutex"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_unlock_mapping",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 3634
        },
        "resolved": true,
        "details": {
          "function_name": "vm_unlock_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3603-3615",
          "snippet": "static void vm_unlock_mapping(struct address_space *mapping)\n{\n\tif (test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change to 0 from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\ti_mmap_unlock_write(mapping);\n\t\tif (!test_and_clear_bit(AS_MM_ALL_LOCKS,\n\t\t\t\t\t&mapping->flags))\n\t\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(mm_all_locks_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_unlock_mapping(struct address_space *mapping)\n{\n\tif (test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change to 0 from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\ti_mmap_unlock_write(mapping);\n\t\tif (!test_and_clear_bit(AS_MM_ALL_LOCKS,\n\t\t\t\t\t&mapping->flags))\n\t\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_unlock_anon_vma",
          "args": [
            "avc->anon_vma"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "vm_unlock_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3581-3601",
          "snippet": "static void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change to 0 from under\n\t\t * us because we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * We must however clear the bitflag before unlocking\n\t\t * the vma so the users using the anon_vma->rb_root will\n\t\t * never see our bitflag.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us until we release the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(mm_all_locks_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change to 0 from under\n\t\t * us because we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * We must however clear the bitflag before unlocking\n\t\t * the vma so the users using the anon_vma->rb_root will\n\t\t * never see our bitflag.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us until we release the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "avc",
            "&vma->anon_vma_chain",
            "same_vma"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&mm_all_locks_mutex)"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&mm_all_locks_mutex"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "down_read_trylock(&mm->mmap_sem)"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nvoid mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}"
  },
  {
    "function_name": "vm_unlock_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3603-3615",
    "snippet": "static void vm_unlock_mapping(struct address_space *mapping)\n{\n\tif (test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change to 0 from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\ti_mmap_unlock_write(mapping);\n\t\tif (!test_and_clear_bit(AS_MM_ALL_LOCKS,\n\t\t\t\t\t&mapping->flags))\n\t\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(mm_all_locks_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "AS_MM_ALL_LOCKS",
            "&mapping->flags"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AS_MM_ALL_LOCKS",
            "&mapping->flags"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_unlock_mapping(struct address_space *mapping)\n{\n\tif (test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change to 0 from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\ti_mmap_unlock_write(mapping);\n\t\tif (!test_and_clear_bit(AS_MM_ALL_LOCKS,\n\t\t\t\t\t&mapping->flags))\n\t\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "vm_unlock_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3581-3601",
    "snippet": "static void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change to 0 from under\n\t\t * us because we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * We must however clear the bitflag before unlocking\n\t\t * the vma so the users using the anon_vma->rb_root will\n\t\t * never see our bitflag.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us until we release the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(mm_all_locks_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "anon_vma"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__test_and_clear_bit",
          "args": [
            "0",
            "(unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_root.rb_node"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "0",
            "(unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change to 0 from under\n\t\t * us because we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * We must however clear the bitflag before unlocking\n\t\t * the vma so the users using the anon_vma->rb_root will\n\t\t * never see our bitflag.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us until we release the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}"
  },
  {
    "function_name": "mm_take_all_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3541-3579",
    "snippet": "int mm_take_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\n\tmutex_lock(&mm_all_locks_mutex);\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\tis_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\t!is_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_lock_anon_vma(mm, avc->anon_vma);\n\t}\n\n\treturn 0;\n\nout_unlock:\n\tmm_drop_all_locks(mm);\n\treturn -EINTR;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(mm_all_locks_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_drop_all_locks",
          "args": [
            "mm"
          ],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "mm_drop_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3621-3638",
          "snippet": "void mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(mm_all_locks_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nvoid mm_drop_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\tBUG_ON(!mutex_is_locked(&mm_all_locks_mutex));\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_unlock_anon_vma(avc->anon_vma);\n\t\tif (vma->vm_file && vma->vm_file->f_mapping)\n\t\t\tvm_unlock_mapping(vma->vm_file->f_mapping);\n\t}\n\n\tmutex_unlock(&mm_all_locks_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_lock_anon_vma",
          "args": [
            "mm",
            "avc->anon_vma"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "vm_lock_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3463-3484",
          "snippet": "static void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)\n{\n\tif (!test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\tdown_write_nest_lock(&anon_vma->root->rwsem, &mm->mmap_sem);\n\t\t/*\n\t\t * We can safely modify head.next after taking the\n\t\t * anon_vma->root->rwsem. If some other vma in this mm shares\n\t\t * the same anon_vma we won't take it again.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us thanks to the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (__test_and_set_bit(0, (unsigned long *)\n\t\t\t\t       &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(mm_all_locks_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)\n{\n\tif (!test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\tdown_write_nest_lock(&anon_vma->root->rwsem, &mm->mmap_sem);\n\t\t/*\n\t\t * We can safely modify head.next after taking the\n\t\t * anon_vma->root->rwsem. If some other vma in this mm shares\n\t\t * the same anon_vma we won't take it again.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us thanks to the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (__test_and_set_bit(0, (unsigned long *)\n\t\t\t\t       &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "avc",
            "&vma->anon_vma_chain",
            "same_vma"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_lock_mapping",
          "args": [
            "mm",
            "vma->vm_file->f_mapping"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "vm_lock_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3486-3502",
          "snippet": "static void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)\n{\n\tif (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change from under us because\n\t\t * we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * Operations on ->flags have to be atomic because\n\t\t * even if AS_MM_ALL_LOCKS is stable thanks to the\n\t\t * mm_all_locks_mutex, there may be other cpus\n\t\t * changing other bitflags in parallel to us.\n\t\t */\n\t\tif (test_and_set_bit(AS_MM_ALL_LOCKS, &mapping->flags))\n\t\t\tBUG();\n\t\tdown_write_nest_lock(&mapping->i_mmap_rwsem, &mm->mmap_sem);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(mm_all_locks_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)\n{\n\tif (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change from under us because\n\t\t * we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * Operations on ->flags have to be atomic because\n\t\t * even if AS_MM_ALL_LOCKS is stable thanks to the\n\t\t * mm_all_locks_mutex, there may be other cpus\n\t\t * changing other bitflags in parallel to us.\n\t\t */\n\t\tif (test_and_set_bit(AS_MM_ALL_LOCKS, &mapping->flags))\n\t\t\tBUG();\n\t\tdown_write_nest_lock(&mapping->i_mmap_rwsem, &mm->mmap_sem);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mm_all_locks_mutex"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "down_read_trylock(&mm->mmap_sem)"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nint mm_take_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\n\tmutex_lock(&mm_all_locks_mutex);\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\tis_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\t!is_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_lock_anon_vma(mm, avc->anon_vma);\n\t}\n\n\treturn 0;\n\nout_unlock:\n\tmm_drop_all_locks(mm);\n\treturn -EINTR;\n}"
  },
  {
    "function_name": "vm_lock_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3486-3502",
    "snippet": "static void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)\n{\n\tif (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change from under us because\n\t\t * we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * Operations on ->flags have to be atomic because\n\t\t * even if AS_MM_ALL_LOCKS is stable thanks to the\n\t\t * mm_all_locks_mutex, there may be other cpus\n\t\t * changing other bitflags in parallel to us.\n\t\t */\n\t\tif (test_and_set_bit(AS_MM_ALL_LOCKS, &mapping->flags))\n\t\t\tBUG();\n\t\tdown_write_nest_lock(&mapping->i_mmap_rwsem, &mm->mmap_sem);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(mm_all_locks_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_write_nest_lock",
          "args": [
            "&mapping->i_mmap_rwsem",
            "&mm->mmap_sem"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "AS_MM_ALL_LOCKS",
            "&mapping->flags"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AS_MM_ALL_LOCKS",
            "&mapping->flags"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_lock_mapping(struct mm_struct *mm, struct address_space *mapping)\n{\n\tif (!test_bit(AS_MM_ALL_LOCKS, &mapping->flags)) {\n\t\t/*\n\t\t * AS_MM_ALL_LOCKS can't change from under us because\n\t\t * we hold the mm_all_locks_mutex.\n\t\t *\n\t\t * Operations on ->flags have to be atomic because\n\t\t * even if AS_MM_ALL_LOCKS is stable thanks to the\n\t\t * mm_all_locks_mutex, there may be other cpus\n\t\t * changing other bitflags in parallel to us.\n\t\t */\n\t\tif (test_and_set_bit(AS_MM_ALL_LOCKS, &mapping->flags))\n\t\t\tBUG();\n\t\tdown_write_nest_lock(&mapping->i_mmap_rwsem, &mm->mmap_sem);\n\t}\n}"
  },
  {
    "function_name": "vm_lock_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3463-3484",
    "snippet": "static void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)\n{\n\tif (!test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\tdown_write_nest_lock(&anon_vma->root->rwsem, &mm->mmap_sem);\n\t\t/*\n\t\t * We can safely modify head.next after taking the\n\t\t * anon_vma->root->rwsem. If some other vma in this mm shares\n\t\t * the same anon_vma we won't take it again.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us thanks to the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (__test_and_set_bit(0, (unsigned long *)\n\t\t\t\t       &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(mm_all_locks_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__test_and_set_bit",
          "args": [
            "0",
            "(unsigned long *)\n\t\t\t\t       &anon_vma->root->rb_root.rb_root.rb_node"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_nest_lock",
          "args": [
            "&anon_vma->root->rwsem",
            "&mm->mmap_sem"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "0",
            "(unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(mm_all_locks_mutex);\n\nstatic void vm_lock_anon_vma(struct mm_struct *mm, struct anon_vma *anon_vma)\n{\n\tif (!test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_root.rb_node)) {\n\t\t/*\n\t\t * The LSB of head.next can't change from under us\n\t\t * because we hold the mm_all_locks_mutex.\n\t\t */\n\t\tdown_write_nest_lock(&anon_vma->root->rwsem, &mm->mmap_sem);\n\t\t/*\n\t\t * We can safely modify head.next after taking the\n\t\t * anon_vma->root->rwsem. If some other vma in this mm shares\n\t\t * the same anon_vma we won't take it again.\n\t\t *\n\t\t * No need of atomic instructions here, head.next\n\t\t * can't change from under us thanks to the\n\t\t * anon_vma->root->rwsem.\n\t\t */\n\t\tif (__test_and_set_bit(0, (unsigned long *)\n\t\t\t\t       &anon_vma->root->rb_root.rb_root.rb_node))\n\t\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "install_special_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3450-3459",
    "snippet": "int install_special_mapping(struct mm_struct *mm,\n\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t    unsigned long vm_flags, struct page **pages)\n{\n\tstruct vm_area_struct *vma = __install_special_mapping(\n\t\tmm, addr, len, vm_flags, (void *)pages,\n\t\t&legacy_special_mapping_vmops);\n\n\treturn PTR_ERR_OR_ZERO(vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "vma"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__install_special_mapping",
          "args": [
            "mm",
            "addr",
            "len",
            "vm_flags",
            "(void *)pages",
            "&legacy_special_mapping_vmops"
          ],
          "line": 3454
        },
        "resolved": true,
        "details": {
          "function_name": "__install_special_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3387-3422",
          "snippet": "static struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};\n\nint install_special_mapping(struct mm_struct *mm,\n\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t    unsigned long vm_flags, struct page **pages)\n{\n\tstruct vm_area_struct *vma = __install_special_mapping(\n\t\tmm, addr, len, vm_flags, (void *)pages,\n\t\t&legacy_special_mapping_vmops);\n\n\treturn PTR_ERR_OR_ZERO(vma);\n}"
  },
  {
    "function_name": "_install_special_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3441-3448",
    "snippet": "struct vm_area_struct *_install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, const struct vm_special_mapping *spec)\n{\n\treturn __install_special_mapping(mm, addr, len, vm_flags, (void *)spec,\n\t\t\t\t\t&special_mapping_vmops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n\t.mremap = special_mapping_mremap,\n\t.name = special_mapping_name,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__install_special_mapping",
          "args": [
            "mm",
            "addr",
            "len",
            "vm_flags",
            "(void *)spec",
            "&special_mapping_vmops"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "__install_special_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3387-3422",
          "snippet": "static struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const struct vm_operations_struct special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n\t.mremap = special_mapping_mremap,\n\t.name = special_mapping_name,\n};\n\nstruct vm_area_struct *_install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, const struct vm_special_mapping *spec)\n{\n\treturn __install_special_mapping(mm, addr, len, vm_flags, (void *)spec,\n\t\t\t\t\t&special_mapping_vmops);\n}"
  },
  {
    "function_name": "vma_is_special_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3424-3430",
    "snippet": "bool vma_is_special_mapping(const struct vm_area_struct *vma,\n\tconst struct vm_special_mapping *sm)\n{\n\treturn vma->vm_private_data == sm &&\n\t\t(vma->vm_ops == &special_mapping_vmops ||\n\t\t vma->vm_ops == &legacy_special_mapping_vmops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n\t.mremap = special_mapping_mremap,\n\t.name = special_mapping_name,\n};",
      "static const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const struct vm_operations_struct special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n\t.mremap = special_mapping_mremap,\n\t.name = special_mapping_name,\n};\nstatic const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};\n\nbool vma_is_special_mapping(const struct vm_area_struct *vma,\n\tconst struct vm_special_mapping *sm)\n{\n\treturn vma->vm_private_data == sm &&\n\t\t(vma->vm_ops == &special_mapping_vmops ||\n\t\t vma->vm_ops == &legacy_special_mapping_vmops);\n}"
  },
  {
    "function_name": "__install_special_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3387-3422",
    "snippet": "static struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_area_free",
          "args": [
            "vma"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_mmap",
          "args": [
            "vma"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_stat_account",
          "args": [
            "mm",
            "vma->vm_flags",
            "len >> PAGE_SHIFT"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "vm_stat_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3306-3316",
          "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_vm_struct",
          "args": [
            "mm",
            "vma"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "insert_vm_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3165-3196",
          "snippet": "int insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\treturn -ENOMEM;\n\tif ((vma->vm_flags & VM_ACCOUNT) &&\n\t     security_vm_enough_memory_mm(mm, vma_pages(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The vm_pgoff of a purely anonymous vma should be irrelevant\n\t * until its first write fault, when page's anon_vma and index\n\t * are set.  But now set the vm_pgoff it will almost certainly\n\t * end up with (unless mremap moves it elsewhere before that\n\t * first wfault), so /proc/pid/maps tells a consistent story.\n\t *\n\t * By setting it to reflect the virtual start address of the\n\t * vma, merges and splits can happen in a seamless way, just\n\t * using the existing file pgoff checks and manipulations.\n\t * Similarly in do_mmap_pgoff and in do_brk.\n\t */\n\tif (vma_is_anonymous(vma)) {\n\t\tBUG_ON(vma->anon_vma);\n\t\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nint insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\treturn -ENOMEM;\n\tif ((vma->vm_flags & VM_ACCOUNT) &&\n\t     security_vm_enough_memory_mm(mm, vma_pages(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The vm_pgoff of a purely anonymous vma should be irrelevant\n\t * until its first write fault, when page's anon_vma and index\n\t * are set.  But now set the vm_pgoff it will almost certainly\n\t * end up with (unless mremap moves it elsewhere before that\n\t * first wfault), so /proc/pid/maps tells a consistent story.\n\t *\n\t * By setting it to reflect the virtual start address of the\n\t * vma, merges and splits can happen in a seamless way, just\n\t * using the existing file pgoff checks and manipulations.\n\t * Similarly in do_mmap_pgoff and in do_brk.\n\t */\n\tif (vma_is_anonymous(vma)) {\n\t\tBUG_ON(vma->anon_vma);\n\t\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_get_page_prot",
          "args": [
            "vma->vm_flags"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "vm_get_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "110-117",
          "snippet": "pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma == NULL"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_area_alloc",
          "args": [
            "mm"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *__install_special_mapping(\n\tstruct mm_struct *mm,\n\tunsigned long addr, unsigned long len,\n\tunsigned long vm_flags, void *priv,\n\tconst struct vm_operations_struct *ops)\n{\n\tint ret;\n\tstruct vm_area_struct *vma;\n\n\tvma = vm_area_alloc(mm);\n\tif (unlikely(vma == NULL))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\n\tvma->vm_flags = vm_flags | mm->def_flags | VM_DONTEXPAND | VM_SOFTDIRTY;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\tvma->vm_ops = ops;\n\tvma->vm_private_data = priv;\n\n\tret = insert_vm_struct(mm, vma);\n\tif (ret)\n\t\tgoto out;\n\n\tvm_stat_account(mm, vma->vm_flags, len >> PAGE_SHIFT);\n\n\tperf_event_mmap(vma);\n\n\treturn vma;\n\nout:\n\tvm_area_free(vma);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "special_mapping_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3357-3385",
    "snippet": "static vm_fault_t special_mapping_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tpgoff_t pgoff;\n\tstruct page **pages;\n\n\tif (vma->vm_ops == &legacy_special_mapping_vmops) {\n\t\tpages = vma->vm_private_data;\n\t} else {\n\t\tstruct vm_special_mapping *sm = vma->vm_private_data;\n\n\t\tif (sm->fault)\n\t\t\treturn sm->fault(sm, vmf->vma, vmf);\n\n\t\tpages = sm->pages;\n\t}\n\n\tfor (pgoff = vmf->pgoff; pgoff && *pages; ++pages)\n\t\tpgoff--;\n\n\tif (*pages) {\n\t\tstruct page *page = *pages;\n\t\tget_page(page);\n\t\tvmf->page = page;\n\t\treturn 0;\n\t}\n\n\treturn VM_FAULT_SIGBUS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vm_fault_t special_mapping_fault(struct vm_fault *vmf);",
      "static const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 3379
        },
        "resolved": true,
        "details": {
          "function_name": "vm_get_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "110-117",
          "snippet": "pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sm->fault",
          "args": [
            "sm",
            "vmf->vma",
            "vmf"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic vm_fault_t special_mapping_fault(struct vm_fault *vmf);\nstatic const struct vm_operations_struct legacy_special_mapping_vmops = {\n\t.close = special_mapping_close,\n\t.fault = special_mapping_fault,\n};\n\nstatic vm_fault_t special_mapping_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tpgoff_t pgoff;\n\tstruct page **pages;\n\n\tif (vma->vm_ops == &legacy_special_mapping_vmops) {\n\t\tpages = vma->vm_private_data;\n\t} else {\n\t\tstruct vm_special_mapping *sm = vma->vm_private_data;\n\n\t\tif (sm->fault)\n\t\t\treturn sm->fault(sm, vmf->vma, vmf);\n\n\t\tpages = sm->pages;\n\t}\n\n\tfor (pgoff = vmf->pgoff; pgoff && *pages; ++pages)\n\t\tpgoff--;\n\n\tif (*pages) {\n\t\tstruct page *page = *pages;\n\t\tget_page(page);\n\t\tvmf->page = page;\n\t\treturn 0;\n\t}\n\n\treturn VM_FAULT_SIGBUS;\n}"
  },
  {
    "function_name": "special_mapping_mremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3332-3343",
    "snippet": "static int special_mapping_mremap(struct vm_area_struct *new_vma)\n{\n\tstruct vm_special_mapping *sm = new_vma->vm_private_data;\n\n\tif (WARN_ON_ONCE(current->mm != new_vma->vm_mm))\n\t\treturn -EFAULT;\n\n\tif (sm->mremap)\n\t\treturn sm->mremap(sm, new_vma);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sm->mremap",
          "args": [
            "sm",
            "new_vma"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->mm != new_vma->vm_mm"
          ],
          "line": 3336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int special_mapping_mremap(struct vm_area_struct *new_vma)\n{\n\tstruct vm_special_mapping *sm = new_vma->vm_private_data;\n\n\tif (WARN_ON_ONCE(current->mm != new_vma->vm_mm))\n\t\treturn -EFAULT;\n\n\tif (sm->mremap)\n\t\treturn sm->mremap(sm, new_vma);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "special_mapping_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3327-3330",
    "snippet": "static const char *special_mapping_name(struct vm_area_struct *vma)\n{\n\treturn ((struct vm_special_mapping *)vma->vm_private_data)->name;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic const char *special_mapping_name(struct vm_area_struct *vma)\n{\n\treturn ((struct vm_special_mapping *)vma->vm_private_data)->name;\n}"
  },
  {
    "function_name": "special_mapping_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3323-3325",
    "snippet": "static void special_mapping_close(struct vm_area_struct *vma)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void special_mapping_close(struct vm_area_struct *vma)\n{\n}"
  },
  {
    "function_name": "vm_stat_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3306-3316",
    "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_data_mapping",
          "args": [
            "flags"
          ],
          "line": 3314
        },
        "resolved": true,
        "details": {
          "function_name": "is_data_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "278-281",
          "snippet": "static inline bool is_data_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_WRITE | VM_SHARED | VM_STACK)) == VM_WRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_data_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_WRITE | VM_SHARED | VM_STACK)) == VM_WRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_stack_mapping",
          "args": [
            "flags"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "is_stack_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "270-273",
          "snippet": "static inline bool is_stack_mapping(vm_flags_t flags)\n{\n\treturn (flags & VM_STACK) == VM_STACK;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_stack_mapping(vm_flags_t flags)\n{\n\treturn (flags & VM_STACK) == VM_STACK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_exec_mapping",
          "args": [
            "flags"
          ],
          "line": 3310
        },
        "resolved": true,
        "details": {
          "function_name": "is_exec_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "259-262",
          "snippet": "static inline bool is_exec_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_EXEC | VM_WRITE | VM_STACK)) == VM_EXEC;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_exec_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_EXEC | VM_WRITE | VM_STACK)) == VM_EXEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
  },
  {
    "function_name": "may_expand_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3281-3304",
    "snippet": "bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ignore_rlimit_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\"",
            "current->comm",
            "current->pid",
            "(mm->data_vm + npages) << PAGE_SHIFT",
            "rlimit(RLIMIT_DATA)",
            "ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\""
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_DATA"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit_max",
          "args": [
            "RLIMIT_DATA"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_DATA"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_DATA"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_data_mapping",
          "args": [
            "flags"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "is_data_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "278-281",
          "snippet": "static inline bool is_data_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_WRITE | VM_SHARED | VM_STACK)) == VM_WRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_data_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_WRITE | VM_SHARED | VM_STACK)) == VM_WRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_AS"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool ignore_rlimit_data;\n\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "copy_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3202-3275",
    "snippet": "struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks)\n{\n\tstruct vm_area_struct *vma = *vmap;\n\tunsigned long vma_start = vma->vm_start;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tbool faulted_in_anon_vma = true;\n\n\t/*\n\t * If anonymous vma has not yet been faulted, update new pgoff\n\t * to match new location, to increase its chance of merging.\n\t */\n\tif (unlikely(vma_is_anonymous(vma) && !vma->anon_vma)) {\n\t\tpgoff = addr >> PAGE_SHIFT;\n\t\tfaulted_in_anon_vma = false;\n\t}\n\n\tif (find_vma_links(mm, addr, addr + len, &prev, &rb_link, &rb_parent))\n\t\treturn NULL;\t/* should never get here */\n\tnew_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,\n\t\t\t    vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t    vma->vm_userfaultfd_ctx);\n\tif (new_vma) {\n\t\t/*\n\t\t * Source vma may have been merged into new_vma\n\t\t */\n\t\tif (unlikely(vma_start >= new_vma->vm_start &&\n\t\t\t     vma_start < new_vma->vm_end)) {\n\t\t\t/*\n\t\t\t * The only way we can get a vma_merge with\n\t\t\t * self during an mremap is if the vma hasn't\n\t\t\t * been faulted in yet and we were allowed to\n\t\t\t * reset the dst vma->vm_pgoff to the\n\t\t\t * destination address of the mremap to allow\n\t\t\t * the merge to happen. mremap must change the\n\t\t\t * vm_pgoff linearity between src and dst vmas\n\t\t\t * (in turn preventing a vma_merge) to be\n\t\t\t * safe. It is only safe to keep the vm_pgoff\n\t\t\t * linear if there are no pages mapped yet.\n\t\t\t */\n\t\t\tVM_BUG_ON_VMA(faulted_in_anon_vma, new_vma);\n\t\t\t*vmap = vma = new_vma;\n\t\t}\n\t\t*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);\n\t} else {\n\t\tnew_vma = vm_area_dup(vma);\n\t\tif (!new_vma)\n\t\t\tgoto out;\n\t\tnew_vma->vm_start = addr;\n\t\tnew_vma->vm_end = addr + len;\n\t\tnew_vma->vm_pgoff = pgoff;\n\t\tif (vma_dup_policy(vma, new_vma))\n\t\t\tgoto out_free_vma;\n\t\tif (anon_vma_clone(new_vma, vma))\n\t\t\tgoto out_free_mempol;\n\t\tif (new_vma->vm_file)\n\t\t\tget_file(new_vma->vm_file);\n\t\tif (new_vma->vm_ops && new_vma->vm_ops->open)\n\t\t\tnew_vma->vm_ops->open(new_vma);\n\t\tvma_link(mm, new_vma, prev, rb_link, rb_parent);\n\t\t*need_rmap_locks = false;\n\t}\n\treturn new_vma;\n\nout_free_mempol:\n\tmpol_put(vma_policy(new_vma));\nout_free_vma:\n\tvm_area_free(new_vma);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_area_free",
          "args": [
            "new_vma"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "vma_policy(new_vma)"
          ],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "new_vma"
          ],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_link",
          "args": [
            "mm",
            "new_vma",
            "prev",
            "rb_link",
            "rb_parent"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "vma_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "637-656",
          "snippet": "static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_vma->vm_ops->open",
          "args": [
            "new_vma"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "new_vma->vm_file"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_clone",
          "args": [
            "new_vma",
            "vma"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "261-308",
          "snippet": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_dup_policy",
          "args": [
            "vma",
            "new_vma"
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "vma_dup_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2088-2096",
          "snippet": "int vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nint vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_area_dup",
          "args": [
            "vma"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "faulted_in_anon_vma",
            "new_vma"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma_start >= new_vma->vm_start &&\n\t\t\t     vma_start < new_vma->vm_end"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "prev",
            "addr",
            "addr + len",
            "vma->vm_flags",
            "vma->anon_vma",
            "vma->vm_file",
            "pgoff",
            "vma_policy(vma)",
            "vma->vm_userfaultfd_ctx"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1132-1223",
          "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma_links",
          "args": [
            "mm",
            "addr",
            "addr + len",
            "&prev",
            "&rb_link",
            "&rb_parent"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "523-555",
          "snippet": "static int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma_is_anonymous(vma) && !vma->anon_vma"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *copy_vma(struct vm_area_struct **vmap,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks)\n{\n\tstruct vm_area_struct *vma = *vmap;\n\tunsigned long vma_start = vma->vm_start;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tbool faulted_in_anon_vma = true;\n\n\t/*\n\t * If anonymous vma has not yet been faulted, update new pgoff\n\t * to match new location, to increase its chance of merging.\n\t */\n\tif (unlikely(vma_is_anonymous(vma) && !vma->anon_vma)) {\n\t\tpgoff = addr >> PAGE_SHIFT;\n\t\tfaulted_in_anon_vma = false;\n\t}\n\n\tif (find_vma_links(mm, addr, addr + len, &prev, &rb_link, &rb_parent))\n\t\treturn NULL;\t/* should never get here */\n\tnew_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,\n\t\t\t    vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t    vma->vm_userfaultfd_ctx);\n\tif (new_vma) {\n\t\t/*\n\t\t * Source vma may have been merged into new_vma\n\t\t */\n\t\tif (unlikely(vma_start >= new_vma->vm_start &&\n\t\t\t     vma_start < new_vma->vm_end)) {\n\t\t\t/*\n\t\t\t * The only way we can get a vma_merge with\n\t\t\t * self during an mremap is if the vma hasn't\n\t\t\t * been faulted in yet and we were allowed to\n\t\t\t * reset the dst vma->vm_pgoff to the\n\t\t\t * destination address of the mremap to allow\n\t\t\t * the merge to happen. mremap must change the\n\t\t\t * vm_pgoff linearity between src and dst vmas\n\t\t\t * (in turn preventing a vma_merge) to be\n\t\t\t * safe. It is only safe to keep the vm_pgoff\n\t\t\t * linear if there are no pages mapped yet.\n\t\t\t */\n\t\t\tVM_BUG_ON_VMA(faulted_in_anon_vma, new_vma);\n\t\t\t*vmap = vma = new_vma;\n\t\t}\n\t\t*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);\n\t} else {\n\t\tnew_vma = vm_area_dup(vma);\n\t\tif (!new_vma)\n\t\t\tgoto out;\n\t\tnew_vma->vm_start = addr;\n\t\tnew_vma->vm_end = addr + len;\n\t\tnew_vma->vm_pgoff = pgoff;\n\t\tif (vma_dup_policy(vma, new_vma))\n\t\t\tgoto out_free_vma;\n\t\tif (anon_vma_clone(new_vma, vma))\n\t\t\tgoto out_free_mempol;\n\t\tif (new_vma->vm_file)\n\t\t\tget_file(new_vma->vm_file);\n\t\tif (new_vma->vm_ops && new_vma->vm_ops->open)\n\t\t\tnew_vma->vm_ops->open(new_vma);\n\t\tvma_link(mm, new_vma, prev, rb_link, rb_parent);\n\t\t*need_rmap_locks = false;\n\t}\n\treturn new_vma;\n\nout_free_mempol:\n\tmpol_put(vma_policy(new_vma));\nout_free_vma:\n\tvm_area_free(new_vma);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "insert_vm_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3165-3196",
    "snippet": "int insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\treturn -ENOMEM;\n\tif ((vma->vm_flags & VM_ACCOUNT) &&\n\t     security_vm_enough_memory_mm(mm, vma_pages(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The vm_pgoff of a purely anonymous vma should be irrelevant\n\t * until its first write fault, when page's anon_vma and index\n\t * are set.  But now set the vm_pgoff it will almost certainly\n\t * end up with (unless mremap moves it elsewhere before that\n\t * first wfault), so /proc/pid/maps tells a consistent story.\n\t *\n\t * By setting it to reflect the virtual start address of the\n\t * vma, merges and splits can happen in a seamless way, just\n\t * using the existing file pgoff checks and manipulations.\n\t * Similarly in do_mmap_pgoff and in do_brk.\n\t */\n\tif (vma_is_anonymous(vma)) {\n\t\tBUG_ON(vma->anon_vma);\n\t\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_link",
          "args": [
            "mm",
            "vma",
            "prev",
            "rb_link",
            "rb_parent"
          ],
          "line": 3194
        },
        "resolved": true,
        "details": {
          "function_name": "vma_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "637-656",
          "snippet": "static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vma->anon_vma"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_vm_enough_memory_mm",
          "args": [
            "mm",
            "vma_pages(vma)"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 3174
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma_links",
          "args": [
            "mm",
            "vma->vm_start",
            "vma->vm_end",
            "&prev",
            "&rb_link",
            "&rb_parent"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "523-555",
          "snippet": "static int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nint insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\treturn -ENOMEM;\n\tif ((vma->vm_flags & VM_ACCOUNT) &&\n\t     security_vm_enough_memory_mm(mm, vma_pages(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The vm_pgoff of a purely anonymous vma should be irrelevant\n\t * until its first write fault, when page's anon_vma and index\n\t * are set.  But now set the vm_pgoff it will almost certainly\n\t * end up with (unless mremap moves it elsewhere before that\n\t * first wfault), so /proc/pid/maps tells a consistent story.\n\t *\n\t * By setting it to reflect the virtual start address of the\n\t * vma, merges and splits can happen in a seamless way, just\n\t * using the existing file pgoff checks and manipulations.\n\t * Similarly in do_mmap_pgoff and in do_brk.\n\t */\n\tif (vma_is_anonymous(vma)) {\n\t\tBUG_ON(vma->anon_vma);\n\t\tvma->vm_pgoff = vma->vm_start >> PAGE_SHIFT;\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\treturn 0;\n}"
  },
  {
    "function_name": "exit_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3092-3159",
    "snippet": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\n\t/* mm's last user has gone, and its about to be pulled down */\n\tmmu_notifier_release(mm);\n\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\t/*\n\t\t * Manually reap the mm to free as much memory as possible.\n\t\t * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard\n\t\t * this mm from further consideration.  Taking mm->mmap_sem for\n\t\t * write after setting MMF_OOM_SKIP will guarantee that the oom\n\t\t * reaper will not run on this mm again after mmap_sem is\n\t\t * dropped.\n\t\t *\n\t\t * Nothing can be holding mm->mmap_sem here and the above call\n\t\t * to mmu_notifier_release(mm) ensures mmu notifier callbacks in\n\t\t * __oom_reap_task_mm() will not block.\n\t\t *\n\t\t * This needs to be done before calling munlock_vma_pages_all(),\n\t\t * which clears VM_LOCKED, otherwise the oom reaper cannot\n\t\t * reliably test it.\n\t\t */\n\t\t(void)__oom_reap_task_mm(mm);\n\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\n\tarch_exit_mmap(mm);\n\n\tvma = mm->mmap;\n\tif (!vma)\t/* Can happen if dup_mmap() received an OOM */\n\t\treturn;\n\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t/* update_hiwater_rss(mm) here? but nobody should be looking */\n\t/* Use -1 here to ensure all VMAs in the mm are unmapped */\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\n\t/*\n\t * Walk the list again, actually closing and freeing it,\n\t * with preemption enabled, without holding any MM locks.\n\t */\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "nr_accounted"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_vma",
          "args": [
            "vma"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "remove_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "175-187",
          "snippet": "static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "0",
            "-1"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "247-261",
          "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pgtables",
          "args": [
            "&tlb",
            "vma",
            "FIRST_USER_ADDRESS",
            "USER_PGTABLES_CEILING"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "free_pgtables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "368-401",
          "snippet": "void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_vmas",
          "args": [
            "&tlb",
            "vma",
            "0",
            "-1"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_vmas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1331-1341",
          "snippet": "void unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "0",
            "-1"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "240-245",
          "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_mm",
          "args": [
            "mm"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_exit_mmap",
          "args": [
            "mm"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&mm->flags"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__oom_reap_task_mm",
          "args": [
            "mm"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "__oom_reap_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "491-536",
          "snippet": "bool __oom_reap_task_mm(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\tconst unsigned long start = vma->vm_start;\n\t\t\tconst unsigned long end = vma->vm_end;\n\t\t\tstruct mmu_gather tlb;\n\n\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {\n\t\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t\t\tret = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nbool __oom_reap_task_mm(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\tconst unsigned long start = vma->vm_start;\n\t\t\tconst unsigned long end = vma->vm_end;\n\t\t\tstruct mmu_gather tlb;\n\n\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {\n\t\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t\t\tret = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mm_is_oom_victim(mm)"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_is_oom_victim",
          "args": [
            "mm"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_release",
          "args": [
            "mm"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_notifier_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "57-103",
          "snippet": "void __mmu_notifier_release(struct mm_struct *mm)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\t/*\n\t * SRCU here will block mmu_notifier_unregister until\n\t * ->release returns.\n\t */\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist)\n\t\t/*\n\t\t * If ->release runs before mmu_notifier_unregister it must be\n\t\t * handled, as it's the only way for the driver to flush all\n\t\t * existing sptes and stop the driver from establishing any more\n\t\t * sptes before all the pages in the mm are freed.\n\t\t */\n\t\tif (mn->ops->release)\n\t\t\tmn->ops->release(mn, mm);\n\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\twhile (unlikely(!hlist_empty(&mm->mmu_notifier_mm->list))) {\n\t\tmn = hlist_entry(mm->mmu_notifier_mm->list.first,\n\t\t\t\t struct mmu_notifier,\n\t\t\t\t hlist);\n\t\t/*\n\t\t * We arrived before mmu_notifier_unregister so\n\t\t * mmu_notifier_unregister will do nothing other than to wait\n\t\t * for ->release to finish and for mmu_notifier_unregister to\n\t\t * return.\n\t\t */\n\t\thlist_del_init_rcu(&mn->hlist);\n\t}\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\tsrcu_read_unlock(&srcu, id);\n\n\t/*\n\t * synchronize_srcu here prevents mmu_notifier_release from returning to\n\t * exit_mmap (which would proceed with freeing all pages in the mm)\n\t * until the ->release method returns, if it was invoked by\n\t * mmu_notifier_unregister.\n\t *\n\t * The mmu_notifier_mm can't go away from under us because one mm_count\n\t * is held by exit_mmap.\n\t */\n\tsynchronize_srcu(&srcu);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid __mmu_notifier_release(struct mm_struct *mm)\n{\n\tstruct mmu_notifier *mn;\n\tint id;\n\n\t/*\n\t * SRCU here will block mmu_notifier_unregister until\n\t * ->release returns.\n\t */\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist)\n\t\t/*\n\t\t * If ->release runs before mmu_notifier_unregister it must be\n\t\t * handled, as it's the only way for the driver to flush all\n\t\t * existing sptes and stop the driver from establishing any more\n\t\t * sptes before all the pages in the mm are freed.\n\t\t */\n\t\tif (mn->ops->release)\n\t\t\tmn->ops->release(mn, mm);\n\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\twhile (unlikely(!hlist_empty(&mm->mmu_notifier_mm->list))) {\n\t\tmn = hlist_entry(mm->mmu_notifier_mm->list.first,\n\t\t\t\t struct mmu_notifier,\n\t\t\t\t hlist);\n\t\t/*\n\t\t * We arrived before mmu_notifier_unregister so\n\t\t * mmu_notifier_unregister will do nothing other than to wait\n\t\t * for ->release to finish and for mmu_notifier_unregister to\n\t\t * return.\n\t\t */\n\t\thlist_del_init_rcu(&mn->hlist);\n\t}\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\tsrcu_read_unlock(&srcu, id);\n\n\t/*\n\t * synchronize_srcu here prevents mmu_notifier_release from returning to\n\t * exit_mmap (which would proceed with freeing all pages in the mm)\n\t * until the ->release method returns, if it was invoked by\n\t * mmu_notifier_unregister.\n\t *\n\t * The mmu_notifier_mm can't go away from under us because one mm_count\n\t * is held by exit_mmap.\n\t */\n\tsynchronize_srcu(&srcu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\n\t/* mm's last user has gone, and its about to be pulled down */\n\tmmu_notifier_release(mm);\n\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\t/*\n\t\t * Manually reap the mm to free as much memory as possible.\n\t\t * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard\n\t\t * this mm from further consideration.  Taking mm->mmap_sem for\n\t\t * write after setting MMF_OOM_SKIP will guarantee that the oom\n\t\t * reaper will not run on this mm again after mmap_sem is\n\t\t * dropped.\n\t\t *\n\t\t * Nothing can be holding mm->mmap_sem here and the above call\n\t\t * to mmu_notifier_release(mm) ensures mmu notifier callbacks in\n\t\t * __oom_reap_task_mm() will not block.\n\t\t *\n\t\t * This needs to be done before calling munlock_vma_pages_all(),\n\t\t * which clears VM_LOCKED, otherwise the oom reaper cannot\n\t\t * reliably test it.\n\t\t */\n\t\t(void)__oom_reap_task_mm(mm);\n\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\n\tarch_exit_mmap(mm);\n\n\tvma = mm->mmap;\n\tif (!vma)\t/* Can happen if dup_mmap() received an OOM */\n\t\treturn;\n\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t/* update_hiwater_rss(mm) here? but nobody should be looking */\n\t/* Use -1 here to ensure all VMAs in the mm are unmapped */\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\n\t/*\n\t * Walk the list again, actually closing and freeing it,\n\t * with preemption enabled, without holding any MM locks.\n\t */\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}"
  },
  {
    "function_name": "vm_brk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3085-3088",
    "snippet": "int vm_brk(unsigned long addr, unsigned long len)\n{\n\treturn vm_brk_flags(addr, len, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_brk_flags",
          "args": [
            "addr",
            "len",
            "0"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "vm_brk_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3058-3082",
          "snippet": "int vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long len;\n\tint ret;\n\tbool populate;\n\tLIST_HEAD(uf);\n\n\tlen = PAGE_ALIGN(request);\n\tif (len < request)\n\t\treturn -ENOMEM;\n\tif (!len)\n\t\treturn 0;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = do_brk_flags(addr, len, flags, &uf);\n\tpopulate = ((mm->def_flags & VM_LOCKED) != 0);\n\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate && !ret)\n\t\tmm_populate(addr, len);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long len;\n\tint ret;\n\tbool populate;\n\tLIST_HEAD(uf);\n\n\tlen = PAGE_ALIGN(request);\n\tif (len < request)\n\t\treturn -ENOMEM;\n\tif (!len)\n\t\treturn 0;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = do_brk_flags(addr, len, flags, &uf);\n\tpopulate = ((mm->def_flags & VM_LOCKED) != 0);\n\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate && !ret)\n\t\tmm_populate(addr, len);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint vm_brk(unsigned long addr, unsigned long len)\n{\n\treturn vm_brk_flags(addr, len, 0);\n}"
  },
  {
    "function_name": "vm_brk_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "3058-3082",
    "snippet": "int vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long len;\n\tint ret;\n\tbool populate;\n\tLIST_HEAD(uf);\n\n\tlen = PAGE_ALIGN(request);\n\tif (len < request)\n\t\treturn -ENOMEM;\n\tif (!len)\n\t\treturn 0;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = do_brk_flags(addr, len, flags, &uf);\n\tpopulate = ((mm->def_flags & VM_LOCKED) != 0);\n\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate && !ret)\n\t\tmm_populate(addr, len);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mm_populate",
          "args": [
            "addr",
            "len"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_unmap_complete",
          "args": [
            "mm",
            "&uf"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_brk_flags",
          "args": [
            "addr",
            "len",
            "flags",
            "&uf"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "do_brk_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2980-3056",
          "snippet": "static int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tpgoff_t pgoff = addr >> PAGE_SHIFT;\n\tint error;\n\n\t/* Until we need other flags, refuse anything except VM_EXEC. */\n\tif ((flags & (~VM_EXEC)) != 0)\n\t\treturn -EINVAL;\n\tflags |= VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;\n\n\terror = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);\n\tif (offset_in_page(error))\n\t\treturn error;\n\n\terror = mlock_future_check(mm, mm->def_flags, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * mm->mmap_sem is required to protect against another thread\n\t * changing the mappings in case we sleep.\n\t */\n\tverify_mm_writelocked(mm);\n\n\t/*\n\t * Clear old maps.  this also does some error checking for us\n\t */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check against address space limits *after* clearing old maps... */\n\tif (!may_expand_vm(mm, flags, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tif (security_vm_enough_memory_mm(mm, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\t/* Can we just expand an old private anonymous mapping? */\n\tvma = vma_merge(mm, prev, addr, addr + len, flags,\n\t\t\tNULL, NULL, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * create a vma struct for an anonymous mapping\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\tvm_unacct_memory(len >> PAGE_SHIFT);\n\t\treturn -ENOMEM;\n\t}\n\n\tvma_set_anonymous(vma);\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_pgoff = pgoff;\n\tvma->vm_flags = flags;\n\tvma->vm_page_prot = vm_get_page_prot(flags);\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\nout:\n\tperf_event_mmap(vma);\n\tmm->total_vm += len >> PAGE_SHIFT;\n\tmm->data_vm += len >> PAGE_SHIFT;\n\tif (flags & VM_LOCKED)\n\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nstatic int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tpgoff_t pgoff = addr >> PAGE_SHIFT;\n\tint error;\n\n\t/* Until we need other flags, refuse anything except VM_EXEC. */\n\tif ((flags & (~VM_EXEC)) != 0)\n\t\treturn -EINVAL;\n\tflags |= VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;\n\n\terror = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);\n\tif (offset_in_page(error))\n\t\treturn error;\n\n\terror = mlock_future_check(mm, mm->def_flags, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * mm->mmap_sem is required to protect against another thread\n\t * changing the mappings in case we sleep.\n\t */\n\tverify_mm_writelocked(mm);\n\n\t/*\n\t * Clear old maps.  this also does some error checking for us\n\t */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check against address space limits *after* clearing old maps... */\n\tif (!may_expand_vm(mm, flags, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tif (security_vm_enough_memory_mm(mm, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\t/* Can we just expand an old private anonymous mapping? */\n\tvma = vma_merge(mm, prev, addr, addr + len, flags,\n\t\t\tNULL, NULL, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * create a vma struct for an anonymous mapping\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\tvm_unacct_memory(len >> PAGE_SHIFT);\n\t\treturn -ENOMEM;\n\t}\n\n\tvma_set_anonymous(vma);\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_pgoff = pgoff;\n\tvma->vm_flags = flags;\n\tvma->vm_page_prot = vm_get_page_prot(flags);\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\nout:\n\tperf_event_mmap(vma);\n\tmm->total_vm += len >> PAGE_SHIFT;\n\tmm->data_vm += len >> PAGE_SHIFT;\n\tif (flags & VM_LOCKED)\n\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "request"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "uf"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long len;\n\tint ret;\n\tbool populate;\n\tLIST_HEAD(uf);\n\n\tlen = PAGE_ALIGN(request);\n\tif (len < request)\n\t\treturn -ENOMEM;\n\tif (!len)\n\t\treturn 0;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = do_brk_flags(addr, len, flags, &uf);\n\tpopulate = ((mm->def_flags & VM_LOCKED) != 0);\n\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate && !ret)\n\t\tmm_populate(addr, len);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_brk_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2980-3056",
    "snippet": "static int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tpgoff_t pgoff = addr >> PAGE_SHIFT;\n\tint error;\n\n\t/* Until we need other flags, refuse anything except VM_EXEC. */\n\tif ((flags & (~VM_EXEC)) != 0)\n\t\treturn -EINVAL;\n\tflags |= VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;\n\n\terror = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);\n\tif (offset_in_page(error))\n\t\treturn error;\n\n\terror = mlock_future_check(mm, mm->def_flags, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * mm->mmap_sem is required to protect against another thread\n\t * changing the mappings in case we sleep.\n\t */\n\tverify_mm_writelocked(mm);\n\n\t/*\n\t * Clear old maps.  this also does some error checking for us\n\t */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check against address space limits *after* clearing old maps... */\n\tif (!may_expand_vm(mm, flags, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tif (security_vm_enough_memory_mm(mm, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\t/* Can we just expand an old private anonymous mapping? */\n\tvma = vma_merge(mm, prev, addr, addr + len, flags,\n\t\t\tNULL, NULL, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * create a vma struct for an anonymous mapping\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\tvm_unacct_memory(len >> PAGE_SHIFT);\n\t\treturn -ENOMEM;\n\t}\n\n\tvma_set_anonymous(vma);\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_pgoff = pgoff;\n\tvma->vm_flags = flags;\n\tvma->vm_page_prot = vm_get_page_prot(flags);\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\nout:\n\tperf_event_mmap(vma);\n\tmm->total_vm += len >> PAGE_SHIFT;\n\tmm->data_vm += len >> PAGE_SHIFT;\n\tif (flags & VM_LOCKED)\n\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_mmap",
          "args": [
            "vma"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_link",
          "args": [
            "mm",
            "vma",
            "prev",
            "rb_link",
            "rb_parent"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "vma_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "637-656",
          "snippet": "static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_get_page_prot",
          "args": [
            "flags"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "vm_get_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "110-117",
          "snippet": "pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_set_anonymous",
          "args": [
            "vma"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "len >> PAGE_SHIFT"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_area_alloc",
          "args": [
            "mm"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "prev",
            "addr",
            "addr + len",
            "flags",
            "NULL",
            "NULL",
            "pgoff",
            "NULL",
            "NULL_VM_UFFD_CTX"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1132-1223",
          "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_vm_enough_memory_mm",
          "args": [
            "mm",
            "len >> PAGE_SHIFT"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_expand_vm",
          "args": [
            "mm",
            "flags",
            "len >> PAGE_SHIFT"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "may_expand_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3281-3304",
          "snippet": "bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ignore_rlimit_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool ignore_rlimit_data;\n\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_munmap",
          "args": [
            "mm",
            "addr",
            "len",
            "uf"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "do_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2822-2826",
          "snippet": "int do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma_links",
          "args": [
            "mm",
            "addr",
            "addr + len",
            "&prev",
            "&rb_link",
            "&rb_parent"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "523-555",
          "snippet": "static int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_mm_writelocked",
          "args": [
            "mm"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "verify_mm_writelocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2965-2973",
          "snippet": "static inline void verify_mm_writelocked(struct mm_struct *mm)\n{\n#ifdef CONFIG_DEBUG_VM\n\tif (unlikely(down_read_trylock(&mm->mmap_sem))) {\n\t\tWARN_ON(1);\n\t\tup_read(&mm->mmap_sem);\n\t}\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void verify_mm_writelocked(struct mm_struct *mm)\n{\n#ifdef CONFIG_DEBUG_VM\n\tif (unlikely(down_read_trylock(&mm->mmap_sem))) {\n\t\tWARN_ON(1);\n\t\tup_read(&mm->mmap_sem);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlock_future_check",
          "args": [
            "mm",
            "mm->def_flags",
            "len"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_future_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1333-1349",
          "snippet": "static inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "error"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unmapped_area",
          "args": [
            "NULL",
            "addr",
            "len",
            "0",
            "MAP_FIXED"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "get_unmapped_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2170-2210",
          "snippet": "unsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nstatic int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tpgoff_t pgoff = addr >> PAGE_SHIFT;\n\tint error;\n\n\t/* Until we need other flags, refuse anything except VM_EXEC. */\n\tif ((flags & (~VM_EXEC)) != 0)\n\t\treturn -EINVAL;\n\tflags |= VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;\n\n\terror = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);\n\tif (offset_in_page(error))\n\t\treturn error;\n\n\terror = mlock_future_check(mm, mm->def_flags, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * mm->mmap_sem is required to protect against another thread\n\t * changing the mappings in case we sleep.\n\t */\n\tverify_mm_writelocked(mm);\n\n\t/*\n\t * Clear old maps.  this also does some error checking for us\n\t */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check against address space limits *after* clearing old maps... */\n\tif (!may_expand_vm(mm, flags, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tif (security_vm_enough_memory_mm(mm, len >> PAGE_SHIFT))\n\t\treturn -ENOMEM;\n\n\t/* Can we just expand an old private anonymous mapping? */\n\tvma = vma_merge(mm, prev, addr, addr + len, flags,\n\t\t\tNULL, NULL, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * create a vma struct for an anonymous mapping\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\tvm_unacct_memory(len >> PAGE_SHIFT);\n\t\treturn -ENOMEM;\n\t}\n\n\tvma_set_anonymous(vma);\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_pgoff = pgoff;\n\tvma->vm_flags = flags;\n\tvma->vm_page_prot = vm_get_page_prot(flags);\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\nout:\n\tperf_event_mmap(vma);\n\tmm->total_vm += len >> PAGE_SHIFT;\n\tmm->data_vm += len >> PAGE_SHIFT;\n\tif (flags & VM_LOCKED)\n\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\treturn 0;\n}"
  },
  {
    "function_name": "verify_mm_writelocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2965-2973",
    "snippet": "static inline void verify_mm_writelocked(struct mm_struct *mm)\n{\n#ifdef CONFIG_DEBUG_VM\n\tif (unlikely(down_read_trylock(&mm->mmap_sem))) {\n\t\tWARN_ON(1);\n\t\tup_read(&mm->mmap_sem);\n\t}\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "down_read_trylock(&mm->mmap_sem)"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void verify_mm_writelocked(struct mm_struct *mm)\n{\n#ifdef CONFIG_DEBUG_VM\n\tif (unlikely(down_read_trylock(&mm->mmap_sem))) {\n\t\tWARN_ON(1);\n\t\tup_read(&mm->mmap_sem);\n\t}\n#endif\n}"
  },
  {
    "function_name": "vm_munmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2853-2856",
    "snippet": "int vm_munmap(unsigned long start, size_t len)\n{\n\treturn __vm_munmap(start, len, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vm_munmap",
          "args": [
            "start",
            "len",
            "false"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "__vm_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2828-2851",
          "snippet": "static int __vm_munmap(unsigned long start, size_t len, bool downgrade)\n{\n\tint ret;\n\tstruct mm_struct *mm = current->mm;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = __do_munmap(mm, start, len, &uf, downgrade);\n\t/*\n\t * Returning 1 indicates mmap_sem is downgraded.\n\t * But 1 is not legal return value of vm_munmap() and munmap(), reset\n\t * it to 0 before return.\n\t */\n\tif (ret == 1) {\n\t\tup_read(&mm->mmap_sem);\n\t\tret = 0;\n\t} else\n\t\tup_write(&mm->mmap_sem);\n\n\tuserfaultfd_unmap_complete(mm, &uf);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nstatic int __vm_munmap(unsigned long start, size_t len, bool downgrade)\n{\n\tint ret;\n\tstruct mm_struct *mm = current->mm;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = __do_munmap(mm, start, len, &uf, downgrade);\n\t/*\n\t * Returning 1 indicates mmap_sem is downgraded.\n\t * But 1 is not legal return value of vm_munmap() and munmap(), reset\n\t * it to 0 before return.\n\t */\n\tif (ret == 1) {\n\t\tup_read(&mm->mmap_sem);\n\t\tret = 0;\n\t} else\n\t\tup_write(&mm->mmap_sem);\n\n\tuserfaultfd_unmap_complete(mm, &uf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint vm_munmap(unsigned long start, size_t len)\n{\n\treturn __vm_munmap(start, len, false);\n}"
  },
  {
    "function_name": "__vm_munmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2828-2851",
    "snippet": "static int __vm_munmap(unsigned long start, size_t len, bool downgrade)\n{\n\tint ret;\n\tstruct mm_struct *mm = current->mm;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = __do_munmap(mm, start, len, &uf, downgrade);\n\t/*\n\t * Returning 1 indicates mmap_sem is downgraded.\n\t * But 1 is not legal return value of vm_munmap() and munmap(), reset\n\t * it to 0 before return.\n\t */\n\tif (ret == 1) {\n\t\tup_read(&mm->mmap_sem);\n\t\tret = 0;\n\t} else\n\t\tup_write(&mm->mmap_sem);\n\n\tuserfaultfd_unmap_complete(mm, &uf);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_unmap_complete",
          "args": [
            "mm",
            "&uf"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_munmap",
          "args": [
            "mm",
            "start",
            "len",
            "&uf",
            "downgrade"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "__do_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2714-2820",
          "snippet": "int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);",
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "uf"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nstatic int __vm_munmap(unsigned long start, size_t len, bool downgrade)\n{\n\tint ret;\n\tstruct mm_struct *mm = current->mm;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = __do_munmap(mm, start, len, &uf, downgrade);\n\t/*\n\t * Returning 1 indicates mmap_sem is downgraded.\n\t * But 1 is not legal return value of vm_munmap() and munmap(), reset\n\t * it to 0 before return.\n\t */\n\tif (ret == 1) {\n\t\tup_read(&mm->mmap_sem);\n\t\tret = 0;\n\t} else\n\t\tup_write(&mm->mmap_sem);\n\n\tuserfaultfd_unmap_complete(mm, &uf);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_munmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2822-2826",
    "snippet": "int do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_munmap",
          "args": [
            "mm",
            "start",
            "len",
            "uf",
            "false"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "__do_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2714-2820",
          "snippet": "int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);",
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}"
  },
  {
    "function_name": "__do_munmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2714-2820",
    "snippet": "int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);",
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_vma_list",
          "args": [
            "mm",
            "vma"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "remove_vma_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2562-2578",
          "snippet": "static void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tunsigned long nr_accounted = 0;\n\n\t/* Update high watermark before we lower total_vm */\n\tupdate_hiwater_vm(mm);\n\tdo {\n\t\tlong nrpages = vma_pages(vma);\n\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += nrpages;\n\t\tvm_stat_account(mm, vma->vm_flags, -nrpages);\n\t\tvma = remove_vma(vma);\n\t} while (vma);\n\tvm_unacct_memory(nr_accounted);\n\tvalidate_mm(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tunsigned long nr_accounted = 0;\n\n\t/* Update high watermark before we lower total_vm */\n\tupdate_hiwater_vm(mm);\n\tdo {\n\t\tlong nrpages = vma_pages(vma);\n\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += nrpages;\n\t\tvm_stat_account(mm, vma->vm_flags, -nrpages);\n\t\tvma = remove_vma(vma);\n\t} while (vma);\n\tvm_unacct_memory(nr_accounted);\n\tvalidate_mm(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_region",
          "args": [
            "mm",
            "vma",
            "prev",
            "start",
            "end"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2585-2599",
          "snippet": "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "downgrade_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_unmap",
          "args": [
            "mm",
            "vma",
            "start",
            "end"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detach_vmas_to_be_unmapped",
          "args": [
            "mm",
            "vma",
            "prev",
            "end"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "detach_vmas_to_be_unmapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2605-2630",
          "snippet": "static void\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic void\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "munlock_vma_pages_all",
          "args": [
            "tmp"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_unmap_prep",
          "args": [
            "vma",
            "start",
            "end",
            "uf"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "uf"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__split_vma",
          "args": [
            "mm",
            "last",
            "end",
            "1"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "__split_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2636-2694",
          "snippet": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "end"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2215-2244",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "start"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tend = start + len;\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = prev ? prev->vm_next : mm->mmap;\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tdetach_vmas_to_be_unmapped(mm, vma, prev, end);\n\n\t/*\n\t * mpx unmap needs to be called with mmap_sem held for write.\n\t * It is safe to call it before unmap_region().\n\t */\n\tarch_unmap(mm, vma, start, end);\n\n\tif (downgrade)\n\t\tdowngrade_write(&mm->mmap_sem);\n\n\tunmap_region(mm, vma, prev, start, end);\n\n\t/* Fix up all other VM information */\n\tremove_vma_list(mm, vma);\n\n\treturn downgrade ? 1 : 0;\n}"
  },
  {
    "function_name": "split_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2700-2707",
    "snippet": "int split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\treturn __split_vma(mm, vma, addr, new_below);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__split_vma",
          "args": [
            "mm",
            "vma",
            "addr",
            "new_below"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "__split_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2636-2694",
          "snippet": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\treturn __split_vma(mm, vma, addr, new_below);\n}"
  },
  {
    "function_name": "__split_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2636-2694",
    "snippet": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_area_free",
          "args": [
            "new"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "vma_policy(new)"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "new"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink_anon_vmas",
          "args": [
            "new"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_anon_vmas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "376-421",
          "snippet": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma)\n\t\tvma->anon_vma->degree--;\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "new->vm_file"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new->vm_ops->close",
          "args": [
            "new"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_adjust",
          "args": [
            "vma",
            "vma->vm_start",
            "addr",
            "vma->vm_pgoff",
            "new"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_adjust",
          "args": [
            "vma",
            "addr",
            "vma->vm_end",
            "vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT)",
            "new"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new->vm_ops->open",
          "args": [
            "new"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "new->vm_file"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_clone",
          "args": [
            "new",
            "vma"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "261-308",
          "snippet": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_dup_policy",
          "args": [
            "vma",
            "new"
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "vma_dup_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2088-2096",
          "snippet": "int vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nint vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_area_dup",
          "args": [
            "vma"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->split",
          "args": [
            "vma",
            "addr"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\n\tif (vma->vm_ops && vma->vm_ops->split) {\n\t\terr = vma->vm_ops->split(vma, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew = vm_area_dup(vma);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\n\t/* Success. */\n\tif (!err)\n\t\treturn 0;\n\n\t/* Clean everything up if vma_adjust failed. */\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tvm_area_free(new);\n\treturn err;\n}"
  },
  {
    "function_name": "detach_vmas_to_be_unmapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2605-2630",
    "snippet": "static void\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmacache_invalidate",
          "args": [
            "mm"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "prev"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_gap_update",
          "args": [
            "vma"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "vma_gap_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "437-444",
          "snippet": "static void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_rb_erase",
          "args": [
            "vma",
            "&mm->mm_rb"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic void\ndetach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}"
  },
  {
    "function_name": "unmap_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2585-2599",
    "snippet": "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "start",
            "end"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "247-261",
          "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pgtables",
          "args": [
            "&tlb",
            "vma",
            "prev ? prev->vm_end : FIRST_USER_ADDRESS",
            "next ? next->vm_start : USER_PGTABLES_CEILING"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "free_pgtables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "368-401",
          "snippet": "void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\n\t\t/*\n\t\t * Hide vma from rmap and truncate_pagecache before freeing\n\t\t * pgtables\n\t\t */\n\t\tunlink_anon_vmas(vma);\n\t\tunlink_file_vma(vma);\n\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Optimization: gather nearby vmas into one call down\n\t\t\t */\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tunlink_anon_vmas(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next ? next->vm_start : ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_vmas",
          "args": [
            "&tlb",
            "vma",
            "start",
            "end"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_vmas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1331-1341",
          "snippet": "void unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_vmas(struct mmu_gather *tlb,\n\t\tstruct vm_area_struct *vma, unsigned long start_addr,\n\t\tunsigned long end_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tmmu_notifier_invalidate_range_start(mm, start_addr, end_addr);\n\tfor ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next)\n\t\tunmap_single_vma(tlb, vma, start_addr, end_addr, NULL);\n\tmmu_notifier_invalidate_range_end(mm, start_addr, end_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_hiwater_rss",
          "args": [
            "mm"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "start",
            "end"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "240-245",
          "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}"
  },
  {
    "function_name": "remove_vma_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2562-2578",
    "snippet": "static void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tunsigned long nr_accounted = 0;\n\n\t/* Update high watermark before we lower total_vm */\n\tupdate_hiwater_vm(mm);\n\tdo {\n\t\tlong nrpages = vma_pages(vma);\n\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += nrpages;\n\t\tvm_stat_account(mm, vma->vm_flags, -nrpages);\n\t\tvma = remove_vma(vma);\n\t} while (vma);\n\tvm_unacct_memory(nr_accounted);\n\tvalidate_mm(mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_mm",
          "args": [
            "mm"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "385-423",
          "snippet": "static void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "nr_accounted"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_vma",
          "args": [
            "vma"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "remove_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "175-187",
          "snippet": "static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_stat_account",
          "args": [
            "mm",
            "vma->vm_flags",
            "-nrpages"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "vm_stat_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3306-3316",
          "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_hiwater_vm",
          "args": [
            "mm"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tunsigned long nr_accounted = 0;\n\n\t/* Update high watermark before we lower total_vm */\n\tupdate_hiwater_vm(mm);\n\tdo {\n\t\tlong nrpages = vma_pages(vma);\n\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += nrpages;\n\t\tvm_stat_account(mm, vma->vm_flags, -nrpages);\n\t\tvma = remove_vma(vma);\n\t} while (vma);\n\tvm_unacct_memory(nr_accounted);\n\tvalidate_mm(mm);\n}"
  },
  {
    "function_name": "find_extend_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2531-2551",
    "snippet": "struct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long start;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma(mm, addr);\n\tif (!vma)\n\t\treturn NULL;\n\tif (vma->vm_start <= addr)\n\t\treturn vma;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\treturn NULL;\n\tstart = vma->vm_start;\n\tif (expand_stack(vma, addr))\n\t\treturn NULL;\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(vma, addr, start, NULL);\n\treturn vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_vma_page_range",
          "args": [
            "vma",
            "addr",
            "start",
            "NULL"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "populate_vma_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1212-1249",
          "snippet": "long populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_stack",
          "args": [
            "vma",
            "addr"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "expand_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2526-2529",
          "snippet": "int expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2215-2244",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long start;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma(mm, addr);\n\tif (!vma)\n\t\treturn NULL;\n\tif (vma->vm_start <= addr)\n\t\treturn vma;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\treturn NULL;\n\tstart = vma->vm_start;\n\tif (expand_stack(vma, addr))\n\t\treturn NULL;\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(vma, addr, start, NULL);\n\treturn vma;\n}"
  },
  {
    "function_name": "expand_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2526-2529",
    "snippet": "int expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expand_downwards",
          "args": [
            "vma",
            "address"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "expand_downwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2413-2486",
          "snippet": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;\n\nint expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}"
  },
  {
    "function_name": "find_extend_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2510-2524",
    "snippet": "struct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_vma_page_range",
          "args": [
            "prev",
            "addr",
            "prev->vm_end",
            "NULL"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "populate_vma_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1212-1249",
          "snippet": "long populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_stack",
          "args": [
            "prev",
            "addr"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "expand_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2526-2529",
          "snippet": "int expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_downwards(vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma_prev",
          "args": [
            "mm",
            "addr",
            "&prev"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2251-2269",
          "snippet": "struct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}"
  },
  {
    "function_name": "expand_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2505-2508",
    "snippet": "int expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_upwards(vma, address);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expand_upwards",
          "args": [
            "vma",
            "address"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "expand_upwards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2322-2407",
          "snippet": "int expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next;\n\tunsigned long gap_addr;\n\tint error = 0;\n\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\n\t/* Guard against exceeding limits of the address space. */\n\taddress &= PAGE_MASK;\n\tif (address >= (TASK_SIZE & PAGE_MASK))\n\t\treturn -ENOMEM;\n\taddress += PAGE_SIZE;\n\n\t/* Enforce stack_guard_gap */\n\tgap_addr = address + stack_guard_gap;\n\n\t/* Guard against overflow */\n\tif (gap_addr < address || gap_addr > TASK_SIZE)\n\t\tgap_addr = TASK_SIZE;\n\n\tnext = vma->vm_next;\n\tif (next && next->vm_start < gap_addr &&\n\t\t\t(next->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (!(next->vm_flags & VM_GROWSUP))\n\t\t\treturn -ENOMEM;\n\t\t/* Check that both stack segments have the same anon_vma? */\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_end = address;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tif (vma->vm_next)\n\t\t\t\t\tvma_gap_update(vma->vm_next);\n\t\t\t\telse\n\t\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;\n\nint expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next;\n\tunsigned long gap_addr;\n\tint error = 0;\n\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\n\t/* Guard against exceeding limits of the address space. */\n\taddress &= PAGE_MASK;\n\tif (address >= (TASK_SIZE & PAGE_MASK))\n\t\treturn -ENOMEM;\n\taddress += PAGE_SIZE;\n\n\t/* Enforce stack_guard_gap */\n\tgap_addr = address + stack_guard_gap;\n\n\t/* Guard against overflow */\n\tif (gap_addr < address || gap_addr > TASK_SIZE)\n\t\tgap_addr = TASK_SIZE;\n\n\tnext = vma->vm_next;\n\tif (next && next->vm_start < gap_addr &&\n\t\t\t(next->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (!(next->vm_flags & VM_GROWSUP))\n\t\t\treturn -ENOMEM;\n\t\t/* Check that both stack segments have the same anon_vma? */\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_end = address;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tif (vma->vm_next)\n\t\t\t\t\tvma_gap_update(vma->vm_next);\n\t\t\t\telse\n\t\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint expand_stack(struct vm_area_struct *vma, unsigned long address)\n{\n\treturn expand_upwards(vma, address);\n}"
  },
  {
    "function_name": "cmdline_parse_stack_guard_gap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2491-2501",
    "snippet": "static int __init cmdline_parse_stack_guard_gap(char *p)\n{\n\tunsigned long val;\n\tchar *endptr;\n\n\tval = simple_strtoul(p, &endptr, 10);\n\tif (!*endptr)\n\t\tstack_guard_gap = val << PAGE_SHIFT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "p",
            "&endptr",
            "10"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;\n\nstatic int __init cmdline_parse_stack_guard_gap(char *p)\n{\n\tunsigned long val;\n\tchar *endptr;\n\n\tval = simple_strtoul(p, &endptr, 10);\n\tif (!*endptr)\n\t\tstack_guard_gap = val << PAGE_SHIFT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "expand_downwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2413-2486",
    "snippet": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_mm",
          "args": [
            "mm"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "385-423",
          "snippet": "static void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_enter_vma_merge",
          "args": [
            "vma",
            "vma->vm_flags"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_enter_vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "453-470",
          "snippet": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_mmap",
          "args": [
            "vma"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_gap_update",
          "args": [
            "vma"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "vma_gap_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "437-444",
          "snippet": "static void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_post_update_vma",
          "args": [
            "vma"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_post_update_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "514-521",
          "snippet": "static inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_pre_update_vma",
          "args": [
            "vma"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_pre_update_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "505-512",
          "snippet": "static inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_stat_account",
          "args": [
            "mm",
            "vma->vm_flags",
            "grow"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "vm_stat_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3306-3316",
          "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_stack_growth",
          "args": [
            "vma",
            "size",
            "grow"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "acct_stack_growth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2276-2315",
          "snippet": "static int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_mmap_addr",
          "args": [
            "address"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;\n\nint expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\n\t/* Enforce stack_guard_gap */\n\tprev = vma->vm_prev;\n\t/* Check that both stack segments have the same anon_vma? */\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}"
  },
  {
    "function_name": "expand_upwards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2322-2407",
    "snippet": "int expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next;\n\tunsigned long gap_addr;\n\tint error = 0;\n\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\n\t/* Guard against exceeding limits of the address space. */\n\taddress &= PAGE_MASK;\n\tif (address >= (TASK_SIZE & PAGE_MASK))\n\t\treturn -ENOMEM;\n\taddress += PAGE_SIZE;\n\n\t/* Enforce stack_guard_gap */\n\tgap_addr = address + stack_guard_gap;\n\n\t/* Guard against overflow */\n\tif (gap_addr < address || gap_addr > TASK_SIZE)\n\t\tgap_addr = TASK_SIZE;\n\n\tnext = vma->vm_next;\n\tif (next && next->vm_start < gap_addr &&\n\t\t\t(next->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (!(next->vm_flags & VM_GROWSUP))\n\t\t\treturn -ENOMEM;\n\t\t/* Check that both stack segments have the same anon_vma? */\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_end = address;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tif (vma->vm_next)\n\t\t\t\t\tvma_gap_update(vma->vm_next);\n\t\t\t\telse\n\t\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_mm",
          "args": [
            "mm"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "385-423",
          "snippet": "static void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_enter_vma_merge",
          "args": [
            "vma",
            "vma->vm_flags"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_enter_vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "453-470",
          "snippet": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_mmap",
          "args": [
            "vma"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_gap_update",
          "args": [
            "vma->vm_next"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "vma_gap_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "437-444",
          "snippet": "static void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_post_update_vma",
          "args": [
            "vma"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_post_update_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "514-521",
          "snippet": "static inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_pre_update_vma",
          "args": [
            "vma"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_pre_update_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "505-512",
          "snippet": "static inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_stat_account",
          "args": [
            "mm",
            "vma->vm_flags",
            "grow"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "vm_stat_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3306-3316",
          "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_stack_growth",
          "args": [
            "vma",
            "size",
            "grow"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "acct_stack_growth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2276-2315",
          "snippet": "static int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;\n\nint expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next;\n\tunsigned long gap_addr;\n\tint error = 0;\n\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\n\t/* Guard against exceeding limits of the address space. */\n\taddress &= PAGE_MASK;\n\tif (address >= (TASK_SIZE & PAGE_MASK))\n\t\treturn -ENOMEM;\n\taddress += PAGE_SIZE;\n\n\t/* Enforce stack_guard_gap */\n\tgap_addr = address + stack_guard_gap;\n\n\t/* Guard against overflow */\n\tif (gap_addr < address || gap_addr > TASK_SIZE)\n\t\tgap_addr = TASK_SIZE;\n\n\tnext = vma->vm_next;\n\tif (next && next->vm_start < gap_addr &&\n\t\t\t(next->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (!(next->vm_flags & VM_GROWSUP))\n\t\t\treturn -ENOMEM;\n\t\t/* Check that both stack segments have the same anon_vma? */\n\t}\n\n\t/* We must make sure the anon_vma is allocated. */\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * vma->vm_start/vm_end cannot change under us because the caller\n\t * is required to hold the mmap_sem in read mode.  We need the\n\t * anon_vma lock to serialize against concurrent expand_stacks.\n\t */\n\tanon_vma_lock_write(vma->anon_vma);\n\n\t/* Somebody else might have raced and expanded it already */\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\n\t\terror = -ENOMEM;\n\t\tif (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\t/*\n\t\t\t\t * vma_gap_update() doesn't support concurrent\n\t\t\t\t * updates, but we only hold a shared mmap_sem\n\t\t\t\t * lock here, so we need to protect against\n\t\t\t\t * concurrent vma expansions.\n\t\t\t\t * anon_vma_lock_write() doesn't help here, as\n\t\t\t\t * we don't guarantee that all growable vmas\n\t\t\t\t * in a mm share the same root anon vma.\n\t\t\t\t * So, we reuse mm->page_table_lock to guard\n\t\t\t\t * against concurrent vma expansions.\n\t\t\t\t */\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_end = address;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tif (vma->vm_next)\n\t\t\t\t\tvma_gap_update(vma->vm_next);\n\t\t\t\telse\n\t\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}"
  },
  {
    "function_name": "acct_stack_growth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2276-2315",
    "snippet": "static int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_vm_enough_memory_mm",
          "args": [
            "mm",
            "grow"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hugepage_only_range",
          "args": [
            "vma->vm_mm",
            "new_start",
            "size"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_STACK"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_expand_vm",
          "args": [
            "mm",
            "vma->vm_flags",
            "grow"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "may_expand_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3281-3304",
          "snippet": "bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ignore_rlimit_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool ignore_rlimit_data;\n\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int acct_stack_growth(struct vm_area_struct *vma,\n\t\t\t     unsigned long size, unsigned long grow)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long new_start;\n\n\t/* address space limit tests */\n\tif (!may_expand_vm(mm, vma->vm_flags, grow))\n\t\treturn -ENOMEM;\n\n\t/* Stack limit test */\n\tif (size > rlimit(RLIMIT_STACK))\n\t\treturn -ENOMEM;\n\n\t/* mlock limit tests */\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked;\n\t\tunsigned long limit;\n\t\tlocked = mm->locked_vm + grow;\n\t\tlimit = rlimit(RLIMIT_MEMLOCK);\n\t\tlimit >>= PAGE_SHIFT;\n\t\tif (locked > limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Check to ensure the stack will not grow into a hugetlb-only region */\n\tnew_start = (vma->vm_flags & VM_GROWSUP) ? vma->vm_start :\n\t\t\tvma->vm_end - size;\n\tif (is_hugepage_only_range(vma->vm_mm, new_start, size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Overcommit..  This must be the final test, as it will\n\t * update security statistics.\n\t */\n\tif (security_vm_enough_memory_mm(mm, grow))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_vma_prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2251-2269",
    "snippet": "struct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2215-2244",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}"
  },
  {
    "function_name": "find_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2215-2244",
    "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmacache_update",
          "args": [
            "addr",
            "vma"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "vmacache_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
          "lines": "36-40",
          "snippet": "void vmacache_update(unsigned long addr, struct vm_area_struct *newvma)\n{\n\tif (vmacache_valid_mm(newvma->vm_mm))\n\t\tcurrent->vmacache.vmas[VMACACHE_HASH(addr)] = newvma;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nvoid vmacache_update(unsigned long addr, struct vm_area_struct *newvma)\n{\n\tif (vmacache_valid_mm(newvma->vm_mm))\n\t\tcurrent->vmacache.vmas[VMACACHE_HASH(addr)] = newvma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "vma"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmacache_find",
          "args": [
            "mm",
            "addr"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "vmacache_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
          "lines": "62-90",
          "snippet": "struct vm_area_struct *vmacache_find(struct mm_struct *mm, unsigned long addr)\n{\n\tint idx = VMACACHE_HASH(addr);\n\tint i;\n\n\tcount_vm_vmacache_event(VMACACHE_FIND_CALLS);\n\n\tif (!vmacache_valid(mm))\n\t\treturn NULL;\n\n\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\tstruct vm_area_struct *vma = current->vmacache.vmas[idx];\n\n\t\tif (vma) {\n#ifdef CONFIG_DEBUG_VM_VMACACHE\n\t\t\tif (WARN_ON_ONCE(vma->vm_mm != mm))\n\t\t\t\tbreak;\n#endif\n\t\t\tif (vma->vm_start <= addr && vma->vm_end > addr) {\n\t\t\t\tcount_vm_vmacache_event(VMACACHE_FIND_HITS);\n\t\t\t\treturn vma;\n\t\t\t}\n\t\t}\n\t\tif (++idx == VMACACHE_SIZE)\n\t\t\tidx = 0;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstruct vm_area_struct *vmacache_find(struct mm_struct *mm, unsigned long addr)\n{\n\tint idx = VMACACHE_HASH(addr);\n\tint i;\n\n\tcount_vm_vmacache_event(VMACACHE_FIND_CALLS);\n\n\tif (!vmacache_valid(mm))\n\t\treturn NULL;\n\n\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\tstruct vm_area_struct *vma = current->vmacache.vmas[idx];\n\n\t\tif (vma) {\n#ifdef CONFIG_DEBUG_VM_VMACACHE\n\t\t\tif (WARN_ON_ONCE(vma->vm_mm != mm))\n\t\t\t\tbreak;\n#endif\n\t\t\tif (vma->vm_start <= addr && vma->vm_end > addr) {\n\t\t\t\tcount_vm_vmacache_event(VMACACHE_FIND_HITS);\n\t\t\t\treturn vma;\n\t\t\t}\n\t\t}\n\t\tif (++idx == VMACACHE_SIZE)\n\t\t\tidx = 0;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}"
  },
  {
    "function_name": "get_unmapped_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2170-2210",
    "snippet": "unsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_mmap_addr",
          "args": [
            "addr"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "addr"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_area",
          "args": [
            "file",
            "addr",
            "len",
            "pgoff",
            "flags"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_mmap_check",
          "args": [
            "addr",
            "len",
            "flags"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}"
  },
  {
    "function_name": "arch_get_unmapped_area_topdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2118-2167",
    "snippet": "unsigned long\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\n\t\t\t  const unsigned long len, const unsigned long pgoff,\n\t\t\t  const unsigned long flags)\n{\n\tstruct vm_area_struct *vma, *prev;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr = addr0;\n\tstruct vm_unmapped_area_info info;\n\n\t/* requested length too big for entire address space */\n\tif (len > TASK_SIZE - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t/* requesting a specific address */\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (TASK_SIZE - len >= addr && addr >= mmap_min_addr &&\n\t\t\t\t(!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t\t\t(!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\n\tinfo.length = len;\n\tinfo.low_limit = max(PAGE_SIZE, mmap_min_addr);\n\tinfo.high_limit = mm->mmap_base;\n\tinfo.align_mask = 0;\n\taddr = vm_unmapped_area(&info);\n\n\t/*\n\t * A failed mmap() very likely causes application failure,\n\t * so fall back to the bottom-up function here. This scenario\n\t * can happen with large stack limits and large mmap()\n\t * allocations.\n\t */\n\tif (offset_in_page(addr)) {\n\t\tVM_BUG_ON(addr != -ENOMEM);\n\t\tinfo.flags = 0;\n\t\tinfo.low_limit = TASK_UNMAPPED_BASE;\n\t\tinfo.high_limit = TASK_SIZE;\n\t\taddr = vm_unmapped_area(&info);\n\t}\n\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unmapped_area",
          "args": [
            "&info"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "addr != -ENOMEM"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_unmapped_area",
          "args": [
            "&info"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "PAGE_SIZE",
            "mmap_min_addr"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "file_mmap_size_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1351-1365",
          "snippet": "static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "prev"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_start_gap",
          "args": [
            "vma"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_prev",
          "args": [
            "mm",
            "addr",
            "&prev"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2251-2269",
          "snippet": "struct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "addr"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\n\t\t\t  const unsigned long len, const unsigned long pgoff,\n\t\t\t  const unsigned long flags)\n{\n\tstruct vm_area_struct *vma, *prev;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr = addr0;\n\tstruct vm_unmapped_area_info info;\n\n\t/* requested length too big for entire address space */\n\tif (len > TASK_SIZE - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t/* requesting a specific address */\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (TASK_SIZE - len >= addr && addr >= mmap_min_addr &&\n\t\t\t\t(!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t\t\t(!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\n\tinfo.length = len;\n\tinfo.low_limit = max(PAGE_SIZE, mmap_min_addr);\n\tinfo.high_limit = mm->mmap_base;\n\tinfo.align_mask = 0;\n\taddr = vm_unmapped_area(&info);\n\n\t/*\n\t * A failed mmap() very likely causes application failure,\n\t * so fall back to the bottom-up function here. This scenario\n\t * can happen with large stack limits and large mmap()\n\t * allocations.\n\t */\n\tif (offset_in_page(addr)) {\n\t\tVM_BUG_ON(addr != -ENOMEM);\n\t\tinfo.flags = 0;\n\t\tinfo.low_limit = TASK_UNMAPPED_BASE;\n\t\tinfo.high_limit = TASK_SIZE;\n\t\taddr = vm_unmapped_area(&info);\n\t}\n\n\treturn addr;\n}"
  },
  {
    "function_name": "arch_get_unmapped_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2081-2110",
    "snippet": "unsigned long\narch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct vm_unmapped_area_info info;\n\n\tif (len > TASK_SIZE - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (TASK_SIZE - len >= addr && addr >= mmap_min_addr &&\n\t\t    (!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t    (!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = mm->mmap_base;\n\tinfo.high_limit = TASK_SIZE;\n\tinfo.align_mask = 0;\n\treturn vm_unmapped_area(&info);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unmapped_area",
          "args": [
            "&info"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "prev"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_start_gap",
          "args": [
            "vma"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_prev",
          "args": [
            "mm",
            "addr",
            "&prev"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2251-2269",
          "snippet": "struct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *\nfind_vma_prev(struct mm_struct *mm, unsigned long addr,\n\t\t\tstruct vm_area_struct **pprev)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = find_vma(mm, addr);\n\tif (vma) {\n\t\t*pprev = vma->vm_prev;\n\t} else {\n\t\tstruct rb_node *rb_node = mm->mm_rb.rb_node;\n\t\t*pprev = NULL;\n\t\twhile (rb_node) {\n\t\t\t*pprev = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\t\t\trb_node = rb_node->rb_right;\n\t\t}\n\t}\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "addr"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long\narch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct vm_unmapped_area_info info;\n\n\tif (len > TASK_SIZE - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma_prev(mm, addr, &prev);\n\t\tif (TASK_SIZE - len >= addr && addr >= mmap_min_addr &&\n\t\t    (!vma || addr + len <= vm_start_gap(vma)) &&\n\t\t    (!prev || addr >= vm_end_gap(prev)))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = 0;\n\tinfo.length = len;\n\tinfo.low_limit = mm->mmap_base;\n\tinfo.high_limit = TASK_SIZE;\n\tinfo.align_mask = 0;\n\treturn vm_unmapped_area(&info);\n}"
  },
  {
    "function_name": "unmapped_area_topdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1970-2067",
    "snippet": "unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust search limits by the desired length.\n\t * See implementation comment at top of unmapped_area().\n\t */\n\tgap_end = info->high_limit;\n\tif (gap_end < length)\n\t\treturn -ENOMEM;\n\thigh_limit = gap_end - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tif (gap_start <= high_limit)\n\t\tgoto found_highest;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\treturn -ENOMEM;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\treturn -ENOMEM;\n\n\twhile (true) {\n\t\t/* Visit right subtree if it looks promising */\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\n\t\tif (gap_start <= high_limit && vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end < low_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_start <= high_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit left subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\treturn -ENOMEM;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_right) {\n\t\t\t\tgap_start = vma->vm_prev ?\n\t\t\t\t\tvm_end_gap(vma->vm_prev) : 0;\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\nfound:\n\t/* We found a suitable gap. Clip it with the original high_limit. */\n\tif (gap_end > info->high_limit)\n\t\tgap_end = info->high_limit;\n\nfound_highest:\n\t/* Compute highest gap address at the desired alignment */\n\tgap_end -= info->length;\n\tgap_end -= (gap_end - info->align_offset) & info->align_mask;\n\n\tVM_BUG_ON(gap_end < info->low_limit);\n\tVM_BUG_ON(gap_end < gap_start);\n\treturn gap_end;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "gap_end < gap_start"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "gap_end < info->low_limit"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma->vm_prev"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_parent(prev)",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_parent",
          "args": [
            "prev"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_parent",
          "args": [
            "prev"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "vma->vm_rb.rb_left",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_start_gap",
          "args": [
            "vma"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "vma->vm_rb.rb_right",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma->vm_prev"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "mm->mm_rb.rb_node",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&mm->mm_rb"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Adjust search limits by the desired length.\n\t * See implementation comment at top of unmapped_area().\n\t */\n\tgap_end = info->high_limit;\n\tif (gap_end < length)\n\t\treturn -ENOMEM;\n\thigh_limit = gap_end - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tif (gap_start <= high_limit)\n\t\tgoto found_highest;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\treturn -ENOMEM;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\treturn -ENOMEM;\n\n\twhile (true) {\n\t\t/* Visit right subtree if it looks promising */\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\n\t\tif (gap_start <= high_limit && vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end < low_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_start <= high_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit left subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\treturn -ENOMEM;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_right) {\n\t\t\t\tgap_start = vma->vm_prev ?\n\t\t\t\t\tvm_end_gap(vma->vm_prev) : 0;\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\nfound:\n\t/* We found a suitable gap. Clip it with the original high_limit. */\n\tif (gap_end > info->high_limit)\n\t\tgap_end = info->high_limit;\n\nfound_highest:\n\t/* Compute highest gap address at the desired alignment */\n\tgap_end -= info->length;\n\tgap_end -= (gap_end - info->align_offset) & info->align_mask;\n\n\tVM_BUG_ON(gap_end < info->low_limit);\n\tVM_BUG_ON(gap_end < gap_start);\n\treturn gap_end;\n}"
  },
  {
    "function_name": "unmapped_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1867-1968",
    "snippet": "unsigned long unmapped_area(struct vm_unmapped_area_info *info)\n{\n\t/*\n\t * We implement the search by looking for an rbtree node that\n\t * immediately follows a suitable gap. That is,\n\t * - gap_start = vma->vm_prev->vm_end <= info->high_limit - length;\n\t * - gap_end   = vma->vm_start        >= info->low_limit  + length;\n\t * - gap_end - gap_start >= length\n\t */\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/* Adjust search limits by the desired length */\n\tif (info->high_limit < length)\n\t\treturn -ENOMEM;\n\thigh_limit = info->high_limit - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\tgoto check_highest;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\tgoto check_highest;\n\n\twhile (true) {\n\t\t/* Visit left subtree if it looks promising */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end >= low_limit && vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tif (gap_start > high_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_end >= low_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit right subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\tgoto check_highest;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_left) {\n\t\t\t\tgap_start = vm_end_gap(vma->vm_prev);\n\t\t\t\tgap_end = vm_start_gap(vma);\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\ncheck_highest:\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tgap_end = ULONG_MAX;  /* Only for VM_BUG_ON below */\n\tif (gap_start > high_limit)\n\t\treturn -ENOMEM;\n\nfound:\n\t/* We found a suitable gap. Clip it with the original low_limit. */\n\tif (gap_start < info->low_limit)\n\t\tgap_start = info->low_limit;\n\n\t/* Adjust gap address to the desired alignment */\n\tgap_start += (info->align_offset - gap_start) & info->align_mask;\n\n\tVM_BUG_ON(gap_start + info->length > info->high_limit);\n\tVM_BUG_ON(gap_start + info->length > gap_end);\n\treturn gap_start;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "gap_start + info->length > gap_end"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "gap_start + info->length > info->high_limit"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_start_gap",
          "args": [
            "vma"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma->vm_prev"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_parent(prev)",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_parent",
          "args": [
            "prev"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_parent",
          "args": [
            "prev"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "vma->vm_rb.rb_right",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma->vm_prev"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "vma->vm_rb.rb_left",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_start_gap",
          "args": [
            "vma"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "mm->mm_rb.rb_node",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&mm->mm_rb"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long unmapped_area(struct vm_unmapped_area_info *info)\n{\n\t/*\n\t * We implement the search by looking for an rbtree node that\n\t * immediately follows a suitable gap. That is,\n\t * - gap_start = vma->vm_prev->vm_end <= info->high_limit - length;\n\t * - gap_end   = vma->vm_start        >= info->low_limit  + length;\n\t * - gap_end - gap_start >= length\n\t */\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long length, low_limit, high_limit, gap_start, gap_end;\n\n\t/* Adjust search length to account for worst case alignment overhead */\n\tlength = info->length + info->align_mask;\n\tif (length < info->length)\n\t\treturn -ENOMEM;\n\n\t/* Adjust search limits by the desired length */\n\tif (info->high_limit < length)\n\t\treturn -ENOMEM;\n\thigh_limit = info->high_limit - length;\n\n\tif (info->low_limit > high_limit)\n\t\treturn -ENOMEM;\n\tlow_limit = info->low_limit + length;\n\n\t/* Check if rbtree root looks promising */\n\tif (RB_EMPTY_ROOT(&mm->mm_rb))\n\t\tgoto check_highest;\n\tvma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);\n\tif (vma->rb_subtree_gap < length)\n\t\tgoto check_highest;\n\n\twhile (true) {\n\t\t/* Visit left subtree if it looks promising */\n\t\tgap_end = vm_start_gap(vma);\n\t\tif (gap_end >= low_limit && vma->vm_rb.rb_left) {\n\t\t\tstruct vm_area_struct *left =\n\t\t\t\trb_entry(vma->vm_rb.rb_left,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (left->rb_subtree_gap >= length) {\n\t\t\t\tvma = left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tgap_start = vma->vm_prev ? vm_end_gap(vma->vm_prev) : 0;\ncheck_current:\n\t\t/* Check if current node has a suitable gap */\n\t\tif (gap_start > high_limit)\n\t\t\treturn -ENOMEM;\n\t\tif (gap_end >= low_limit &&\n\t\t    gap_end > gap_start && gap_end - gap_start >= length)\n\t\t\tgoto found;\n\n\t\t/* Visit right subtree if it looks promising */\n\t\tif (vma->vm_rb.rb_right) {\n\t\t\tstruct vm_area_struct *right =\n\t\t\t\trb_entry(vma->vm_rb.rb_right,\n\t\t\t\t\t struct vm_area_struct, vm_rb);\n\t\t\tif (right->rb_subtree_gap >= length) {\n\t\t\t\tvma = right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Go back up the rbtree to find next candidate node */\n\t\twhile (true) {\n\t\t\tstruct rb_node *prev = &vma->vm_rb;\n\t\t\tif (!rb_parent(prev))\n\t\t\t\tgoto check_highest;\n\t\t\tvma = rb_entry(rb_parent(prev),\n\t\t\t\t       struct vm_area_struct, vm_rb);\n\t\t\tif (prev == vma->vm_rb.rb_left) {\n\t\t\t\tgap_start = vm_end_gap(vma->vm_prev);\n\t\t\t\tgap_end = vm_start_gap(vma);\n\t\t\t\tgoto check_current;\n\t\t\t}\n\t\t}\n\t}\n\ncheck_highest:\n\t/* Check highest gap, which does not precede any rbtree node */\n\tgap_start = mm->highest_vm_end;\n\tgap_end = ULONG_MAX;  /* Only for VM_BUG_ON below */\n\tif (gap_start > high_limit)\n\t\treturn -ENOMEM;\n\nfound:\n\t/* We found a suitable gap. Clip it with the original low_limit. */\n\tif (gap_start < info->low_limit)\n\t\tgap_start = info->low_limit;\n\n\t/* Adjust gap address to the desired alignment */\n\tgap_start += (info->align_offset - gap_start) & info->align_mask;\n\n\tVM_BUG_ON(gap_start + info->length > info->high_limit);\n\tVM_BUG_ON(gap_start + info->length > gap_end);\n\treturn gap_start;\n}"
  },
  {
    "function_name": "mmap_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1701-1865",
    "snippet": "unsigned long mmap_region(struct file *file, unsigned long addr,\n\t\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tint error;\n\tstruct rb_node **rb_link, *rb_parent;\n\tunsigned long charged = 0;\n\n\t/* Check against address space limit. */\n\tif (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {\n\t\tunsigned long nr_pages;\n\n\t\t/*\n\t\t * MAP_FIXED may remove pages of mappings that intersects with\n\t\t * requested mapping. Account for the pages it would unmap.\n\t\t */\n\t\tnr_pages = count_vma_pages_range(mm, addr, addr + len);\n\n\t\tif (!may_expand_vm(mm, vm_flags,\n\t\t\t\t\t(len >> PAGE_SHIFT) - nr_pages))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Clear old maps */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Private writable mapping: check memory availability\n\t */\n\tif (accountable_mapping(file, vm_flags)) {\n\t\tcharged = len >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn -ENOMEM;\n\t\tvm_flags |= VM_ACCOUNT;\n\t}\n\n\t/*\n\t * Can we just expand an old mapping?\n\t */\n\tvma = vma_merge(mm, prev, addr, addr + len, vm_flags,\n\t\t\tNULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * Determine the object being mapped and call the appropriate\n\t * specific mapper. the address has already been validated, but\n\t * not unmapped, but the maps are removed from the list.\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\terror = -ENOMEM;\n\t\tgoto unacct_error;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_flags = vm_flags;\n\tvma->vm_page_prot = vm_get_page_prot(vm_flags);\n\tvma->vm_pgoff = pgoff;\n\n\tif (file) {\n\t\tif (vm_flags & VM_DENYWRITE) {\n\t\t\terror = deny_write_access(file);\n\t\t\tif (error)\n\t\t\t\tgoto free_vma;\n\t\t}\n\t\tif (vm_flags & VM_SHARED) {\n\t\t\terror = mapping_map_writable(file->f_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto allow_write_and_free_vma;\n\t\t}\n\n\t\t/* ->mmap() can change vma->vm_file, but must guarantee that\n\t\t * vma_link() below can deny write-access if VM_DENYWRITE is set\n\t\t * and map writably if VM_SHARED is set. This usually means the\n\t\t * new file must not have been exposed to user-space, yet.\n\t\t */\n\t\tvma->vm_file = get_file(file);\n\t\terror = call_mmap(file, vma);\n\t\tif (error)\n\t\t\tgoto unmap_and_free_vma;\n\n\t\t/* Can addr have changed??\n\t\t *\n\t\t * Answer: Yes, several device drivers can do it in their\n\t\t *         f_op->mmap method. -DaveM\n\t\t * Bug: If addr is changed, prev, rb_link, rb_parent should\n\t\t *      be updated for vma_link()\n\t\t */\n\t\tWARN_ON_ONCE(addr != vma->vm_start);\n\n\t\taddr = vma->vm_start;\n\t\tvm_flags = vma->vm_flags;\n\t} else if (vm_flags & VM_SHARED) {\n\t\terror = shmem_zero_setup(vma);\n\t\tif (error)\n\t\t\tgoto free_vma;\n\t} else {\n\t\tvma_set_anonymous(vma);\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\t/* Once vma denies write, undo our temporary denial count */\n\tif (file) {\n\t\tif (vm_flags & VM_SHARED)\n\t\t\tmapping_unmap_writable(file->f_mapping);\n\t\tif (vm_flags & VM_DENYWRITE)\n\t\t\tallow_write_access(file);\n\t}\n\tfile = vma->vm_file;\nout:\n\tperf_event_mmap(vma);\n\n\tvm_stat_account(mm, vm_flags, len >> PAGE_SHIFT);\n\tif (vm_flags & VM_LOCKED) {\n\t\tif ((vm_flags & VM_SPECIAL) || vma_is_dax(vma) ||\n\t\t\t\t\tis_vm_hugetlb_page(vma) ||\n\t\t\t\t\tvma == get_gate_vma(current->mm))\n\t\t\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\t\telse\n\t\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\t}\n\n\tif (file)\n\t\tuprobe_mmap(vma);\n\n\t/*\n\t * New (or expanded) vma always get soft dirty status.\n\t * Otherwise user-space soft-dirty page tracker won't\n\t * be able to distinguish situation when vma area unmapped,\n\t * then new mapped in-place (which must be aimed as\n\t * a completely new data area).\n\t */\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\n\tvma_set_page_prot(vma);\n\n\treturn addr;\n\nunmap_and_free_vma:\n\tvma->vm_file = NULL;\n\tfput(file);\n\n\t/* Undo any partial mapping done by a device driver. */\n\tunmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);\n\tcharged = 0;\n\tif (vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(file->f_mapping);\nallow_write_and_free_vma:\n\tif (vm_flags & VM_DENYWRITE)\n\t\tallow_write_access(file);\nfree_vma:\n\tvm_area_free(vma);\nunacct_error:\n\tif (charged)\n\t\tvm_unacct_memory(charged);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "charged"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_area_free",
          "args": [
            "vma"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "file"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_unmap_writable",
          "args": [
            "file->f_mapping"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_region",
          "args": [
            "mm",
            "vma",
            "prev",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2585-2599",
          "snippet": "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = prev ? prev->vm_next : mm->mmap;\n\tstruct mmu_gather tlb;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_set_page_prot",
          "args": [
            "vma"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "vma_set_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "126-138",
          "snippet": "void vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_mmap",
          "args": [
            "vma"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "current->mm"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_stat_account",
          "args": [
            "mm",
            "vm_flags",
            "len >> PAGE_SHIFT"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "vm_stat_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3306-3316",
          "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_mmap",
          "args": [
            "vma"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "file"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_unmap_writable",
          "args": [
            "file->f_mapping"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_link",
          "args": [
            "mm",
            "vma",
            "prev",
            "rb_link",
            "rb_parent"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "vma_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "637-656",
          "snippet": "static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_set_anonymous",
          "args": [
            "vma"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_zero_setup",
          "args": [
            "vma"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_zero_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "3934-3961",
          "snippet": "int shmem_zero_setup(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\tloff_t size = vma->vm_end - vma->vm_start;\n\n\t/*\n\t * Cloning a new file under mmap_sem leads to a lock ordering conflict\n\t * between XFS directory reading and selinux: since this file is only\n\t * accessible to the user through its mapping, use S_PRIVATE flag to\n\t * bypass file security, in the same way as shmem_kernel_file_setup().\n\t */\n\tfile = shmem_kernel_file_setup(\"dev/zero\", size, vma->vm_flags);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tvma->vm_file = file;\n\tvma->vm_ops = &shmem_vm_ops;\n\n\tif (IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&\n\t\t\t((vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK) <\n\t\t\t(vma->vm_end & HPAGE_PMD_MASK)) {\n\t\tkhugepaged_enter(vma, vma->vm_flags);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define shmem_vm_ops\t\t\t\tgeneric_file_vm_ops"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\n#define shmem_vm_ops\t\t\t\tgeneric_file_vm_ops\n\nint shmem_zero_setup(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\tloff_t size = vma->vm_end - vma->vm_start;\n\n\t/*\n\t * Cloning a new file under mmap_sem leads to a lock ordering conflict\n\t * between XFS directory reading and selinux: since this file is only\n\t * accessible to the user through its mapping, use S_PRIVATE flag to\n\t * bypass file security, in the same way as shmem_kernel_file_setup().\n\t */\n\tfile = shmem_kernel_file_setup(\"dev/zero\", size, vma->vm_flags);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tvma->vm_file = file;\n\tvma->vm_ops = &shmem_vm_ops;\n\n\tif (IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE) &&\n\t\t\t((vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK) <\n\t\t\t(vma->vm_end & HPAGE_PMD_MASK)) {\n\t\tkhugepaged_enter(vma, vma->vm_flags);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "addr != vma->vm_start"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_mmap",
          "args": [
            "file",
            "vma"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_map_writable",
          "args": [
            "file->f_mapping"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deny_write_access",
          "args": [
            "file"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_get_page_prot",
          "args": [
            "vm_flags"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "vm_get_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "110-117",
          "snippet": "pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_area_alloc",
          "args": [
            "mm"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "prev",
            "addr",
            "addr + len",
            "vm_flags",
            "NULL",
            "file",
            "pgoff",
            "NULL",
            "NULL_VM_UFFD_CTX"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1132-1223",
          "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_vm_enough_memory_mm",
          "args": [
            "mm",
            "charged"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accountable_mapping",
          "args": [
            "file",
            "vm_flags"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "accountable_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1689-1699",
          "snippet": "static inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)\n{\n\t/*\n\t * hugetlb has its own accounting separate from the core VM\n\t * VM_HUGETLB may not be set yet so we cannot check for that flag.\n\t */\n\tif (file && is_file_hugepages(file))\n\t\treturn 0;\n\n\treturn (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)\n{\n\t/*\n\t * hugetlb has its own accounting separate from the core VM\n\t * VM_HUGETLB may not be set yet so we cannot check for that flag.\n\t */\n\tif (file && is_file_hugepages(file))\n\t\treturn 0;\n\n\treturn (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_munmap",
          "args": [
            "mm",
            "addr",
            "len",
            "uf"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "do_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2822-2826",
          "snippet": "int do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nint do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t      struct list_head *uf)\n{\n\treturn __do_munmap(mm, start, len, uf, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma_links",
          "args": [
            "mm",
            "addr",
            "addr + len",
            "&prev",
            "&rb_link",
            "&rb_parent"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "523-555",
          "snippet": "static int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_expand_vm",
          "args": [
            "mm",
            "vm_flags",
            "(len >> PAGE_SHIFT) - nr_pages"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "may_expand_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3281-3304",
          "snippet": "bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ignore_rlimit_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool ignore_rlimit_data;\n\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vma_pages_range",
          "args": [
            "mm",
            "addr",
            "addr + len"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "count_vma_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "557-583",
          "snippet": "static unsigned long count_vma_pages_range(struct mm_struct *mm,\n\t\tunsigned long addr, unsigned long end)\n{\n\tunsigned long nr_pages = 0;\n\tstruct vm_area_struct *vma;\n\n\t/* Find first overlaping mapping */\n\tvma = find_vma_intersection(mm, addr, end);\n\tif (!vma)\n\t\treturn 0;\n\n\tnr_pages = (min(end, vma->vm_end) -\n\t\tmax(addr, vma->vm_start)) >> PAGE_SHIFT;\n\n\t/* Iterate over the rest of the overlaps */\n\tfor (vma = vma->vm_next; vma; vma = vma->vm_next) {\n\t\tunsigned long overlap_len;\n\n\t\tif (vma->vm_start > end)\n\t\t\tbreak;\n\n\t\toverlap_len = min(end, vma->vm_end) - vma->vm_start;\n\t\tnr_pages += overlap_len >> PAGE_SHIFT;\n\t}\n\n\treturn nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic unsigned long count_vma_pages_range(struct mm_struct *mm,\n\t\tunsigned long addr, unsigned long end)\n{\n\tunsigned long nr_pages = 0;\n\tstruct vm_area_struct *vma;\n\n\t/* Find first overlaping mapping */\n\tvma = find_vma_intersection(mm, addr, end);\n\tif (!vma)\n\t\treturn 0;\n\n\tnr_pages = (min(end, vma->vm_end) -\n\t\tmax(addr, vma->vm_start)) >> PAGE_SHIFT;\n\n\t/* Iterate over the rest of the overlaps */\n\tfor (vma = vma->vm_next; vma; vma = vma->vm_next) {\n\t\tunsigned long overlap_len;\n\n\t\tif (vma->vm_start > end)\n\t\t\tbreak;\n\n\t\toverlap_len = min(end, vma->vm_end) - vma->vm_start;\n\t\tnr_pages += overlap_len >> PAGE_SHIFT;\n\t}\n\n\treturn nr_pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nunsigned long mmap_region(struct file *file, unsigned long addr,\n\t\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tint error;\n\tstruct rb_node **rb_link, *rb_parent;\n\tunsigned long charged = 0;\n\n\t/* Check against address space limit. */\n\tif (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {\n\t\tunsigned long nr_pages;\n\n\t\t/*\n\t\t * MAP_FIXED may remove pages of mappings that intersects with\n\t\t * requested mapping. Account for the pages it would unmap.\n\t\t */\n\t\tnr_pages = count_vma_pages_range(mm, addr, addr + len);\n\n\t\tif (!may_expand_vm(mm, vm_flags,\n\t\t\t\t\t(len >> PAGE_SHIFT) - nr_pages))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Clear old maps */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Private writable mapping: check memory availability\n\t */\n\tif (accountable_mapping(file, vm_flags)) {\n\t\tcharged = len >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn -ENOMEM;\n\t\tvm_flags |= VM_ACCOUNT;\n\t}\n\n\t/*\n\t * Can we just expand an old mapping?\n\t */\n\tvma = vma_merge(mm, prev, addr, addr + len, vm_flags,\n\t\t\tNULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * Determine the object being mapped and call the appropriate\n\t * specific mapper. the address has already been validated, but\n\t * not unmapped, but the maps are removed from the list.\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\terror = -ENOMEM;\n\t\tgoto unacct_error;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_flags = vm_flags;\n\tvma->vm_page_prot = vm_get_page_prot(vm_flags);\n\tvma->vm_pgoff = pgoff;\n\n\tif (file) {\n\t\tif (vm_flags & VM_DENYWRITE) {\n\t\t\terror = deny_write_access(file);\n\t\t\tif (error)\n\t\t\t\tgoto free_vma;\n\t\t}\n\t\tif (vm_flags & VM_SHARED) {\n\t\t\terror = mapping_map_writable(file->f_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto allow_write_and_free_vma;\n\t\t}\n\n\t\t/* ->mmap() can change vma->vm_file, but must guarantee that\n\t\t * vma_link() below can deny write-access if VM_DENYWRITE is set\n\t\t * and map writably if VM_SHARED is set. This usually means the\n\t\t * new file must not have been exposed to user-space, yet.\n\t\t */\n\t\tvma->vm_file = get_file(file);\n\t\terror = call_mmap(file, vma);\n\t\tif (error)\n\t\t\tgoto unmap_and_free_vma;\n\n\t\t/* Can addr have changed??\n\t\t *\n\t\t * Answer: Yes, several device drivers can do it in their\n\t\t *         f_op->mmap method. -DaveM\n\t\t * Bug: If addr is changed, prev, rb_link, rb_parent should\n\t\t *      be updated for vma_link()\n\t\t */\n\t\tWARN_ON_ONCE(addr != vma->vm_start);\n\n\t\taddr = vma->vm_start;\n\t\tvm_flags = vma->vm_flags;\n\t} else if (vm_flags & VM_SHARED) {\n\t\terror = shmem_zero_setup(vma);\n\t\tif (error)\n\t\t\tgoto free_vma;\n\t} else {\n\t\tvma_set_anonymous(vma);\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\t/* Once vma denies write, undo our temporary denial count */\n\tif (file) {\n\t\tif (vm_flags & VM_SHARED)\n\t\t\tmapping_unmap_writable(file->f_mapping);\n\t\tif (vm_flags & VM_DENYWRITE)\n\t\t\tallow_write_access(file);\n\t}\n\tfile = vma->vm_file;\nout:\n\tperf_event_mmap(vma);\n\n\tvm_stat_account(mm, vm_flags, len >> PAGE_SHIFT);\n\tif (vm_flags & VM_LOCKED) {\n\t\tif ((vm_flags & VM_SPECIAL) || vma_is_dax(vma) ||\n\t\t\t\t\tis_vm_hugetlb_page(vma) ||\n\t\t\t\t\tvma == get_gate_vma(current->mm))\n\t\t\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\t\telse\n\t\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\t}\n\n\tif (file)\n\t\tuprobe_mmap(vma);\n\n\t/*\n\t * New (or expanded) vma always get soft dirty status.\n\t * Otherwise user-space soft-dirty page tracker won't\n\t * be able to distinguish situation when vma area unmapped,\n\t * then new mapped in-place (which must be aimed as\n\t * a completely new data area).\n\t */\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\n\tvma_set_page_prot(vma);\n\n\treturn addr;\n\nunmap_and_free_vma:\n\tvma->vm_file = NULL;\n\tfput(file);\n\n\t/* Undo any partial mapping done by a device driver. */\n\tunmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);\n\tcharged = 0;\n\tif (vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(file->f_mapping);\nallow_write_and_free_vma:\n\tif (vm_flags & VM_DENYWRITE)\n\t\tallow_write_access(file);\nfree_vma:\n\tvm_area_free(vma);\nunacct_error:\n\tif (charged)\n\t\tvm_unacct_memory(charged);\n\treturn error;\n}"
  },
  {
    "function_name": "accountable_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1689-1699",
    "snippet": "static inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)\n{\n\t/*\n\t * hugetlb has its own accounting separate from the core VM\n\t * VM_HUGETLB may not be set yet so we cannot check for that flag.\n\t */\n\tif (file && is_file_hugepages(file))\n\t\treturn 0;\n\n\treturn (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_file_hugepages",
          "args": [
            "file"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)\n{\n\t/*\n\t * hugetlb has its own accounting separate from the core VM\n\t * VM_HUGETLB may not be set yet so we cannot check for that flag.\n\t */\n\tif (file && is_file_hugepages(file))\n\t\treturn 0;\n\n\treturn (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;\n}"
  },
  {
    "function_name": "vma_wants_writenotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1653-1683",
    "snippet": "int vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MEM_SOFT_DIRTY"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "vm_pgprot_modify(vm_page_prot, vm_flags)"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_pgprot_modify",
          "args": [
            "vm_page_prot",
            "vm_flags"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "vm_pgprot_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "120-123",
          "snippet": "static pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "vm_page_prot"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}"
  },
  {
    "function_name": "ksys_mmap_pgoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1567-1614",
    "snippet": "unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long fd, unsigned long pgoff)\n{\n\tstruct file *file = NULL;\n\tunsigned long retval;\n\n\tif (!(flags & MAP_ANONYMOUS)) {\n\t\taudit_mmap_fd(fd, flags);\n\t\tfile = fget(fd);\n\t\tif (!file)\n\t\t\treturn -EBADF;\n\t\tif (is_file_hugepages(file))\n\t\t\tlen = ALIGN(len, huge_page_size(hstate_file(file)));\n\t\tretval = -EINVAL;\n\t\tif (unlikely(flags & MAP_HUGETLB && !is_file_hugepages(file)))\n\t\t\tgoto out_fput;\n\t} else if (flags & MAP_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\t\tstruct hstate *hs;\n\n\t\ths = hstate_sizelog((flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (!hs)\n\t\t\treturn -EINVAL;\n\n\t\tlen = ALIGN(len, huge_page_size(hs));\n\t\t/*\n\t\t * VM_NORESERVE is used because the reservations will be\n\t\t * taken when vm_ops->mmap() is called\n\t\t * A dummy user value is used because we are not locking\n\t\t * memory so no accounting is necessary\n\t\t */\n\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len,\n\t\t\t\tVM_NORESERVE,\n\t\t\t\t&user, HUGETLB_ANONHUGE_INODE,\n\t\t\t\t(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\t}\n\n\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n\n\tretval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);\nout_fput:\n\tif (file)\n\t\tfput(file);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap_pgoff",
          "args": [
            "file",
            "addr",
            "len",
            "prot",
            "flags",
            "pgoff"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "vm_mmap_pgoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "337-358",
          "snippet": "unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long pgoff)\n{\n\tunsigned long ret;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long populate;\n\tLIST_HEAD(uf);\n\n\tret = security_mmap_file(file, prot, flag);\n\tif (!ret) {\n\t\tif (down_write_killable(&mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t\tret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,\n\t\t\t\t    &populate, &uf);\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_unmap_complete(mm, &uf);\n\t\tif (populate)\n\t\t\tmm_populate(ret, populate);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nunsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long prot,\n\tunsigned long flag, unsigned long pgoff)\n{\n\tunsigned long ret;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long populate;\n\tLIST_HEAD(uf);\n\n\tret = security_mmap_file(file, prot, flag);\n\tif (!ret) {\n\t\tif (down_write_killable(&mm->mmap_sem))\n\t\t\treturn -EINTR;\n\t\tret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,\n\t\t\t\t    &populate, &uf);\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_unmap_complete(mm, &uf);\n\t\tif (populate)\n\t\t\tmm_populate(ret, populate);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_file_setup",
          "args": [
            "HUGETLB_ANON_FILE",
            "len",
            "VM_NORESERVE",
            "&user",
            "HUGETLB_ANONHUGE_INODE",
            "(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "huge_page_size(hs)"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "hs"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_sizelog",
          "args": [
            "(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & MAP_HUGETLB && !is_file_hugepages(file)"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_hugepages",
          "args": [
            "file"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "huge_page_size(hstate_file(file))"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "hstate_file(file)"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_file",
          "args": [
            "file"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_hugepages",
          "args": [
            "file"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "fd"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mmap_fd",
          "args": [
            "fd",
            "flags"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long fd, unsigned long pgoff)\n{\n\tstruct file *file = NULL;\n\tunsigned long retval;\n\n\tif (!(flags & MAP_ANONYMOUS)) {\n\t\taudit_mmap_fd(fd, flags);\n\t\tfile = fget(fd);\n\t\tif (!file)\n\t\t\treturn -EBADF;\n\t\tif (is_file_hugepages(file))\n\t\t\tlen = ALIGN(len, huge_page_size(hstate_file(file)));\n\t\tretval = -EINVAL;\n\t\tif (unlikely(flags & MAP_HUGETLB && !is_file_hugepages(file)))\n\t\t\tgoto out_fput;\n\t} else if (flags & MAP_HUGETLB) {\n\t\tstruct user_struct *user = NULL;\n\t\tstruct hstate *hs;\n\n\t\ths = hstate_sizelog((flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (!hs)\n\t\t\treturn -EINVAL;\n\n\t\tlen = ALIGN(len, huge_page_size(hs));\n\t\t/*\n\t\t * VM_NORESERVE is used because the reservations will be\n\t\t * taken when vm_ops->mmap() is called\n\t\t * A dummy user value is used because we are not locking\n\t\t * memory so no accounting is necessary\n\t\t */\n\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len,\n\t\t\t\tVM_NORESERVE,\n\t\t\t\t&user, HUGETLB_ANONHUGE_INODE,\n\t\t\t\t(flags >> MAP_HUGE_SHIFT) & MAP_HUGE_MASK);\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\t}\n\n\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n\n\tretval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);\nout_fput:\n\tif (file)\n\t\tfput(file);\n\treturn retval;\n}"
  },
  {
    "function_name": "do_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1383-1565",
    "snippet": "unsigned long do_mmap(struct file *file, unsigned long addr,\n\t\t\tunsigned long len, unsigned long prot,\n\t\t\tunsigned long flags, vm_flags_t vm_flags,\n\t\t\tunsigned long pgoff, unsigned long *populate,\n\t\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint pkey = 0;\n\n\t*populate = 0;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Does the application expect PROT_READ to imply PROT_EXEC?\n\t *\n\t * (the exception is when the underlying filesystem is noexec\n\t *  mounted, in which case we dont add PROT_EXEC.)\n\t */\n\tif ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))\n\t\tif (!(file && path_noexec(&file->f_path)))\n\t\t\tprot |= PROT_EXEC;\n\n\t/* force arch specific MAP_FIXED handling in get_unmapped_area */\n\tif (flags & MAP_FIXED_NOREPLACE)\n\t\tflags |= MAP_FIXED;\n\n\tif (!(flags & MAP_FIXED))\n\t\taddr = round_hint_to_min(addr);\n\n\t/* Careful about overflows.. */\n\tlen = PAGE_ALIGN(len);\n\tif (!len)\n\t\treturn -ENOMEM;\n\n\t/* offset overflow? */\n\tif ((pgoff + (len >> PAGE_SHIFT)) < pgoff)\n\t\treturn -EOVERFLOW;\n\n\t/* Too many mappings? */\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\t/* Obtain the address to map to. we verify (or select) it and ensure\n\t * that it represents a valid section of the address space.\n\t */\n\taddr = get_unmapped_area(file, addr, len, pgoff, flags);\n\tif (offset_in_page(addr))\n\t\treturn addr;\n\n\tif (flags & MAP_FIXED_NOREPLACE) {\n\t\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\t\tif (vma && vma->vm_start < addr + len)\n\t\t\treturn -EEXIST;\n\t}\n\n\tif (prot == PROT_EXEC) {\n\t\tpkey = execute_only_pkey(mm);\n\t\tif (pkey < 0)\n\t\t\tpkey = 0;\n\t}\n\n\t/* Do simple checking here so the lower-level routines won't have\n\t * to. we assume access permissions have been handled by the open\n\t * of the memory object, so we don't do any here.\n\t */\n\tvm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |\n\t\t\tmm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;\n\n\tif (flags & MAP_LOCKED)\n\t\tif (!can_do_mlock())\n\t\t\treturn -EPERM;\n\n\tif (mlock_future_check(mm, vm_flags, len))\n\t\treturn -EAGAIN;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tunsigned long flags_mask;\n\n\t\tif (!file_mmap_ok(file, inode, pgoff, len))\n\t\t\treturn -EOVERFLOW;\n\n\t\tflags_mask = LEGACY_MAP_MASK | file->f_op->mmap_supported_flags;\n\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\t/*\n\t\t\t * Force use of MAP_SHARED_VALIDATE with non-legacy\n\t\t\t * flags. E.g. MAP_SYNC is dangerous to use with\n\t\t\t * MAP_SHARED as you don't know which consistency model\n\t\t\t * you will get. We silently ignore unsupported flags\n\t\t\t * with MAP_SHARED to preserve backward compatibility.\n\t\t\t */\n\t\t\tflags &= LEGACY_MAP_MASK;\n\t\t\t/* fall through */\n\t\tcase MAP_SHARED_VALIDATE:\n\t\t\tif (flags & ~flags_mask)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tif ((prot&PROT_WRITE) && !(file->f_mode&FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure we don't allow writing to an append-only\n\t\t\t * file..\n\t\t\t */\n\t\t\tif (IS_APPEND(inode) && (file->f_mode & FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure there are no mandatory locks on the file.\n\t\t\t */\n\t\t\tif (locks_verify_locked(file))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tif (!(file->f_mode & FMODE_WRITE))\n\t\t\t\tvm_flags &= ~(VM_MAYWRITE | VM_SHARED);\n\n\t\t\t/* fall through */\n\t\tcase MAP_PRIVATE:\n\t\t\tif (!(file->f_mode & FMODE_READ))\n\t\t\t\treturn -EACCES;\n\t\t\tif (path_noexec(&file->f_path)) {\n\t\t\t\tif (vm_flags & VM_EXEC)\n\t\t\t\t\treturn -EPERM;\n\t\t\t\tvm_flags &= ~VM_MAYEXEC;\n\t\t\t}\n\n\t\t\tif (!file->f_op->mmap)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * Ignore pgoff.\n\t\t\t */\n\t\t\tpgoff = 0;\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tbreak;\n\t\tcase MAP_PRIVATE:\n\t\t\t/*\n\t\t\t * Set pgoff according to addr for anon_vma.\n\t\t\t */\n\t\t\tpgoff = addr >> PAGE_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'VM_NORESERVE' if we should not account for the\n\t * memory use of this mapping.\n\t */\n\tif (flags & MAP_NORESERVE) {\n\t\t/* We honor MAP_NORESERVE if allowed to overcommit */\n\t\tif (sysctl_overcommit_memory != OVERCOMMIT_NEVER)\n\t\t\tvm_flags |= VM_NORESERVE;\n\n\t\t/* hugetlb applies strict overcommit unless MAP_NORESERVE */\n\t\tif (file && is_file_hugepages(file))\n\t\t\tvm_flags |= VM_NORESERVE;\n\t}\n\n\taddr = mmap_region(file, addr, len, vm_flags, pgoff, uf);\n\tif (!IS_ERR_VALUE(addr) &&\n\t    ((vm_flags & VM_LOCKED) ||\n\t     (flags & (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))\n\t\t*populate = len;\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "addr"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_region",
          "args": [
            "file",
            "addr",
            "len",
            "vm_flags",
            "pgoff",
            "uf"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "mmap_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1701-1865",
          "snippet": "unsigned long mmap_region(struct file *file, unsigned long addr,\n\t\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tint error;\n\tstruct rb_node **rb_link, *rb_parent;\n\tunsigned long charged = 0;\n\n\t/* Check against address space limit. */\n\tif (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {\n\t\tunsigned long nr_pages;\n\n\t\t/*\n\t\t * MAP_FIXED may remove pages of mappings that intersects with\n\t\t * requested mapping. Account for the pages it would unmap.\n\t\t */\n\t\tnr_pages = count_vma_pages_range(mm, addr, addr + len);\n\n\t\tif (!may_expand_vm(mm, vm_flags,\n\t\t\t\t\t(len >> PAGE_SHIFT) - nr_pages))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Clear old maps */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Private writable mapping: check memory availability\n\t */\n\tif (accountable_mapping(file, vm_flags)) {\n\t\tcharged = len >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn -ENOMEM;\n\t\tvm_flags |= VM_ACCOUNT;\n\t}\n\n\t/*\n\t * Can we just expand an old mapping?\n\t */\n\tvma = vma_merge(mm, prev, addr, addr + len, vm_flags,\n\t\t\tNULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * Determine the object being mapped and call the appropriate\n\t * specific mapper. the address has already been validated, but\n\t * not unmapped, but the maps are removed from the list.\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\terror = -ENOMEM;\n\t\tgoto unacct_error;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_flags = vm_flags;\n\tvma->vm_page_prot = vm_get_page_prot(vm_flags);\n\tvma->vm_pgoff = pgoff;\n\n\tif (file) {\n\t\tif (vm_flags & VM_DENYWRITE) {\n\t\t\terror = deny_write_access(file);\n\t\t\tif (error)\n\t\t\t\tgoto free_vma;\n\t\t}\n\t\tif (vm_flags & VM_SHARED) {\n\t\t\terror = mapping_map_writable(file->f_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto allow_write_and_free_vma;\n\t\t}\n\n\t\t/* ->mmap() can change vma->vm_file, but must guarantee that\n\t\t * vma_link() below can deny write-access if VM_DENYWRITE is set\n\t\t * and map writably if VM_SHARED is set. This usually means the\n\t\t * new file must not have been exposed to user-space, yet.\n\t\t */\n\t\tvma->vm_file = get_file(file);\n\t\terror = call_mmap(file, vma);\n\t\tif (error)\n\t\t\tgoto unmap_and_free_vma;\n\n\t\t/* Can addr have changed??\n\t\t *\n\t\t * Answer: Yes, several device drivers can do it in their\n\t\t *         f_op->mmap method. -DaveM\n\t\t * Bug: If addr is changed, prev, rb_link, rb_parent should\n\t\t *      be updated for vma_link()\n\t\t */\n\t\tWARN_ON_ONCE(addr != vma->vm_start);\n\n\t\taddr = vma->vm_start;\n\t\tvm_flags = vma->vm_flags;\n\t} else if (vm_flags & VM_SHARED) {\n\t\terror = shmem_zero_setup(vma);\n\t\tif (error)\n\t\t\tgoto free_vma;\n\t} else {\n\t\tvma_set_anonymous(vma);\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\t/* Once vma denies write, undo our temporary denial count */\n\tif (file) {\n\t\tif (vm_flags & VM_SHARED)\n\t\t\tmapping_unmap_writable(file->f_mapping);\n\t\tif (vm_flags & VM_DENYWRITE)\n\t\t\tallow_write_access(file);\n\t}\n\tfile = vma->vm_file;\nout:\n\tperf_event_mmap(vma);\n\n\tvm_stat_account(mm, vm_flags, len >> PAGE_SHIFT);\n\tif (vm_flags & VM_LOCKED) {\n\t\tif ((vm_flags & VM_SPECIAL) || vma_is_dax(vma) ||\n\t\t\t\t\tis_vm_hugetlb_page(vma) ||\n\t\t\t\t\tvma == get_gate_vma(current->mm))\n\t\t\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\t\telse\n\t\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\t}\n\n\tif (file)\n\t\tuprobe_mmap(vma);\n\n\t/*\n\t * New (or expanded) vma always get soft dirty status.\n\t * Otherwise user-space soft-dirty page tracker won't\n\t * be able to distinguish situation when vma area unmapped,\n\t * then new mapped in-place (which must be aimed as\n\t * a completely new data area).\n\t */\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\n\tvma_set_page_prot(vma);\n\n\treturn addr;\n\nunmap_and_free_vma:\n\tvma->vm_file = NULL;\n\tfput(file);\n\n\t/* Undo any partial mapping done by a device driver. */\n\tunmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);\n\tcharged = 0;\n\tif (vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(file->f_mapping);\nallow_write_and_free_vma:\n\tif (vm_flags & VM_DENYWRITE)\n\t\tallow_write_access(file);\nfree_vma:\n\tvm_area_free(vma);\nunacct_error:\n\tif (charged)\n\t\tvm_unacct_memory(charged);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nunsigned long mmap_region(struct file *file, unsigned long addr,\n\t\tunsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tint error;\n\tstruct rb_node **rb_link, *rb_parent;\n\tunsigned long charged = 0;\n\n\t/* Check against address space limit. */\n\tif (!may_expand_vm(mm, vm_flags, len >> PAGE_SHIFT)) {\n\t\tunsigned long nr_pages;\n\n\t\t/*\n\t\t * MAP_FIXED may remove pages of mappings that intersects with\n\t\t * requested mapping. Account for the pages it would unmap.\n\t\t */\n\t\tnr_pages = count_vma_pages_range(mm, addr, addr + len);\n\n\t\tif (!may_expand_vm(mm, vm_flags,\n\t\t\t\t\t(len >> PAGE_SHIFT) - nr_pages))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Clear old maps */\n\twhile (find_vma_links(mm, addr, addr + len, &prev, &rb_link,\n\t\t\t      &rb_parent)) {\n\t\tif (do_munmap(mm, addr, len, uf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Private writable mapping: check memory availability\n\t */\n\tif (accountable_mapping(file, vm_flags)) {\n\t\tcharged = len >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn -ENOMEM;\n\t\tvm_flags |= VM_ACCOUNT;\n\t}\n\n\t/*\n\t * Can we just expand an old mapping?\n\t */\n\tvma = vma_merge(mm, prev, addr, addr + len, vm_flags,\n\t\t\tNULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n\tif (vma)\n\t\tgoto out;\n\n\t/*\n\t * Determine the object being mapped and call the appropriate\n\t * specific mapper. the address has already been validated, but\n\t * not unmapped, but the maps are removed from the list.\n\t */\n\tvma = vm_area_alloc(mm);\n\tif (!vma) {\n\t\terror = -ENOMEM;\n\t\tgoto unacct_error;\n\t}\n\n\tvma->vm_start = addr;\n\tvma->vm_end = addr + len;\n\tvma->vm_flags = vm_flags;\n\tvma->vm_page_prot = vm_get_page_prot(vm_flags);\n\tvma->vm_pgoff = pgoff;\n\n\tif (file) {\n\t\tif (vm_flags & VM_DENYWRITE) {\n\t\t\terror = deny_write_access(file);\n\t\t\tif (error)\n\t\t\t\tgoto free_vma;\n\t\t}\n\t\tif (vm_flags & VM_SHARED) {\n\t\t\terror = mapping_map_writable(file->f_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto allow_write_and_free_vma;\n\t\t}\n\n\t\t/* ->mmap() can change vma->vm_file, but must guarantee that\n\t\t * vma_link() below can deny write-access if VM_DENYWRITE is set\n\t\t * and map writably if VM_SHARED is set. This usually means the\n\t\t * new file must not have been exposed to user-space, yet.\n\t\t */\n\t\tvma->vm_file = get_file(file);\n\t\terror = call_mmap(file, vma);\n\t\tif (error)\n\t\t\tgoto unmap_and_free_vma;\n\n\t\t/* Can addr have changed??\n\t\t *\n\t\t * Answer: Yes, several device drivers can do it in their\n\t\t *         f_op->mmap method. -DaveM\n\t\t * Bug: If addr is changed, prev, rb_link, rb_parent should\n\t\t *      be updated for vma_link()\n\t\t */\n\t\tWARN_ON_ONCE(addr != vma->vm_start);\n\n\t\taddr = vma->vm_start;\n\t\tvm_flags = vma->vm_flags;\n\t} else if (vm_flags & VM_SHARED) {\n\t\terror = shmem_zero_setup(vma);\n\t\tif (error)\n\t\t\tgoto free_vma;\n\t} else {\n\t\tvma_set_anonymous(vma);\n\t}\n\n\tvma_link(mm, vma, prev, rb_link, rb_parent);\n\t/* Once vma denies write, undo our temporary denial count */\n\tif (file) {\n\t\tif (vm_flags & VM_SHARED)\n\t\t\tmapping_unmap_writable(file->f_mapping);\n\t\tif (vm_flags & VM_DENYWRITE)\n\t\t\tallow_write_access(file);\n\t}\n\tfile = vma->vm_file;\nout:\n\tperf_event_mmap(vma);\n\n\tvm_stat_account(mm, vm_flags, len >> PAGE_SHIFT);\n\tif (vm_flags & VM_LOCKED) {\n\t\tif ((vm_flags & VM_SPECIAL) || vma_is_dax(vma) ||\n\t\t\t\t\tis_vm_hugetlb_page(vma) ||\n\t\t\t\t\tvma == get_gate_vma(current->mm))\n\t\t\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\t\telse\n\t\t\tmm->locked_vm += (len >> PAGE_SHIFT);\n\t}\n\n\tif (file)\n\t\tuprobe_mmap(vma);\n\n\t/*\n\t * New (or expanded) vma always get soft dirty status.\n\t * Otherwise user-space soft-dirty page tracker won't\n\t * be able to distinguish situation when vma area unmapped,\n\t * then new mapped in-place (which must be aimed as\n\t * a completely new data area).\n\t */\n\tvma->vm_flags |= VM_SOFTDIRTY;\n\n\tvma_set_page_prot(vma);\n\n\treturn addr;\n\nunmap_and_free_vma:\n\tvma->vm_file = NULL;\n\tfput(file);\n\n\t/* Undo any partial mapping done by a device driver. */\n\tunmap_region(mm, vma, prev, vma->vm_start, vma->vm_end);\n\tcharged = 0;\n\tif (vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(file->f_mapping);\nallow_write_and_free_vma:\n\tif (vm_flags & VM_DENYWRITE)\n\t\tallow_write_access(file);\nfree_vma:\n\tvm_area_free(vma);\nunacct_error:\n\tif (charged)\n\t\tvm_unacct_memory(charged);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_file_hugepages",
          "args": [
            "file"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_noexec",
          "args": [
            "&file->f_path"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_verify_locked",
          "args": [
            "file"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_mmap_ok",
          "args": [
            "file",
            "inode",
            "pgoff",
            "len"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "file_mmap_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1367-1378",
          "snippet": "static inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_future_check",
          "args": [
            "mm",
            "vm_flags",
            "len"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_future_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1333-1349",
          "snippet": "static inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_do_mlock",
          "args": [],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "can_do_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "29-36",
          "snippet": "bool can_do_mlock(void)\n{\n\tif (rlimit(RLIMIT_MEMLOCK) != 0)\n\t\treturn true;\n\tif (capable(CAP_IPC_LOCK))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nbool can_do_mlock(void)\n{\n\tif (rlimit(RLIMIT_MEMLOCK) != 0)\n\t\treturn true;\n\tif (capable(CAP_IPC_LOCK))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_vm_flag_bits",
          "args": [
            "flags"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_vm_prot_bits",
          "args": [
            "prot",
            "pkey"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute_only_pkey",
          "args": [
            "mm"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2215-2244",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct rb_node *rb_node;\n\tstruct vm_area_struct *vma;\n\n\t/* Check the cache first. */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\trb_node = mm->mm_rb.rb_node;\n\n\twhile (rb_node) {\n\t\tstruct vm_area_struct *tmp;\n\n\t\ttmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);\n\n\t\tif (tmp->vm_end > addr) {\n\t\t\tvma = tmp;\n\t\t\tif (tmp->vm_start <= addr)\n\t\t\t\tbreak;\n\t\t\trb_node = rb_node->rb_left;\n\t\t} else\n\t\t\trb_node = rb_node->rb_right;\n\t}\n\n\tif (vma)\n\t\tvmacache_update(addr, vma);\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unmapped_area",
          "args": [
            "file",
            "addr",
            "len",
            "pgoff",
            "flags"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "get_unmapped_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "2170-2210",
          "snippet": "unsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nunsigned long\nget_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n\t\tunsigned long pgoff, unsigned long flags)\n{\n\tunsigned long (*get_area)(struct file *, unsigned long,\n\t\t\t\t  unsigned long, unsigned long, unsigned long);\n\n\tunsigned long error = arch_mmap_check(addr, len, flags);\n\tif (error)\n\t\treturn error;\n\n\t/* Careful about overflows.. */\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\n\tget_area = current->mm->get_unmapped_area;\n\tif (file) {\n\t\tif (file->f_op->get_unmapped_area)\n\t\t\tget_area = file->f_op->get_unmapped_area;\n\t} else if (flags & MAP_SHARED) {\n\t\t/*\n\t\t * mmap_region() will call shmem_zero_setup() to create a file,\n\t\t * so use shmem's get_unmapped_area in case it can be huge.\n\t\t * do_mmap_pgoff() will clear pgoff, so match alignment.\n\t\t */\n\t\tpgoff = 0;\n\t\tget_area = shmem_get_unmapped_area;\n\t}\n\n\taddr = get_area(file, addr, len, pgoff, flags);\n\tif (IS_ERR_VALUE(addr))\n\t\treturn addr;\n\n\tif (addr > TASK_SIZE - len)\n\t\treturn -ENOMEM;\n\tif (offset_in_page(addr))\n\t\treturn -EINVAL;\n\n\terror = security_mmap_addr(addr);\n\treturn error ? error : addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_hint_to_min",
          "args": [
            "addr"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "round_hint_to_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1324-1331",
          "snippet": "static inline unsigned long round_hint_to_min(unsigned long hint)\n{\n\thint &= PAGE_MASK;\n\tif (((void *)hint != NULL) &&\n\t    (hint < mmap_min_addr))\n\t\treturn PAGE_ALIGN(mmap_min_addr);\n\treturn hint;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long round_hint_to_min(unsigned long hint)\n{\n\thint &= PAGE_MASK;\n\tif (((void *)hint != NULL) &&\n\t    (hint < mmap_min_addr))\n\t\treturn PAGE_ALIGN(mmap_min_addr);\n\treturn hint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_noexec",
          "args": [
            "&file->f_path"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nunsigned long do_mmap(struct file *file, unsigned long addr,\n\t\t\tunsigned long len, unsigned long prot,\n\t\t\tunsigned long flags, vm_flags_t vm_flags,\n\t\t\tunsigned long pgoff, unsigned long *populate,\n\t\t\tstruct list_head *uf)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint pkey = 0;\n\n\t*populate = 0;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Does the application expect PROT_READ to imply PROT_EXEC?\n\t *\n\t * (the exception is when the underlying filesystem is noexec\n\t *  mounted, in which case we dont add PROT_EXEC.)\n\t */\n\tif ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))\n\t\tif (!(file && path_noexec(&file->f_path)))\n\t\t\tprot |= PROT_EXEC;\n\n\t/* force arch specific MAP_FIXED handling in get_unmapped_area */\n\tif (flags & MAP_FIXED_NOREPLACE)\n\t\tflags |= MAP_FIXED;\n\n\tif (!(flags & MAP_FIXED))\n\t\taddr = round_hint_to_min(addr);\n\n\t/* Careful about overflows.. */\n\tlen = PAGE_ALIGN(len);\n\tif (!len)\n\t\treturn -ENOMEM;\n\n\t/* offset overflow? */\n\tif ((pgoff + (len >> PAGE_SHIFT)) < pgoff)\n\t\treturn -EOVERFLOW;\n\n\t/* Too many mappings? */\n\tif (mm->map_count > sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\t/* Obtain the address to map to. we verify (or select) it and ensure\n\t * that it represents a valid section of the address space.\n\t */\n\taddr = get_unmapped_area(file, addr, len, pgoff, flags);\n\tif (offset_in_page(addr))\n\t\treturn addr;\n\n\tif (flags & MAP_FIXED_NOREPLACE) {\n\t\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\t\tif (vma && vma->vm_start < addr + len)\n\t\t\treturn -EEXIST;\n\t}\n\n\tif (prot == PROT_EXEC) {\n\t\tpkey = execute_only_pkey(mm);\n\t\tif (pkey < 0)\n\t\t\tpkey = 0;\n\t}\n\n\t/* Do simple checking here so the lower-level routines won't have\n\t * to. we assume access permissions have been handled by the open\n\t * of the memory object, so we don't do any here.\n\t */\n\tvm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |\n\t\t\tmm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;\n\n\tif (flags & MAP_LOCKED)\n\t\tif (!can_do_mlock())\n\t\t\treturn -EPERM;\n\n\tif (mlock_future_check(mm, vm_flags, len))\n\t\treturn -EAGAIN;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tunsigned long flags_mask;\n\n\t\tif (!file_mmap_ok(file, inode, pgoff, len))\n\t\t\treturn -EOVERFLOW;\n\n\t\tflags_mask = LEGACY_MAP_MASK | file->f_op->mmap_supported_flags;\n\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\t/*\n\t\t\t * Force use of MAP_SHARED_VALIDATE with non-legacy\n\t\t\t * flags. E.g. MAP_SYNC is dangerous to use with\n\t\t\t * MAP_SHARED as you don't know which consistency model\n\t\t\t * you will get. We silently ignore unsupported flags\n\t\t\t * with MAP_SHARED to preserve backward compatibility.\n\t\t\t */\n\t\t\tflags &= LEGACY_MAP_MASK;\n\t\t\t/* fall through */\n\t\tcase MAP_SHARED_VALIDATE:\n\t\t\tif (flags & ~flags_mask)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tif ((prot&PROT_WRITE) && !(file->f_mode&FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure we don't allow writing to an append-only\n\t\t\t * file..\n\t\t\t */\n\t\t\tif (IS_APPEND(inode) && (file->f_mode & FMODE_WRITE))\n\t\t\t\treturn -EACCES;\n\n\t\t\t/*\n\t\t\t * Make sure there are no mandatory locks on the file.\n\t\t\t */\n\t\t\tif (locks_verify_locked(file))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tif (!(file->f_mode & FMODE_WRITE))\n\t\t\t\tvm_flags &= ~(VM_MAYWRITE | VM_SHARED);\n\n\t\t\t/* fall through */\n\t\tcase MAP_PRIVATE:\n\t\t\tif (!(file->f_mode & FMODE_READ))\n\t\t\t\treturn -EACCES;\n\t\t\tif (path_noexec(&file->f_path)) {\n\t\t\t\tif (vm_flags & VM_EXEC)\n\t\t\t\t\treturn -EPERM;\n\t\t\t\tvm_flags &= ~VM_MAYEXEC;\n\t\t\t}\n\n\t\t\tif (!file->f_op->mmap)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (flags & MAP_TYPE) {\n\t\tcase MAP_SHARED:\n\t\t\tif (vm_flags & (VM_GROWSDOWN|VM_GROWSUP))\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * Ignore pgoff.\n\t\t\t */\n\t\t\tpgoff = 0;\n\t\t\tvm_flags |= VM_SHARED | VM_MAYSHARE;\n\t\t\tbreak;\n\t\tcase MAP_PRIVATE:\n\t\t\t/*\n\t\t\t * Set pgoff according to addr for anon_vma.\n\t\t\t */\n\t\t\tpgoff = addr >> PAGE_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Set 'VM_NORESERVE' if we should not account for the\n\t * memory use of this mapping.\n\t */\n\tif (flags & MAP_NORESERVE) {\n\t\t/* We honor MAP_NORESERVE if allowed to overcommit */\n\t\tif (sysctl_overcommit_memory != OVERCOMMIT_NEVER)\n\t\t\tvm_flags |= VM_NORESERVE;\n\n\t\t/* hugetlb applies strict overcommit unless MAP_NORESERVE */\n\t\tif (file && is_file_hugepages(file))\n\t\t\tvm_flags |= VM_NORESERVE;\n\t}\n\n\taddr = mmap_region(file, addr, len, vm_flags, pgoff, uf);\n\tif (!IS_ERR_VALUE(addr) &&\n\t    ((vm_flags & VM_LOCKED) ||\n\t     (flags & (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))\n\t\t*populate = len;\n\treturn addr;\n}"
  },
  {
    "function_name": "file_mmap_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1367-1378",
    "snippet": "static inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_mmap_size_max",
          "args": [
            "file",
            "inode"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "file_mmap_size_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1351-1365",
          "snippet": "static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "file_mmap_size_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1351-1365",
    "snippet": "static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}"
  },
  {
    "function_name": "mlock_future_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1333-1349",
    "snippet": "static inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int mlock_future_check(struct mm_struct *mm,\n\t\t\t\t     unsigned long flags,\n\t\t\t\t     unsigned long len)\n{\n\tunsigned long locked, lock_limit;\n\n\t/*  mlock MCL_FUTURE? */\n\tif (flags & VM_LOCKED) {\n\t\tlocked = len >> PAGE_SHIFT;\n\t\tlocked += mm->locked_vm;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlock_limit >>= PAGE_SHIFT;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "round_hint_to_min",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1324-1331",
    "snippet": "static inline unsigned long round_hint_to_min(unsigned long hint)\n{\n\thint &= PAGE_MASK;\n\tif (((void *)hint != NULL) &&\n\t    (hint < mmap_min_addr))\n\t\treturn PAGE_ALIGN(mmap_min_addr);\n\treturn hint;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mmap_min_addr"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long round_hint_to_min(unsigned long hint)\n{\n\thint &= PAGE_MASK;\n\tif (((void *)hint != NULL) &&\n\t    (hint < mmap_min_addr))\n\t\treturn PAGE_ALIGN(mmap_min_addr);\n\treturn hint;\n}"
  },
  {
    "function_name": "find_mergeable_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1288-1318",
    "snippet": "struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma;\n\tstruct vm_area_struct *near;\n\n\tnear = vma->vm_next;\n\tif (!near)\n\t\tgoto try_prev;\n\n\tanon_vma = reusable_anon_vma(near, vma, near);\n\tif (anon_vma)\n\t\treturn anon_vma;\ntry_prev:\n\tnear = vma->vm_prev;\n\tif (!near)\n\t\tgoto none;\n\n\tanon_vma = reusable_anon_vma(near, near, vma);\n\tif (anon_vma)\n\t\treturn anon_vma;\nnone:\n\t/*\n\t * There's no absolute need to look only at touching neighbours:\n\t * we could search further afield for \"compatible\" anon_vmas.\n\t * But it would probably just be a waste of time searching,\n\t * or lead to too many vmas hanging off the same anon_vma.\n\t * We're trying to allow mprotect remerging later on,\n\t * not trying to minimize memory used for anon_vmas.\n\t */\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reusable_anon_vma",
          "args": [
            "near",
            "near",
            "vma"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "reusable_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1269-1278",
          "snippet": "static struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\tif (anon_vma_compatible(a, b)) {\n\t\tstruct anon_vma *anon_vma = READ_ONCE(old->anon_vma);\n\n\t\tif (anon_vma && list_is_singular(&old->anon_vma_chain))\n\t\t\treturn anon_vma;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\tif (anon_vma_compatible(a, b)) {\n\t\tstruct anon_vma *anon_vma = READ_ONCE(old->anon_vma);\n\n\t\tif (anon_vma && list_is_singular(&old->anon_vma_chain))\n\t\t\treturn anon_vma;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma *anon_vma;\n\tstruct vm_area_struct *near;\n\n\tnear = vma->vm_next;\n\tif (!near)\n\t\tgoto try_prev;\n\n\tanon_vma = reusable_anon_vma(near, vma, near);\n\tif (anon_vma)\n\t\treturn anon_vma;\ntry_prev:\n\tnear = vma->vm_prev;\n\tif (!near)\n\t\tgoto none;\n\n\tanon_vma = reusable_anon_vma(near, near, vma);\n\tif (anon_vma)\n\t\treturn anon_vma;\nnone:\n\t/*\n\t * There's no absolute need to look only at touching neighbours:\n\t * we could search further afield for \"compatible\" anon_vmas.\n\t * But it would probably just be a waste of time searching,\n\t * or lead to too many vmas hanging off the same anon_vma.\n\t * We're trying to allow mprotect remerging later on,\n\t * not trying to minimize memory used for anon_vmas.\n\t */\n\treturn NULL;\n}"
  },
  {
    "function_name": "reusable_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1269-1278",
    "snippet": "static struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\tif (anon_vma_compatible(a, b)) {\n\t\tstruct anon_vma *anon_vma = READ_ONCE(old->anon_vma);\n\n\t\tif (anon_vma && list_is_singular(&old->anon_vma_chain))\n\t\t\treturn anon_vma;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&old->anon_vma_chain"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "old->anon_vma"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_compatible",
          "args": [
            "a",
            "b"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_compatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1238-1245",
          "snippet": "static int anon_vma_compatible(struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\treturn a->vm_end == b->vm_start &&\n\t\tmpol_equal(vma_policy(a), vma_policy(b)) &&\n\t\ta->vm_file == b->vm_file &&\n\t\t!((a->vm_flags ^ b->vm_flags) & ~(VM_READ|VM_WRITE|VM_EXEC|VM_SOFTDIRTY)) &&\n\t\tb->vm_pgoff == a->vm_pgoff + ((b->vm_start - a->vm_start) >> PAGE_SHIFT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int anon_vma_compatible(struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\treturn a->vm_end == b->vm_start &&\n\t\tmpol_equal(vma_policy(a), vma_policy(b)) &&\n\t\ta->vm_file == b->vm_file &&\n\t\t!((a->vm_flags ^ b->vm_flags) & ~(VM_READ|VM_WRITE|VM_EXEC|VM_SOFTDIRTY)) &&\n\t\tb->vm_pgoff == a->vm_pgoff + ((b->vm_start - a->vm_start) >> PAGE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct anon_vma *reusable_anon_vma(struct vm_area_struct *old, struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\tif (anon_vma_compatible(a, b)) {\n\t\tstruct anon_vma *anon_vma = READ_ONCE(old->anon_vma);\n\n\t\tif (anon_vma && list_is_singular(&old->anon_vma_chain))\n\t\t\treturn anon_vma;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "anon_vma_compatible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1238-1245",
    "snippet": "static int anon_vma_compatible(struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\treturn a->vm_end == b->vm_start &&\n\t\tmpol_equal(vma_policy(a), vma_policy(b)) &&\n\t\ta->vm_file == b->vm_file &&\n\t\t!((a->vm_flags ^ b->vm_flags) & ~(VM_READ|VM_WRITE|VM_EXEC|VM_SOFTDIRTY)) &&\n\t\tb->vm_pgoff == a->vm_pgoff + ((b->vm_start - a->vm_start) >> PAGE_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpol_equal",
          "args": [
            "vma_policy(a)",
            "vma_policy(b)"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "__mpol_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2134-2160",
          "snippet": "bool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "b"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int anon_vma_compatible(struct vm_area_struct *a, struct vm_area_struct *b)\n{\n\treturn a->vm_end == b->vm_start &&\n\t\tmpol_equal(vma_policy(a), vma_policy(b)) &&\n\t\ta->vm_file == b->vm_file &&\n\t\t!((a->vm_flags ^ b->vm_flags) & ~(VM_READ|VM_WRITE|VM_EXEC|VM_SOFTDIRTY)) &&\n\t\tb->vm_pgoff == a->vm_pgoff + ((b->vm_start - a->vm_start) >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "vma_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1132-1223",
    "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "khugepaged_enter_vma_merge",
          "args": [
            "area",
            "vm_flags"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_enter_vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "453-470",
          "snippet": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vma_adjust",
          "args": [
            "area",
            "addr",
            "next->vm_end",
            "next->vm_pgoff - pglen",
            "NULL",
            "next"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "714-1001",
          "snippet": "int __vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert,\n\tstruct vm_area_struct *expand)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next = vma->vm_next, *orig_vma = vma;\n\tstruct address_space *mapping = NULL;\n\tstruct rb_root_cached *root = NULL;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct file *file = vma->vm_file;\n\tbool start_changed = false, end_changed = false;\n\tlong adjust_next = 0;\n\tint remove_next = 0;\n\n\tif (next && !insert) {\n\t\tstruct vm_area_struct *exporter = NULL, *importer = NULL;\n\n\t\tif (end >= next->vm_end) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping all the next, and\n\t\t\t * perhaps the one after too (mprotect case 6).\n\t\t\t * The only other cases that gets here are\n\t\t\t * case 1, case 7 and case 8.\n\t\t\t */\n\t\t\tif (next == expand) {\n\t\t\t\t/*\n\t\t\t\t * The only case where we don't expand \"vma\"\n\t\t\t\t * and we expand \"next\" instead is case 8.\n\t\t\t\t */\n\t\t\t\tVM_WARN_ON(end != next->vm_end);\n\t\t\t\t/*\n\t\t\t\t * remove_next == 3 means we're\n\t\t\t\t * removing \"vma\" and that to do so we\n\t\t\t\t * swapped \"vma\" and \"next\".\n\t\t\t\t */\n\t\t\t\tremove_next = 3;\n\t\t\t\tVM_WARN_ON(file != next->vm_file);\n\t\t\t\tswap(vma, next);\n\t\t\t} else {\n\t\t\t\tVM_WARN_ON(expand != vma);\n\t\t\t\t/*\n\t\t\t\t * case 1, 6, 7, remove_next == 2 is case 6,\n\t\t\t\t * remove_next == 1 is case 1 or 7.\n\t\t\t\t */\n\t\t\t\tremove_next = 1 + (end > next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 2 &&\n\t\t\t\t\t   end != next->vm_next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 1 &&\n\t\t\t\t\t   end != next->vm_end);\n\t\t\t\t/* trim end to next, for case 6 first pass */\n\t\t\t\tend = next->vm_end;\n\t\t\t}\n\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\n\t\t\t/*\n\t\t\t * If next doesn't have anon_vma, import from vma after\n\t\t\t * next, if the vma overlaps with it.\n\t\t\t */\n\t\t\tif (remove_next == 2 && !next->anon_vma)\n\t\t\t\texporter = next->vm_next;\n\n\t\t} else if (end > next->vm_start) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping part of the next:\n\t\t\t * mprotect case 5 shifting the boundary up.\n\t\t\t */\n\t\t\tadjust_next = (end - next->vm_start) >> PAGE_SHIFT;\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t} else if (end < vma->vm_end) {\n\t\t\t/*\n\t\t\t * vma shrinks, and !insert tells it's not\n\t\t\t * split_vma inserting another: so it must be\n\t\t\t * mprotect case 4 shifting the boundary down.\n\t\t\t */\n\t\t\tadjust_next = -((vma->vm_end - end) >> PAGE_SHIFT);\n\t\t\texporter = vma;\n\t\t\timporter = next;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t}\n\n\t\t/*\n\t\t * Easily overlooked: when mprotect shifts the boundary,\n\t\t * make sure the expanding vma has anon_vma set if the\n\t\t * shrinking vma had, to cover any anon pages imported.\n\t\t */\n\t\tif (exporter && exporter->anon_vma && !importer->anon_vma) {\n\t\t\tint error;\n\n\t\t\timporter->anon_vma = exporter->anon_vma;\n\t\t\terror = anon_vma_clone(importer, exporter);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\nagain:\n\tvma_adjust_trans_huge(orig_vma, start, end, adjust_next);\n\n\tif (file) {\n\t\tmapping = file->f_mapping;\n\t\troot = &mapping->i_mmap;\n\t\tuprobe_munmap(vma, vma->vm_start, vma->vm_end);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\n\t\ti_mmap_lock_write(mapping);\n\t\tif (insert) {\n\t\t\t/*\n\t\t\t * Put into interval tree now, so instantiated pages\n\t\t\t * are visible to arm/parisc __flush_dcache_page\n\t\t\t * throughout; but we cannot insert into address\n\t\t\t * space until vma start or end is updated.\n\t\t\t */\n\t\t\t__vma_link_file(insert);\n\t\t}\n\t}\n\n\tanon_vma = vma->anon_vma;\n\tif (!anon_vma && adjust_next)\n\t\tanon_vma = next->anon_vma;\n\tif (anon_vma) {\n\t\tVM_WARN_ON(adjust_next && next->anon_vma &&\n\t\t\t   anon_vma != next->anon_vma);\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_pre_update_vma(next);\n\t}\n\n\tif (root) {\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_remove(vma, root);\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_remove(next, root);\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tvma->vm_start = start;\n\t\tstart_changed = true;\n\t}\n\tif (end != vma->vm_end) {\n\t\tvma->vm_end = end;\n\t\tend_changed = true;\n\t}\n\tvma->vm_pgoff = pgoff;\n\tif (adjust_next) {\n\t\tnext->vm_start += adjust_next << PAGE_SHIFT;\n\t\tnext->vm_pgoff += adjust_next;\n\t}\n\n\tif (root) {\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_insert(next, root);\n\t\tvma_interval_tree_insert(vma, root);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n\n\tif (remove_next) {\n\t\t/*\n\t\t * vma_merge has merged next into vma, and needs\n\t\t * us to remove next before dropping the locks.\n\t\t */\n\t\tif (remove_next != 3)\n\t\t\t__vma_unlink_prev(mm, next, vma);\n\t\telse\n\t\t\t/*\n\t\t\t * vma is not before next if they've been\n\t\t\t * swapped.\n\t\t\t *\n\t\t\t * pre-swap() next->vm_start was reduced so\n\t\t\t * tell validate_mm_rb to ignore pre-swap()\n\t\t\t * \"next\" (which is stored in post-swap()\n\t\t\t * \"vma\").\n\t\t\t */\n\t\t\t__vma_unlink_common(mm, next, NULL, false, vma);\n\t\tif (file)\n\t\t\t__remove_shared_vm_struct(next, file, mapping);\n\t} else if (insert) {\n\t\t/*\n\t\t * split_vma has split insert from vma, and needs\n\t\t * us to insert it before dropping the locks\n\t\t * (it may either follow vma or precede it).\n\t\t */\n\t\t__insert_vm_struct(mm, insert);\n\t} else {\n\t\tif (start_changed)\n\t\t\tvma_gap_update(vma);\n\t\tif (end_changed) {\n\t\t\tif (!next)\n\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\telse if (!adjust_next)\n\t\t\t\tvma_gap_update(next);\n\t\t}\n\t}\n\n\tif (anon_vma) {\n\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_post_update_vma(next);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tif (root) {\n\t\tuprobe_mmap(vma);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_mmap(next);\n\t}\n\n\tif (remove_next) {\n\t\tif (file) {\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\t\t\tfput(file);\n\t\t}\n\t\tif (next->anon_vma)\n\t\t\tanon_vma_merge(vma, next);\n\t\tmm->map_count--;\n\t\tmpol_put(vma_policy(next));\n\t\tvm_area_free(next);\n\t\t/*\n\t\t * In mprotect's case 6 (see comments on vma_merge),\n\t\t * we must remove another next too. It would clutter\n\t\t * up the code too much to do both in one go.\n\t\t */\n\t\tif (remove_next != 3) {\n\t\t\t/*\n\t\t\t * If \"next\" was removed and vma->vm_end was\n\t\t\t * expanded (up) over it, in turn\n\t\t\t * \"next->vm_prev->vm_end\" changed and the\n\t\t\t * \"vma->vm_next\" gap must be updated.\n\t\t\t */\n\t\t\tnext = vma->vm_next;\n\t\t} else {\n\t\t\t/*\n\t\t\t * For the scope of the comment \"next\" and\n\t\t\t * \"vma\" considered pre-swap(): if \"vma\" was\n\t\t\t * removed, next->vm_start was expanded (down)\n\t\t\t * over it and the \"next\" gap must be updated.\n\t\t\t * Because of the swap() the post-swap() \"vma\"\n\t\t\t * actually points to pre-swap() \"next\"\n\t\t\t * (post-swap() \"next\" as opposed is now a\n\t\t\t * dangling pointer).\n\t\t\t */\n\t\t\tnext = vma;\n\t\t}\n\t\tif (remove_next == 2) {\n\t\t\tremove_next = 1;\n\t\t\tend = next->vm_end;\n\t\t\tgoto again;\n\t\t}\n\t\telse if (next)\n\t\t\tvma_gap_update(next);\n\t\telse {\n\t\t\t/*\n\t\t\t * If remove_next == 2 we obviously can't\n\t\t\t * reach this path.\n\t\t\t *\n\t\t\t * If remove_next == 3 we can't reach this\n\t\t\t * path because pre-swap() next is always not\n\t\t\t * NULL. pre-swap() \"next\" is not being\n\t\t\t * removed and its next->vm_end is not altered\n\t\t\t * (and furthermore \"end\" already matches\n\t\t\t * next->vm_end in remove_next == 3).\n\t\t\t *\n\t\t\t * We reach this only in the remove_next == 1\n\t\t\t * case if the \"next\" vma that was removed was\n\t\t\t * the highest vma of the mm. However in such\n\t\t\t * case next->vm_end == \"end\" and the extended\n\t\t\t * \"vma\" has vma->vm_end == next->vm_end so\n\t\t\t * mm->highest_vm_end doesn't need any update\n\t\t\t * in remove_next == 1 case.\n\t\t\t */\n\t\t\tVM_WARN_ON(mm->highest_vm_end != vm_end_gap(vma));\n\t\t}\n\t}\n\tif (insert && file)\n\t\tuprobe_mmap(insert);\n\n\tvalidate_mm(mm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nint __vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert,\n\tstruct vm_area_struct *expand)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next = vma->vm_next, *orig_vma = vma;\n\tstruct address_space *mapping = NULL;\n\tstruct rb_root_cached *root = NULL;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct file *file = vma->vm_file;\n\tbool start_changed = false, end_changed = false;\n\tlong adjust_next = 0;\n\tint remove_next = 0;\n\n\tif (next && !insert) {\n\t\tstruct vm_area_struct *exporter = NULL, *importer = NULL;\n\n\t\tif (end >= next->vm_end) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping all the next, and\n\t\t\t * perhaps the one after too (mprotect case 6).\n\t\t\t * The only other cases that gets here are\n\t\t\t * case 1, case 7 and case 8.\n\t\t\t */\n\t\t\tif (next == expand) {\n\t\t\t\t/*\n\t\t\t\t * The only case where we don't expand \"vma\"\n\t\t\t\t * and we expand \"next\" instead is case 8.\n\t\t\t\t */\n\t\t\t\tVM_WARN_ON(end != next->vm_end);\n\t\t\t\t/*\n\t\t\t\t * remove_next == 3 means we're\n\t\t\t\t * removing \"vma\" and that to do so we\n\t\t\t\t * swapped \"vma\" and \"next\".\n\t\t\t\t */\n\t\t\t\tremove_next = 3;\n\t\t\t\tVM_WARN_ON(file != next->vm_file);\n\t\t\t\tswap(vma, next);\n\t\t\t} else {\n\t\t\t\tVM_WARN_ON(expand != vma);\n\t\t\t\t/*\n\t\t\t\t * case 1, 6, 7, remove_next == 2 is case 6,\n\t\t\t\t * remove_next == 1 is case 1 or 7.\n\t\t\t\t */\n\t\t\t\tremove_next = 1 + (end > next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 2 &&\n\t\t\t\t\t   end != next->vm_next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 1 &&\n\t\t\t\t\t   end != next->vm_end);\n\t\t\t\t/* trim end to next, for case 6 first pass */\n\t\t\t\tend = next->vm_end;\n\t\t\t}\n\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\n\t\t\t/*\n\t\t\t * If next doesn't have anon_vma, import from vma after\n\t\t\t * next, if the vma overlaps with it.\n\t\t\t */\n\t\t\tif (remove_next == 2 && !next->anon_vma)\n\t\t\t\texporter = next->vm_next;\n\n\t\t} else if (end > next->vm_start) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping part of the next:\n\t\t\t * mprotect case 5 shifting the boundary up.\n\t\t\t */\n\t\t\tadjust_next = (end - next->vm_start) >> PAGE_SHIFT;\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t} else if (end < vma->vm_end) {\n\t\t\t/*\n\t\t\t * vma shrinks, and !insert tells it's not\n\t\t\t * split_vma inserting another: so it must be\n\t\t\t * mprotect case 4 shifting the boundary down.\n\t\t\t */\n\t\t\tadjust_next = -((vma->vm_end - end) >> PAGE_SHIFT);\n\t\t\texporter = vma;\n\t\t\timporter = next;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t}\n\n\t\t/*\n\t\t * Easily overlooked: when mprotect shifts the boundary,\n\t\t * make sure the expanding vma has anon_vma set if the\n\t\t * shrinking vma had, to cover any anon pages imported.\n\t\t */\n\t\tif (exporter && exporter->anon_vma && !importer->anon_vma) {\n\t\t\tint error;\n\n\t\t\timporter->anon_vma = exporter->anon_vma;\n\t\t\terror = anon_vma_clone(importer, exporter);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\nagain:\n\tvma_adjust_trans_huge(orig_vma, start, end, adjust_next);\n\n\tif (file) {\n\t\tmapping = file->f_mapping;\n\t\troot = &mapping->i_mmap;\n\t\tuprobe_munmap(vma, vma->vm_start, vma->vm_end);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\n\t\ti_mmap_lock_write(mapping);\n\t\tif (insert) {\n\t\t\t/*\n\t\t\t * Put into interval tree now, so instantiated pages\n\t\t\t * are visible to arm/parisc __flush_dcache_page\n\t\t\t * throughout; but we cannot insert into address\n\t\t\t * space until vma start or end is updated.\n\t\t\t */\n\t\t\t__vma_link_file(insert);\n\t\t}\n\t}\n\n\tanon_vma = vma->anon_vma;\n\tif (!anon_vma && adjust_next)\n\t\tanon_vma = next->anon_vma;\n\tif (anon_vma) {\n\t\tVM_WARN_ON(adjust_next && next->anon_vma &&\n\t\t\t   anon_vma != next->anon_vma);\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_pre_update_vma(next);\n\t}\n\n\tif (root) {\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_remove(vma, root);\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_remove(next, root);\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tvma->vm_start = start;\n\t\tstart_changed = true;\n\t}\n\tif (end != vma->vm_end) {\n\t\tvma->vm_end = end;\n\t\tend_changed = true;\n\t}\n\tvma->vm_pgoff = pgoff;\n\tif (adjust_next) {\n\t\tnext->vm_start += adjust_next << PAGE_SHIFT;\n\t\tnext->vm_pgoff += adjust_next;\n\t}\n\n\tif (root) {\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_insert(next, root);\n\t\tvma_interval_tree_insert(vma, root);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n\n\tif (remove_next) {\n\t\t/*\n\t\t * vma_merge has merged next into vma, and needs\n\t\t * us to remove next before dropping the locks.\n\t\t */\n\t\tif (remove_next != 3)\n\t\t\t__vma_unlink_prev(mm, next, vma);\n\t\telse\n\t\t\t/*\n\t\t\t * vma is not before next if they've been\n\t\t\t * swapped.\n\t\t\t *\n\t\t\t * pre-swap() next->vm_start was reduced so\n\t\t\t * tell validate_mm_rb to ignore pre-swap()\n\t\t\t * \"next\" (which is stored in post-swap()\n\t\t\t * \"vma\").\n\t\t\t */\n\t\t\t__vma_unlink_common(mm, next, NULL, false, vma);\n\t\tif (file)\n\t\t\t__remove_shared_vm_struct(next, file, mapping);\n\t} else if (insert) {\n\t\t/*\n\t\t * split_vma has split insert from vma, and needs\n\t\t * us to insert it before dropping the locks\n\t\t * (it may either follow vma or precede it).\n\t\t */\n\t\t__insert_vm_struct(mm, insert);\n\t} else {\n\t\tif (start_changed)\n\t\t\tvma_gap_update(vma);\n\t\tif (end_changed) {\n\t\t\tif (!next)\n\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\telse if (!adjust_next)\n\t\t\t\tvma_gap_update(next);\n\t\t}\n\t}\n\n\tif (anon_vma) {\n\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_post_update_vma(next);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tif (root) {\n\t\tuprobe_mmap(vma);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_mmap(next);\n\t}\n\n\tif (remove_next) {\n\t\tif (file) {\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\t\t\tfput(file);\n\t\t}\n\t\tif (next->anon_vma)\n\t\t\tanon_vma_merge(vma, next);\n\t\tmm->map_count--;\n\t\tmpol_put(vma_policy(next));\n\t\tvm_area_free(next);\n\t\t/*\n\t\t * In mprotect's case 6 (see comments on vma_merge),\n\t\t * we must remove another next too. It would clutter\n\t\t * up the code too much to do both in one go.\n\t\t */\n\t\tif (remove_next != 3) {\n\t\t\t/*\n\t\t\t * If \"next\" was removed and vma->vm_end was\n\t\t\t * expanded (up) over it, in turn\n\t\t\t * \"next->vm_prev->vm_end\" changed and the\n\t\t\t * \"vma->vm_next\" gap must be updated.\n\t\t\t */\n\t\t\tnext = vma->vm_next;\n\t\t} else {\n\t\t\t/*\n\t\t\t * For the scope of the comment \"next\" and\n\t\t\t * \"vma\" considered pre-swap(): if \"vma\" was\n\t\t\t * removed, next->vm_start was expanded (down)\n\t\t\t * over it and the \"next\" gap must be updated.\n\t\t\t * Because of the swap() the post-swap() \"vma\"\n\t\t\t * actually points to pre-swap() \"next\"\n\t\t\t * (post-swap() \"next\" as opposed is now a\n\t\t\t * dangling pointer).\n\t\t\t */\n\t\t\tnext = vma;\n\t\t}\n\t\tif (remove_next == 2) {\n\t\t\tremove_next = 1;\n\t\t\tend = next->vm_end;\n\t\t\tgoto again;\n\t\t}\n\t\telse if (next)\n\t\t\tvma_gap_update(next);\n\t\telse {\n\t\t\t/*\n\t\t\t * If remove_next == 2 we obviously can't\n\t\t\t * reach this path.\n\t\t\t *\n\t\t\t * If remove_next == 3 we can't reach this\n\t\t\t * path because pre-swap() next is always not\n\t\t\t * NULL. pre-swap() \"next\" is not being\n\t\t\t * removed and its next->vm_end is not altered\n\t\t\t * (and furthermore \"end\" already matches\n\t\t\t * next->vm_end in remove_next == 3).\n\t\t\t *\n\t\t\t * We reach this only in the remove_next == 1\n\t\t\t * case if the \"next\" vma that was removed was\n\t\t\t * the highest vma of the mm. However in such\n\t\t\t * case next->vm_end == \"end\" and the extended\n\t\t\t * \"vma\" has vma->vm_end == next->vm_end so\n\t\t\t * mm->highest_vm_end doesn't need any update\n\t\t\t * in remove_next == 1 case.\n\t\t\t */\n\t\t\tVM_WARN_ON(mm->highest_vm_end != vm_end_gap(vma));\n\t\t}\n\t}\n\tif (insert && file)\n\t\tuprobe_mmap(insert);\n\n\tvalidate_mm(mm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_vma_merge_before",
          "args": [
            "next",
            "vm_flags",
            "anon_vma",
            "file",
            "pgoff+pglen",
            "vm_userfaultfd_ctx"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "can_vma_merge_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1055-1067",
          "snippet": "static int\ncan_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t     struct anon_vma *anon_vma, struct file *file,\n\t\t     pgoff_t vm_pgoff,\n\t\t     struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tif (vma->vm_pgoff == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int\ncan_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t     struct anon_vma *anon_vma, struct file *file,\n\t\t     pgoff_t vm_pgoff,\n\t\t     struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tif (vma->vm_pgoff == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_equal",
          "args": [
            "policy",
            "vma_policy(next)"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "__mpol_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2134-2160",
          "snippet": "bool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "next"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mergeable_anon_vma",
          "args": [
            "prev->anon_vma",
            "next->anon_vma",
            "NULL"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "is_mergeable_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1030-1042",
          "snippet": "static inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_vma_merge_after",
          "args": [
            "prev",
            "vm_flags",
            "anon_vma",
            "file",
            "pgoff",
            "vm_userfaultfd_ctx"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "can_vma_merge_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1076-1090",
          "snippet": "static int\ncan_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t    struct anon_vma *anon_vma, struct file *file,\n\t\t    pgoff_t vm_pgoff,\n\t\t    struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tpgoff_t vm_pglen;\n\t\tvm_pglen = vma_pages(vma);\n\t\tif (vma->vm_pgoff + vm_pglen == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int\ncan_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t    struct anon_vma *anon_vma, struct file *file,\n\t\t    pgoff_t vm_pgoff,\n\t\t    struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tpgoff_t vm_pglen;\n\t\tvm_pglen = vma_pages(vma);\n\t\tif (vma->vm_pgoff + vm_pglen == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "addr >= end"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "area && end > area->vm_end"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "prev && addr <= prev->vm_start"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "can_vma_merge_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1076-1090",
    "snippet": "static int\ncan_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t    struct anon_vma *anon_vma, struct file *file,\n\t\t    pgoff_t vm_pgoff,\n\t\t    struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tpgoff_t vm_pglen;\n\t\tvm_pglen = vma_pages(vma);\n\t\tif (vma->vm_pgoff + vm_pglen == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "292-295",
          "snippet": "static inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void munlock_vma_pages_all(struct vm_area_struct *vma)\n{\n\tmunlock_vma_pages_range(vma, vma->vm_start, vma->vm_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mergeable_anon_vma",
          "args": [
            "anon_vma",
            "vma->anon_vma",
            "vma"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "is_mergeable_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1030-1042",
          "snippet": "static inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mergeable_vma",
          "args": [
            "vma",
            "file",
            "vm_flags",
            "vm_userfaultfd_ctx"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "is_mergeable_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1007-1028",
          "snippet": "static inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int\ncan_vma_merge_after(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t    struct anon_vma *anon_vma, struct file *file,\n\t\t    pgoff_t vm_pgoff,\n\t\t    struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tpgoff_t vm_pglen;\n\t\tvm_pglen = vma_pages(vma);\n\t\tif (vma->vm_pgoff + vm_pglen == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "can_vma_merge_before",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1055-1067",
    "snippet": "static int\ncan_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t     struct anon_vma *anon_vma, struct file *file,\n\t\t     pgoff_t vm_pgoff,\n\t\t     struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tif (vma->vm_pgoff == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_mergeable_anon_vma",
          "args": [
            "anon_vma",
            "vma->anon_vma",
            "vma"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "is_mergeable_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1030-1042",
          "snippet": "static inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mergeable_vma",
          "args": [
            "vma",
            "file",
            "vm_flags",
            "vm_userfaultfd_ctx"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "is_mergeable_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1007-1028",
          "snippet": "static inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int\ncan_vma_merge_before(struct vm_area_struct *vma, unsigned long vm_flags,\n\t\t     struct anon_vma *anon_vma, struct file *file,\n\t\t     pgoff_t vm_pgoff,\n\t\t     struct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tif (is_mergeable_vma(vma, file, vm_flags, vm_userfaultfd_ctx) &&\n\t    is_mergeable_anon_vma(anon_vma, vma->anon_vma, vma)) {\n\t\tif (vma->vm_pgoff == vm_pgoff)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "is_mergeable_anon_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1030-1042",
    "snippet": "static inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&vma->anon_vma_chain"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,\n\t\t\t\t\tstruct anon_vma *anon_vma2,\n\t\t\t\t\tstruct vm_area_struct *vma)\n{\n\t/*\n\t * The list_is_singular() test is to avoid merging VMA cloned from\n\t * parents. This can improve scalability caused by anon_vma lock.\n\t */\n\tif ((!anon_vma1 || !anon_vma2) && (!vma ||\n\t\tlist_is_singular(&vma->anon_vma_chain)))\n\t\treturn 1;\n\treturn anon_vma1 == anon_vma2;\n}"
  },
  {
    "function_name": "is_mergeable_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1007-1028",
    "snippet": "static inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_mergeable_vm_userfaultfd_ctx",
          "args": [
            "vma",
            "vm_userfaultfd_ctx"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int is_mergeable_vma(struct vm_area_struct *vma,\n\t\t\t\tstruct file *file, unsigned long vm_flags,\n\t\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\t/*\n\t * VM_SOFTDIRTY should not prevent from VMA merging, if we\n\t * match the flags but dirty bit -- the caller should mark\n\t * merged VMA as dirty. If dirty bit won't be excluded from\n\t * comparison, we increase pressue on the memory system forcing\n\t * the kernel to generate new VMAs when old one could be\n\t * extended instead.\n\t */\n\tif ((vma->vm_flags ^ vm_flags) & ~VM_SOFTDIRTY)\n\t\treturn 0;\n\tif (vma->vm_file != file)\n\t\treturn 0;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\treturn 0;\n\tif (!is_mergeable_vm_userfaultfd_ctx(vma, vm_userfaultfd_ctx))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__vma_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "714-1001",
    "snippet": "int __vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert,\n\tstruct vm_area_struct *expand)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next = vma->vm_next, *orig_vma = vma;\n\tstruct address_space *mapping = NULL;\n\tstruct rb_root_cached *root = NULL;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct file *file = vma->vm_file;\n\tbool start_changed = false, end_changed = false;\n\tlong adjust_next = 0;\n\tint remove_next = 0;\n\n\tif (next && !insert) {\n\t\tstruct vm_area_struct *exporter = NULL, *importer = NULL;\n\n\t\tif (end >= next->vm_end) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping all the next, and\n\t\t\t * perhaps the one after too (mprotect case 6).\n\t\t\t * The only other cases that gets here are\n\t\t\t * case 1, case 7 and case 8.\n\t\t\t */\n\t\t\tif (next == expand) {\n\t\t\t\t/*\n\t\t\t\t * The only case where we don't expand \"vma\"\n\t\t\t\t * and we expand \"next\" instead is case 8.\n\t\t\t\t */\n\t\t\t\tVM_WARN_ON(end != next->vm_end);\n\t\t\t\t/*\n\t\t\t\t * remove_next == 3 means we're\n\t\t\t\t * removing \"vma\" and that to do so we\n\t\t\t\t * swapped \"vma\" and \"next\".\n\t\t\t\t */\n\t\t\t\tremove_next = 3;\n\t\t\t\tVM_WARN_ON(file != next->vm_file);\n\t\t\t\tswap(vma, next);\n\t\t\t} else {\n\t\t\t\tVM_WARN_ON(expand != vma);\n\t\t\t\t/*\n\t\t\t\t * case 1, 6, 7, remove_next == 2 is case 6,\n\t\t\t\t * remove_next == 1 is case 1 or 7.\n\t\t\t\t */\n\t\t\t\tremove_next = 1 + (end > next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 2 &&\n\t\t\t\t\t   end != next->vm_next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 1 &&\n\t\t\t\t\t   end != next->vm_end);\n\t\t\t\t/* trim end to next, for case 6 first pass */\n\t\t\t\tend = next->vm_end;\n\t\t\t}\n\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\n\t\t\t/*\n\t\t\t * If next doesn't have anon_vma, import from vma after\n\t\t\t * next, if the vma overlaps with it.\n\t\t\t */\n\t\t\tif (remove_next == 2 && !next->anon_vma)\n\t\t\t\texporter = next->vm_next;\n\n\t\t} else if (end > next->vm_start) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping part of the next:\n\t\t\t * mprotect case 5 shifting the boundary up.\n\t\t\t */\n\t\t\tadjust_next = (end - next->vm_start) >> PAGE_SHIFT;\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t} else if (end < vma->vm_end) {\n\t\t\t/*\n\t\t\t * vma shrinks, and !insert tells it's not\n\t\t\t * split_vma inserting another: so it must be\n\t\t\t * mprotect case 4 shifting the boundary down.\n\t\t\t */\n\t\t\tadjust_next = -((vma->vm_end - end) >> PAGE_SHIFT);\n\t\t\texporter = vma;\n\t\t\timporter = next;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t}\n\n\t\t/*\n\t\t * Easily overlooked: when mprotect shifts the boundary,\n\t\t * make sure the expanding vma has anon_vma set if the\n\t\t * shrinking vma had, to cover any anon pages imported.\n\t\t */\n\t\tif (exporter && exporter->anon_vma && !importer->anon_vma) {\n\t\t\tint error;\n\n\t\t\timporter->anon_vma = exporter->anon_vma;\n\t\t\terror = anon_vma_clone(importer, exporter);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\nagain:\n\tvma_adjust_trans_huge(orig_vma, start, end, adjust_next);\n\n\tif (file) {\n\t\tmapping = file->f_mapping;\n\t\troot = &mapping->i_mmap;\n\t\tuprobe_munmap(vma, vma->vm_start, vma->vm_end);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\n\t\ti_mmap_lock_write(mapping);\n\t\tif (insert) {\n\t\t\t/*\n\t\t\t * Put into interval tree now, so instantiated pages\n\t\t\t * are visible to arm/parisc __flush_dcache_page\n\t\t\t * throughout; but we cannot insert into address\n\t\t\t * space until vma start or end is updated.\n\t\t\t */\n\t\t\t__vma_link_file(insert);\n\t\t}\n\t}\n\n\tanon_vma = vma->anon_vma;\n\tif (!anon_vma && adjust_next)\n\t\tanon_vma = next->anon_vma;\n\tif (anon_vma) {\n\t\tVM_WARN_ON(adjust_next && next->anon_vma &&\n\t\t\t   anon_vma != next->anon_vma);\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_pre_update_vma(next);\n\t}\n\n\tif (root) {\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_remove(vma, root);\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_remove(next, root);\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tvma->vm_start = start;\n\t\tstart_changed = true;\n\t}\n\tif (end != vma->vm_end) {\n\t\tvma->vm_end = end;\n\t\tend_changed = true;\n\t}\n\tvma->vm_pgoff = pgoff;\n\tif (adjust_next) {\n\t\tnext->vm_start += adjust_next << PAGE_SHIFT;\n\t\tnext->vm_pgoff += adjust_next;\n\t}\n\n\tif (root) {\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_insert(next, root);\n\t\tvma_interval_tree_insert(vma, root);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n\n\tif (remove_next) {\n\t\t/*\n\t\t * vma_merge has merged next into vma, and needs\n\t\t * us to remove next before dropping the locks.\n\t\t */\n\t\tif (remove_next != 3)\n\t\t\t__vma_unlink_prev(mm, next, vma);\n\t\telse\n\t\t\t/*\n\t\t\t * vma is not before next if they've been\n\t\t\t * swapped.\n\t\t\t *\n\t\t\t * pre-swap() next->vm_start was reduced so\n\t\t\t * tell validate_mm_rb to ignore pre-swap()\n\t\t\t * \"next\" (which is stored in post-swap()\n\t\t\t * \"vma\").\n\t\t\t */\n\t\t\t__vma_unlink_common(mm, next, NULL, false, vma);\n\t\tif (file)\n\t\t\t__remove_shared_vm_struct(next, file, mapping);\n\t} else if (insert) {\n\t\t/*\n\t\t * split_vma has split insert from vma, and needs\n\t\t * us to insert it before dropping the locks\n\t\t * (it may either follow vma or precede it).\n\t\t */\n\t\t__insert_vm_struct(mm, insert);\n\t} else {\n\t\tif (start_changed)\n\t\t\tvma_gap_update(vma);\n\t\tif (end_changed) {\n\t\t\tif (!next)\n\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\telse if (!adjust_next)\n\t\t\t\tvma_gap_update(next);\n\t\t}\n\t}\n\n\tif (anon_vma) {\n\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_post_update_vma(next);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tif (root) {\n\t\tuprobe_mmap(vma);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_mmap(next);\n\t}\n\n\tif (remove_next) {\n\t\tif (file) {\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\t\t\tfput(file);\n\t\t}\n\t\tif (next->anon_vma)\n\t\t\tanon_vma_merge(vma, next);\n\t\tmm->map_count--;\n\t\tmpol_put(vma_policy(next));\n\t\tvm_area_free(next);\n\t\t/*\n\t\t * In mprotect's case 6 (see comments on vma_merge),\n\t\t * we must remove another next too. It would clutter\n\t\t * up the code too much to do both in one go.\n\t\t */\n\t\tif (remove_next != 3) {\n\t\t\t/*\n\t\t\t * If \"next\" was removed and vma->vm_end was\n\t\t\t * expanded (up) over it, in turn\n\t\t\t * \"next->vm_prev->vm_end\" changed and the\n\t\t\t * \"vma->vm_next\" gap must be updated.\n\t\t\t */\n\t\t\tnext = vma->vm_next;\n\t\t} else {\n\t\t\t/*\n\t\t\t * For the scope of the comment \"next\" and\n\t\t\t * \"vma\" considered pre-swap(): if \"vma\" was\n\t\t\t * removed, next->vm_start was expanded (down)\n\t\t\t * over it and the \"next\" gap must be updated.\n\t\t\t * Because of the swap() the post-swap() \"vma\"\n\t\t\t * actually points to pre-swap() \"next\"\n\t\t\t * (post-swap() \"next\" as opposed is now a\n\t\t\t * dangling pointer).\n\t\t\t */\n\t\t\tnext = vma;\n\t\t}\n\t\tif (remove_next == 2) {\n\t\t\tremove_next = 1;\n\t\t\tend = next->vm_end;\n\t\t\tgoto again;\n\t\t}\n\t\telse if (next)\n\t\t\tvma_gap_update(next);\n\t\telse {\n\t\t\t/*\n\t\t\t * If remove_next == 2 we obviously can't\n\t\t\t * reach this path.\n\t\t\t *\n\t\t\t * If remove_next == 3 we can't reach this\n\t\t\t * path because pre-swap() next is always not\n\t\t\t * NULL. pre-swap() \"next\" is not being\n\t\t\t * removed and its next->vm_end is not altered\n\t\t\t * (and furthermore \"end\" already matches\n\t\t\t * next->vm_end in remove_next == 3).\n\t\t\t *\n\t\t\t * We reach this only in the remove_next == 1\n\t\t\t * case if the \"next\" vma that was removed was\n\t\t\t * the highest vma of the mm. However in such\n\t\t\t * case next->vm_end == \"end\" and the extended\n\t\t\t * \"vma\" has vma->vm_end == next->vm_end so\n\t\t\t * mm->highest_vm_end doesn't need any update\n\t\t\t * in remove_next == 1 case.\n\t\t\t */\n\t\t\tVM_WARN_ON(mm->highest_vm_end != vm_end_gap(vma));\n\t\t}\n\t}\n\tif (insert && file)\n\t\tuprobe_mmap(insert);\n\n\tvalidate_mm(mm);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_mm",
          "args": [
            "mm"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "385-423",
          "snippet": "static void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uprobe_mmap",
          "args": [
            "insert"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "mm->highest_vm_end != vm_end_gap(vma)"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_gap_update",
          "args": [
            "next"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "vma_gap_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "437-444",
          "snippet": "static void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_area_free",
          "args": [
            "next"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "vma_policy(next)"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "next"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_merge",
          "args": [
            "vma",
            "next"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_munmap",
          "args": [
            "next",
            "next->vm_start",
            "next->vm_end"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_mmap",
          "args": [
            "next"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_mmap",
          "args": [
            "vma"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "anon_vma"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_post_update_vma",
          "args": [
            "next"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_post_update_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "514-521",
          "snippet": "static inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__insert_vm_struct",
          "args": [
            "mm",
            "insert"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_vm_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "662-672",
          "snippet": "static void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\tBUG();\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\tmm->map_count++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\tBUG();\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\tmm->map_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_shared_vm_struct",
          "args": [
            "next",
            "file",
            "mapping"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_shared_vm_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "143-154",
          "snippet": "static void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vma_unlink_common",
          "args": [
            "mm",
            "next",
            "NULL",
            "false",
            "vma"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_unlink_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "674-698",
          "snippet": "static __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vma_unlink_prev",
          "args": [
            "mm",
            "next",
            "vma"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_unlink_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "700-705",
          "snippet": "static inline void __vma_unlink_prev(struct mm_struct *mm,\n\t\t\t\t     struct vm_area_struct *vma,\n\t\t\t\t     struct vm_area_struct *prev)\n{\n\t__vma_unlink_common(mm, vma, prev, true, vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void __vma_unlink_prev(struct mm_struct *mm,\n\t\t\t\t     struct vm_area_struct *vma,\n\t\t\t\t     struct vm_area_struct *prev)\n{\n\t__vma_unlink_common(mm, vma, prev, true, vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mmap_unlock",
          "args": [
            "mapping"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_insert",
          "args": [
            "vma",
            "root"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "72-84",
          "snippet": "INTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nINTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_remove",
          "args": [
            "next",
            "root"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "86-90",
          "snippet": "void anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nvoid anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mmap_lock",
          "args": [
            "mapping"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_pre_update_vma",
          "args": [
            "next"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_pre_update_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "505-512",
          "snippet": "static inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "anon_vma"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "adjust_next && next->anon_vma &&\n\t\t\t   anon_vma != next->anon_vma"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vma_link_file",
          "args": [
            "insert"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_link_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "609-626",
          "snippet": "static void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_munmap",
          "args": [
            "next",
            "next->vm_start",
            "next->vm_end"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_munmap",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_adjust_trans_huge",
          "args": [
            "orig_vma",
            "start",
            "end",
            "adjust_next"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "vma_adjust_trans_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2312-2351",
          "snippet": "void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t     unsigned long start,\n\t\t\t     unsigned long end,\n\t\t\t     long adjust_next)\n{\n\t/*\n\t * If the new start address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (start & ~HPAGE_PMD_MASK &&\n\t    (start & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (start & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, start, false, NULL);\n\n\t/*\n\t * If the new end address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (end & ~HPAGE_PMD_MASK &&\n\t    (end & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (end & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, end, false, NULL);\n\n\t/*\n\t * If we're also updating the vma->vm_next->vm_start, if the new\n\t * vm_next->vm_start isn't page aligned and it could previously\n\t * contain an hugepage: check if we need to split an huge pmd.\n\t */\n\tif (adjust_next > 0) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long nstart = next->vm_start;\n\t\tnstart += adjust_next << PAGE_SHIFT;\n\t\tif (nstart & ~HPAGE_PMD_MASK &&\n\t\t    (nstart & HPAGE_PMD_MASK) >= next->vm_start &&\n\t\t    (nstart & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= next->vm_end)\n\t\t\tsplit_huge_pmd_address(next, nstart, false, NULL);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t     unsigned long start,\n\t\t\t     unsigned long end,\n\t\t\t     long adjust_next)\n{\n\t/*\n\t * If the new start address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (start & ~HPAGE_PMD_MASK &&\n\t    (start & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (start & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, start, false, NULL);\n\n\t/*\n\t * If the new end address isn't hpage aligned and it could\n\t * previously contain an hugepage: check if we need to split\n\t * an huge pmd.\n\t */\n\tif (end & ~HPAGE_PMD_MASK &&\n\t    (end & HPAGE_PMD_MASK) >= vma->vm_start &&\n\t    (end & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)\n\t\tsplit_huge_pmd_address(vma, end, false, NULL);\n\n\t/*\n\t * If we're also updating the vma->vm_next->vm_start, if the new\n\t * vm_next->vm_start isn't page aligned and it could previously\n\t * contain an hugepage: check if we need to split an huge pmd.\n\t */\n\tif (adjust_next > 0) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long nstart = next->vm_start;\n\t\tnstart += adjust_next << PAGE_SHIFT;\n\t\tif (nstart & ~HPAGE_PMD_MASK &&\n\t\t    (nstart & HPAGE_PMD_MASK) >= next->vm_start &&\n\t\t    (nstart & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= next->vm_end)\n\t\t\tsplit_huge_pmd_address(next, nstart, false, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_clone",
          "args": [
            "importer",
            "exporter"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "261-308",
          "snippet": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\n\t\t/*\n\t\t * Reuse existing anon_vma if its degree lower than two,\n\t\t * that means it has no vma and only one anon_vma child.\n\t\t *\n\t\t * Do not chose parent anon_vma, otherwise first child\n\t\t * will always reuse it. Root anon_vma is never reused:\n\t\t * it has self-parent reference and at least one child.\n\t\t */\n\t\tif (!dst->anon_vma && anon_vma != src->anon_vma &&\n\t\t\t\tanon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n\n enomem_failure:\n\t/*\n\t * dst->anon_vma is dropped here otherwise its degree can be incorrectly\n\t * decremented in unlink_anon_vmas().\n\t * We can safely do this because callers of anon_vma_clone() don't care\n\t * about dst->anon_vma if anon_vma_clone() failed.\n\t */\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "expand != importer"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "expand != importer"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "remove_next == 1 &&\n\t\t\t\t\t   end != next->vm_end"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "remove_next == 2 &&\n\t\t\t\t\t   end != next->vm_next->vm_end"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "expand != vma"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "vma",
            "next"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "me_swapcache_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "765-773",
          "snippet": "static int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "file != next->vm_file"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "end != next->vm_end"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nint __vma_adjust(struct vm_area_struct *vma, unsigned long start,\n\tunsigned long end, pgoff_t pgoff, struct vm_area_struct *insert,\n\tstruct vm_area_struct *expand)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *next = vma->vm_next, *orig_vma = vma;\n\tstruct address_space *mapping = NULL;\n\tstruct rb_root_cached *root = NULL;\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct file *file = vma->vm_file;\n\tbool start_changed = false, end_changed = false;\n\tlong adjust_next = 0;\n\tint remove_next = 0;\n\n\tif (next && !insert) {\n\t\tstruct vm_area_struct *exporter = NULL, *importer = NULL;\n\n\t\tif (end >= next->vm_end) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping all the next, and\n\t\t\t * perhaps the one after too (mprotect case 6).\n\t\t\t * The only other cases that gets here are\n\t\t\t * case 1, case 7 and case 8.\n\t\t\t */\n\t\t\tif (next == expand) {\n\t\t\t\t/*\n\t\t\t\t * The only case where we don't expand \"vma\"\n\t\t\t\t * and we expand \"next\" instead is case 8.\n\t\t\t\t */\n\t\t\t\tVM_WARN_ON(end != next->vm_end);\n\t\t\t\t/*\n\t\t\t\t * remove_next == 3 means we're\n\t\t\t\t * removing \"vma\" and that to do so we\n\t\t\t\t * swapped \"vma\" and \"next\".\n\t\t\t\t */\n\t\t\t\tremove_next = 3;\n\t\t\t\tVM_WARN_ON(file != next->vm_file);\n\t\t\t\tswap(vma, next);\n\t\t\t} else {\n\t\t\t\tVM_WARN_ON(expand != vma);\n\t\t\t\t/*\n\t\t\t\t * case 1, 6, 7, remove_next == 2 is case 6,\n\t\t\t\t * remove_next == 1 is case 1 or 7.\n\t\t\t\t */\n\t\t\t\tremove_next = 1 + (end > next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 2 &&\n\t\t\t\t\t   end != next->vm_next->vm_end);\n\t\t\t\tVM_WARN_ON(remove_next == 1 &&\n\t\t\t\t\t   end != next->vm_end);\n\t\t\t\t/* trim end to next, for case 6 first pass */\n\t\t\t\tend = next->vm_end;\n\t\t\t}\n\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\n\t\t\t/*\n\t\t\t * If next doesn't have anon_vma, import from vma after\n\t\t\t * next, if the vma overlaps with it.\n\t\t\t */\n\t\t\tif (remove_next == 2 && !next->anon_vma)\n\t\t\t\texporter = next->vm_next;\n\n\t\t} else if (end > next->vm_start) {\n\t\t\t/*\n\t\t\t * vma expands, overlapping part of the next:\n\t\t\t * mprotect case 5 shifting the boundary up.\n\t\t\t */\n\t\t\tadjust_next = (end - next->vm_start) >> PAGE_SHIFT;\n\t\t\texporter = next;\n\t\t\timporter = vma;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t} else if (end < vma->vm_end) {\n\t\t\t/*\n\t\t\t * vma shrinks, and !insert tells it's not\n\t\t\t * split_vma inserting another: so it must be\n\t\t\t * mprotect case 4 shifting the boundary down.\n\t\t\t */\n\t\t\tadjust_next = -((vma->vm_end - end) >> PAGE_SHIFT);\n\t\t\texporter = vma;\n\t\t\timporter = next;\n\t\t\tVM_WARN_ON(expand != importer);\n\t\t}\n\n\t\t/*\n\t\t * Easily overlooked: when mprotect shifts the boundary,\n\t\t * make sure the expanding vma has anon_vma set if the\n\t\t * shrinking vma had, to cover any anon pages imported.\n\t\t */\n\t\tif (exporter && exporter->anon_vma && !importer->anon_vma) {\n\t\t\tint error;\n\n\t\t\timporter->anon_vma = exporter->anon_vma;\n\t\t\terror = anon_vma_clone(importer, exporter);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\nagain:\n\tvma_adjust_trans_huge(orig_vma, start, end, adjust_next);\n\n\tif (file) {\n\t\tmapping = file->f_mapping;\n\t\troot = &mapping->i_mmap;\n\t\tuprobe_munmap(vma, vma->vm_start, vma->vm_end);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\n\t\ti_mmap_lock_write(mapping);\n\t\tif (insert) {\n\t\t\t/*\n\t\t\t * Put into interval tree now, so instantiated pages\n\t\t\t * are visible to arm/parisc __flush_dcache_page\n\t\t\t * throughout; but we cannot insert into address\n\t\t\t * space until vma start or end is updated.\n\t\t\t */\n\t\t\t__vma_link_file(insert);\n\t\t}\n\t}\n\n\tanon_vma = vma->anon_vma;\n\tif (!anon_vma && adjust_next)\n\t\tanon_vma = next->anon_vma;\n\tif (anon_vma) {\n\t\tVM_WARN_ON(adjust_next && next->anon_vma &&\n\t\t\t   anon_vma != next->anon_vma);\n\t\tanon_vma_lock_write(anon_vma);\n\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_pre_update_vma(next);\n\t}\n\n\tif (root) {\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_remove(vma, root);\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_remove(next, root);\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tvma->vm_start = start;\n\t\tstart_changed = true;\n\t}\n\tif (end != vma->vm_end) {\n\t\tvma->vm_end = end;\n\t\tend_changed = true;\n\t}\n\tvma->vm_pgoff = pgoff;\n\tif (adjust_next) {\n\t\tnext->vm_start += adjust_next << PAGE_SHIFT;\n\t\tnext->vm_pgoff += adjust_next;\n\t}\n\n\tif (root) {\n\t\tif (adjust_next)\n\t\t\tvma_interval_tree_insert(next, root);\n\t\tvma_interval_tree_insert(vma, root);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n\n\tif (remove_next) {\n\t\t/*\n\t\t * vma_merge has merged next into vma, and needs\n\t\t * us to remove next before dropping the locks.\n\t\t */\n\t\tif (remove_next != 3)\n\t\t\t__vma_unlink_prev(mm, next, vma);\n\t\telse\n\t\t\t/*\n\t\t\t * vma is not before next if they've been\n\t\t\t * swapped.\n\t\t\t *\n\t\t\t * pre-swap() next->vm_start was reduced so\n\t\t\t * tell validate_mm_rb to ignore pre-swap()\n\t\t\t * \"next\" (which is stored in post-swap()\n\t\t\t * \"vma\").\n\t\t\t */\n\t\t\t__vma_unlink_common(mm, next, NULL, false, vma);\n\t\tif (file)\n\t\t\t__remove_shared_vm_struct(next, file, mapping);\n\t} else if (insert) {\n\t\t/*\n\t\t * split_vma has split insert from vma, and needs\n\t\t * us to insert it before dropping the locks\n\t\t * (it may either follow vma or precede it).\n\t\t */\n\t\t__insert_vm_struct(mm, insert);\n\t} else {\n\t\tif (start_changed)\n\t\t\tvma_gap_update(vma);\n\t\tif (end_changed) {\n\t\t\tif (!next)\n\t\t\t\tmm->highest_vm_end = vm_end_gap(vma);\n\t\t\telse if (!adjust_next)\n\t\t\t\tvma_gap_update(next);\n\t\t}\n\t}\n\n\tif (anon_vma) {\n\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\tif (adjust_next)\n\t\t\tanon_vma_interval_tree_post_update_vma(next);\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tif (root) {\n\t\tuprobe_mmap(vma);\n\n\t\tif (adjust_next)\n\t\t\tuprobe_mmap(next);\n\t}\n\n\tif (remove_next) {\n\t\tif (file) {\n\t\t\tuprobe_munmap(next, next->vm_start, next->vm_end);\n\t\t\tfput(file);\n\t\t}\n\t\tif (next->anon_vma)\n\t\t\tanon_vma_merge(vma, next);\n\t\tmm->map_count--;\n\t\tmpol_put(vma_policy(next));\n\t\tvm_area_free(next);\n\t\t/*\n\t\t * In mprotect's case 6 (see comments on vma_merge),\n\t\t * we must remove another next too. It would clutter\n\t\t * up the code too much to do both in one go.\n\t\t */\n\t\tif (remove_next != 3) {\n\t\t\t/*\n\t\t\t * If \"next\" was removed and vma->vm_end was\n\t\t\t * expanded (up) over it, in turn\n\t\t\t * \"next->vm_prev->vm_end\" changed and the\n\t\t\t * \"vma->vm_next\" gap must be updated.\n\t\t\t */\n\t\t\tnext = vma->vm_next;\n\t\t} else {\n\t\t\t/*\n\t\t\t * For the scope of the comment \"next\" and\n\t\t\t * \"vma\" considered pre-swap(): if \"vma\" was\n\t\t\t * removed, next->vm_start was expanded (down)\n\t\t\t * over it and the \"next\" gap must be updated.\n\t\t\t * Because of the swap() the post-swap() \"vma\"\n\t\t\t * actually points to pre-swap() \"next\"\n\t\t\t * (post-swap() \"next\" as opposed is now a\n\t\t\t * dangling pointer).\n\t\t\t */\n\t\t\tnext = vma;\n\t\t}\n\t\tif (remove_next == 2) {\n\t\t\tremove_next = 1;\n\t\t\tend = next->vm_end;\n\t\t\tgoto again;\n\t\t}\n\t\telse if (next)\n\t\t\tvma_gap_update(next);\n\t\telse {\n\t\t\t/*\n\t\t\t * If remove_next == 2 we obviously can't\n\t\t\t * reach this path.\n\t\t\t *\n\t\t\t * If remove_next == 3 we can't reach this\n\t\t\t * path because pre-swap() next is always not\n\t\t\t * NULL. pre-swap() \"next\" is not being\n\t\t\t * removed and its next->vm_end is not altered\n\t\t\t * (and furthermore \"end\" already matches\n\t\t\t * next->vm_end in remove_next == 3).\n\t\t\t *\n\t\t\t * We reach this only in the remove_next == 1\n\t\t\t * case if the \"next\" vma that was removed was\n\t\t\t * the highest vma of the mm. However in such\n\t\t\t * case next->vm_end == \"end\" and the extended\n\t\t\t * \"vma\" has vma->vm_end == next->vm_end so\n\t\t\t * mm->highest_vm_end doesn't need any update\n\t\t\t * in remove_next == 1 case.\n\t\t\t */\n\t\t\tVM_WARN_ON(mm->highest_vm_end != vm_end_gap(vma));\n\t\t}\n\t}\n\tif (insert && file)\n\t\tuprobe_mmap(insert);\n\n\tvalidate_mm(mm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__vma_unlink_prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "700-705",
    "snippet": "static inline void __vma_unlink_prev(struct mm_struct *mm,\n\t\t\t\t     struct vm_area_struct *vma,\n\t\t\t\t     struct vm_area_struct *prev)\n{\n\t__vma_unlink_common(mm, vma, prev, true, vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_unlink_common",
          "args": [
            "mm",
            "vma",
            "prev",
            "true",
            "vma"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_unlink_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "674-698",
          "snippet": "static __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void __vma_unlink_prev(struct mm_struct *mm,\n\t\t\t\t     struct vm_area_struct *vma,\n\t\t\t\t     struct vm_area_struct *prev)\n{\n\t__vma_unlink_common(mm, vma, prev, true, vma);\n}"
  },
  {
    "function_name": "__vma_unlink_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "674-698",
    "snippet": "static __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmacache_invalidate",
          "args": [
            "mm"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_rb_erase_ignore",
          "args": [
            "vma",
            "&mm->mm_rb",
            "ignore"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase_ignore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "465-477",
          "snippet": "static __always_inline void vma_rb_erase_ignore(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the \"next\" vma being erased if\n\t * next->vm_start was reduced.\n\t */\n\tvalidate_mm_rb(root, ignore);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase_ignore(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the \"next\" vma being erased if\n\t * next->vm_start was reduced.\n\t */\n\tvalidate_mm_rb(root, ignore);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}"
  },
  {
    "function_name": "__insert_vm_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "662-672",
    "snippet": "static void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\tBUG();\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\tmm->map_count++;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_link",
          "args": [
            "mm",
            "vma",
            "prev",
            "rb_link",
            "rb_parent"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "628-635",
          "snippet": "static void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_links",
          "args": [
            "mm",
            "vma->vm_start",
            "vma->vm_end",
            "&prev",
            "&rb_link",
            "&rb_parent"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "523-555",
          "snippet": "static int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\n\tif (find_vma_links(mm, vma->vm_start, vma->vm_end,\n\t\t\t   &prev, &rb_link, &rb_parent))\n\t\tBUG();\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\tmm->map_count++;\n}"
  },
  {
    "function_name": "vma_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "637-656",
    "snippet": "static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_mm",
          "args": [
            "mm"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "385-423",
          "snippet": "static void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vma_link_file",
          "args": [
            "vma"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_link_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "609-626",
          "snippet": "static void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vma_link",
          "args": [
            "mm",
            "vma",
            "prev",
            "rb_link",
            "rb_parent"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "628-635",
          "snippet": "static void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\t\t\tstruct rb_node *rb_parent)\n{\n\tstruct address_space *mapping = NULL;\n\n\tif (vma->vm_file) {\n\t\tmapping = vma->vm_file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t}\n\n\t__vma_link(mm, vma, prev, rb_link, rb_parent);\n\t__vma_link_file(vma);\n\n\tif (mapping)\n\t\ti_mmap_unlock_write(mapping);\n\n\tmm->map_count++;\n\tvalidate_mm(mm);\n}"
  },
  {
    "function_name": "__vma_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "628-635",
    "snippet": "static void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_link_rb",
          "args": [
            "mm",
            "vma",
            "rb_link",
            "rb_parent"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_link_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "585-607",
          "snippet": "void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct rb_node **rb_link, struct rb_node *rb_parent)\n{\n\t/* Update tracking information for the gap following the new vma. */\n\tif (vma->vm_next)\n\t\tvma_gap_update(vma->vm_next);\n\telse\n\t\tmm->highest_vm_end = vm_end_gap(vma);\n\n\t/*\n\t * vma->vm_prev wasn't known when we followed the rbtree to find the\n\t * correct insertion point for that vma. As a result, we could not\n\t * update the vma vm_rb parents rb_subtree_gap values on the way down.\n\t * So, we first insert the vma with a zero rb_subtree_gap value\n\t * (to be consistent with what we did on the way down), and then\n\t * immediately update the gap to the correct value. Finally we\n\t * rebalance the rbtree after all augmented values have been set.\n\t */\n\trb_link_node(&vma->vm_rb, rb_parent, rb_link);\n\tvma->rb_subtree_gap = 0;\n\tvma_gap_update(vma);\n\tvma_rb_insert(vma, &mm->mm_rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct rb_node **rb_link, struct rb_node *rb_parent)\n{\n\t/* Update tracking information for the gap following the new vma. */\n\tif (vma->vm_next)\n\t\tvma_gap_update(vma->vm_next);\n\telse\n\t\tmm->highest_vm_end = vm_end_gap(vma);\n\n\t/*\n\t * vma->vm_prev wasn't known when we followed the rbtree to find the\n\t * correct insertion point for that vma. As a result, we could not\n\t * update the vma vm_rb parents rb_subtree_gap values on the way down.\n\t * So, we first insert the vma with a zero rb_subtree_gap value\n\t * (to be consistent with what we did on the way down), and then\n\t * immediately update the gap to the correct value. Finally we\n\t * rebalance the rbtree after all augmented values have been set.\n\t */\n\trb_link_node(&vma->vm_rb, rb_parent, rb_link);\n\tvma->rb_subtree_gap = 0;\n\tvma_gap_update(vma);\n\tvma_rb_insert(vma, &mm->mm_rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vma_link_list",
          "args": [
            "mm",
            "vma",
            "prev",
            "rb_parent"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_link_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "252-272",
          "snippet": "void __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct vm_area_struct *prev, struct rb_node *rb_parent)\n{\n\tstruct vm_area_struct *next;\n\n\tvma->vm_prev = prev;\n\tif (prev) {\n\t\tnext = prev->vm_next;\n\t\tprev->vm_next = vma;\n\t} else {\n\t\tmm->mmap = vma;\n\t\tif (rb_parent)\n\t\t\tnext = rb_entry(rb_parent,\n\t\t\t\t\tstruct vm_area_struct, vm_rb);\n\t\telse\n\t\t\tnext = NULL;\n\t}\n\tvma->vm_next = next;\n\tif (next)\n\t\tnext->vm_prev = vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct vm_area_struct *prev, struct rb_node *rb_parent)\n{\n\tstruct vm_area_struct *next;\n\n\tvma->vm_prev = prev;\n\tif (prev) {\n\t\tnext = prev->vm_next;\n\t\tprev->vm_next = vma;\n\t} else {\n\t\tmm->mmap = vma;\n\t\tif (rb_parent)\n\t\t\tnext = rb_entry(rb_parent,\n\t\t\t\t\tstruct vm_area_struct, vm_rb);\n\t\telse\n\t\t\tnext = NULL;\n\t}\n\tvma->vm_next = next;\n\tif (next)\n\t\tnext->vm_prev = vma;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\n__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}"
  },
  {
    "function_name": "__vma_link_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "609-626",
    "snippet": "static void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_mmap_unlock",
          "args": [
            "mapping"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_insert",
          "args": [
            "vma",
            "&mapping->i_mmap"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "72-84",
          "snippet": "INTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nINTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mmap_lock",
          "args": [
            "mapping"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&mapping->i_mmap_writable"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&file_inode(file)->i_writecount"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __vma_link_file(struct vm_area_struct *vma)\n{\n\tstruct file *file;\n\n\tfile = vma->vm_file;\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\tif (vma->vm_flags & VM_DENYWRITE)\n\t\t\tatomic_dec(&file_inode(file)->i_writecount);\n\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\tatomic_inc(&mapping->i_mmap_writable);\n\n\t\tflush_dcache_mmap_lock(mapping);\n\t\tvma_interval_tree_insert(vma, &mapping->i_mmap);\n\t\tflush_dcache_mmap_unlock(mapping);\n\t}\n}"
  },
  {
    "function_name": "__vma_link_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "585-607",
    "snippet": "void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct rb_node **rb_link, struct rb_node *rb_parent)\n{\n\t/* Update tracking information for the gap following the new vma. */\n\tif (vma->vm_next)\n\t\tvma_gap_update(vma->vm_next);\n\telse\n\t\tmm->highest_vm_end = vm_end_gap(vma);\n\n\t/*\n\t * vma->vm_prev wasn't known when we followed the rbtree to find the\n\t * correct insertion point for that vma. As a result, we could not\n\t * update the vma vm_rb parents rb_subtree_gap values on the way down.\n\t * So, we first insert the vma with a zero rb_subtree_gap value\n\t * (to be consistent with what we did on the way down), and then\n\t * immediately update the gap to the correct value. Finally we\n\t * rebalance the rbtree after all augmented values have been set.\n\t */\n\trb_link_node(&vma->vm_rb, rb_parent, rb_link);\n\tvma->rb_subtree_gap = 0;\n\tvma_gap_update(vma);\n\tvma_rb_insert(vma, &mm->mm_rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_rb_insert",
          "args": [
            "vma",
            "&mm->mm_rb"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "446-453",
          "snippet": "static inline void vma_rb_insert(struct vm_area_struct *vma,\n\t\t\t\t struct rb_root *root)\n{\n\t/* All rb_subtree_gap values must be consistent prior to insertion */\n\tvalidate_mm_rb(root, NULL);\n\n\trb_insert_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void vma_rb_insert(struct vm_area_struct *vma,\n\t\t\t\t struct rb_root *root)\n{\n\t/* All rb_subtree_gap values must be consistent prior to insertion */\n\tvalidate_mm_rb(root, NULL);\n\n\trb_insert_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_gap_update",
          "args": [
            "vma"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "vma_gap_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "437-444",
          "snippet": "static void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&vma->vm_rb",
            "rb_parent",
            "rb_link"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tstruct rb_node **rb_link, struct rb_node *rb_parent)\n{\n\t/* Update tracking information for the gap following the new vma. */\n\tif (vma->vm_next)\n\t\tvma_gap_update(vma->vm_next);\n\telse\n\t\tmm->highest_vm_end = vm_end_gap(vma);\n\n\t/*\n\t * vma->vm_prev wasn't known when we followed the rbtree to find the\n\t * correct insertion point for that vma. As a result, we could not\n\t * update the vma vm_rb parents rb_subtree_gap values on the way down.\n\t * So, we first insert the vma with a zero rb_subtree_gap value\n\t * (to be consistent with what we did on the way down), and then\n\t * immediately update the gap to the correct value. Finally we\n\t * rebalance the rbtree after all augmented values have been set.\n\t */\n\trb_link_node(&vma->vm_rb, rb_parent, rb_link);\n\tvma->rb_subtree_gap = 0;\n\tvma_gap_update(vma);\n\tvma_rb_insert(vma, &mm->mm_rb);\n}"
  },
  {
    "function_name": "count_vma_pages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "557-583",
    "snippet": "static unsigned long count_vma_pages_range(struct mm_struct *mm,\n\t\tunsigned long addr, unsigned long end)\n{\n\tunsigned long nr_pages = 0;\n\tstruct vm_area_struct *vma;\n\n\t/* Find first overlaping mapping */\n\tvma = find_vma_intersection(mm, addr, end);\n\tif (!vma)\n\t\treturn 0;\n\n\tnr_pages = (min(end, vma->vm_end) -\n\t\tmax(addr, vma->vm_start)) >> PAGE_SHIFT;\n\n\t/* Iterate over the rest of the overlaps */\n\tfor (vma = vma->vm_next; vma; vma = vma->vm_next) {\n\t\tunsigned long overlap_len;\n\n\t\tif (vma->vm_start > end)\n\t\t\tbreak;\n\n\t\toverlap_len = min(end, vma->vm_end) - vma->vm_start;\n\t\tnr_pages += overlap_len >> PAGE_SHIFT;\n\t}\n\n\treturn nr_pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "vma->vm_end"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "addr",
            "vma->vm_start"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "file_mmap_size_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1351-1365",
          "snippet": "static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma_intersection",
          "args": [
            "mm",
            "addr",
            "end"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic unsigned long count_vma_pages_range(struct mm_struct *mm,\n\t\tunsigned long addr, unsigned long end)\n{\n\tunsigned long nr_pages = 0;\n\tstruct vm_area_struct *vma;\n\n\t/* Find first overlaping mapping */\n\tvma = find_vma_intersection(mm, addr, end);\n\tif (!vma)\n\t\treturn 0;\n\n\tnr_pages = (min(end, vma->vm_end) -\n\t\tmax(addr, vma->vm_start)) >> PAGE_SHIFT;\n\n\t/* Iterate over the rest of the overlaps */\n\tfor (vma = vma->vm_next; vma; vma = vma->vm_next) {\n\t\tunsigned long overlap_len;\n\n\t\tif (vma->vm_start > end)\n\t\t\tbreak;\n\n\t\toverlap_len = min(end, vma->vm_end) - vma->vm_start;\n\t\tnr_pages += overlap_len >> PAGE_SHIFT;\n\t}\n\n\treturn nr_pages;\n}"
  },
  {
    "function_name": "find_vma_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "523-555",
    "snippet": "static int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_prev",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "__rb_parent",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstatic int find_vma_links(struct mm_struct *mm, unsigned long addr,\n\t\tunsigned long end, struct vm_area_struct **pprev,\n\t\tstruct rb_node ***rb_link, struct rb_node **rb_parent)\n{\n\tstruct rb_node **__rb_link, *__rb_parent, *rb_prev;\n\n\t__rb_link = &mm->mm_rb.rb_node;\n\trb_prev = __rb_parent = NULL;\n\n\twhile (*__rb_link) {\n\t\tstruct vm_area_struct *vma_tmp;\n\n\t\t__rb_parent = *__rb_link;\n\t\tvma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);\n\n\t\tif (vma_tmp->vm_end > addr) {\n\t\t\t/* Fail if an existing vma overlaps the area */\n\t\t\tif (vma_tmp->vm_start < end)\n\t\t\t\treturn -ENOMEM;\n\t\t\t__rb_link = &__rb_parent->rb_left;\n\t\t} else {\n\t\t\trb_prev = __rb_parent;\n\t\t\t__rb_link = &__rb_parent->rb_right;\n\t\t}\n\t}\n\n\t*pprev = NULL;\n\tif (rb_prev)\n\t\t*pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);\n\t*rb_link = __rb_link;\n\t*rb_parent = __rb_parent;\n\treturn 0;\n}"
  },
  {
    "function_name": "anon_vma_interval_tree_post_update_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "514-521",
    "snippet": "static inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_insert",
          "args": [
            "avc",
            "&avc->anon_vma->rb_root"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "72-84",
          "snippet": "INTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nINTERVAL_TREE_DEFINE(struct anon_vma_chain, rb, unsigned long, rb_subtree_last,\n\t\t     avc_start_pgoff, avc_last_pgoff,\n\t\t     static inline, __anon_vma_interval_tree)\n\nvoid anon_vma_interval_tree_insert(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n#ifdef CONFIG_DEBUG_VM_RB\n\tnode->cached_vma_start = avc_start_pgoff(node);\n\tnode->cached_vma_last = avc_last_pgoff(node);\n#endif\n\t__anon_vma_interval_tree_insert(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "avc",
            "&vma->anon_vma_chain",
            "same_vma"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_post_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_insert(avc, &avc->anon_vma->rb_root);\n}"
  },
  {
    "function_name": "anon_vma_interval_tree_pre_update_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "505-512",
    "snippet": "static inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_remove",
          "args": [
            "avc",
            "&avc->anon_vma->rb_root"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "86-90",
          "snippet": "void anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nvoid anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "avc",
            "&vma->anon_vma_chain",
            "same_vma"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void\nanon_vma_interval_tree_pre_update_vma(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc;\n\n\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\tanon_vma_interval_tree_remove(avc, &avc->anon_vma->rb_root);\n}"
  },
  {
    "function_name": "vma_rb_erase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "479-489",
    "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_rb_erase",
          "args": [
            "vma",
            "root"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "455-463",
          "snippet": "static void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_mm_rb",
          "args": [
            "root",
            "vma"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "372-383",
          "snippet": "static void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
  },
  {
    "function_name": "vma_rb_erase_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "465-477",
    "snippet": "static __always_inline void vma_rb_erase_ignore(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the \"next\" vma being erased if\n\t * next->vm_start was reduced.\n\t */\n\tvalidate_mm_rb(root, ignore);\n\n\t__vma_rb_erase(vma, root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vma_rb_erase",
          "args": [
            "vma",
            "root"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "455-463",
          "snippet": "static void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_mm_rb",
          "args": [
            "root",
            "ignore"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "372-383",
          "snippet": "static void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase_ignore(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct rb_root *root,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the \"next\" vma being erased if\n\t * next->vm_start was reduced.\n\t */\n\tvalidate_mm_rb(root, ignore);\n\n\t__vma_rb_erase(vma, root);\n}"
  },
  {
    "function_name": "__vma_rb_erase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "455-463",
    "snippet": "static void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase_augmented",
          "args": [
            "&vma->vm_rb",
            "root",
            "&vma_gap_callbacks"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __vma_rb_erase(struct vm_area_struct *vma, struct rb_root *root)\n{\n\t/*\n\t * Note rb_erase_augmented is a fairly large inline function,\n\t * so make sure we instantiate it only once with our desired\n\t * augmented rbtree callbacks.\n\t */\n\trb_erase_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}"
  },
  {
    "function_name": "vma_rb_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "446-453",
    "snippet": "static inline void vma_rb_insert(struct vm_area_struct *vma,\n\t\t\t\t struct rb_root *root)\n{\n\t/* All rb_subtree_gap values must be consistent prior to insertion */\n\tvalidate_mm_rb(root, NULL);\n\n\trb_insert_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_augmented",
          "args": [
            "&vma->vm_rb",
            "root",
            "&vma_gap_callbacks"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_mm_rb",
          "args": [
            "root",
            "NULL"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mm_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "372-383",
          "snippet": "static void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void vma_rb_insert(struct vm_area_struct *vma,\n\t\t\t\t struct rb_root *root)\n{\n\t/* All rb_subtree_gap values must be consistent prior to insertion */\n\tvalidate_mm_rb(root, NULL);\n\n\trb_insert_augmented(&vma->vm_rb, root, &vma_gap_callbacks);\n}"
  },
  {
    "function_name": "vma_gap_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "437-444",
    "snippet": "static void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_gap_callbacks_propagate",
          "args": [
            "&vma->vm_rb",
            "NULL"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void vma_gap_update(struct vm_area_struct *vma)\n{\n\t/*\n\t * As it turns out, RB_DECLARE_CALLBACKS() already created a callback\n\t * function that does exacltly what we want.\n\t */\n\tvma_gap_callbacks_propagate(&vma->vm_rb, NULL);\n}"
  },
  {
    "function_name": "validate_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "385-423",
    "snippet": "static void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_MM",
          "args": [
            "bug",
            "mm"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"map_count %d rb %d\\n\"",
            "mm->map_count",
            "i"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "browse_rb",
          "args": [
            "mm"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "browse_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "324-370",
          "snippet": "static int browse_rb(struct mm_struct *mm)\n{\n\tstruct rb_root *root = &mm->mm_rb;\n\tint i = 0, j, bug = 0;\n\tstruct rb_node *nd, *pn = NULL;\n\tunsigned long prev = 0, pend = 0;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tif (vma->vm_start < prev) {\n\t\t\tpr_emerg(\"vm_start %lx < prev %lx\\n\",\n\t\t\t\t  vma->vm_start, prev);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start < pend) {\n\t\t\tpr_emerg(\"vm_start %lx < pend %lx\\n\",\n\t\t\t\t  vma->vm_start, pend);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start > vma->vm_end) {\n\t\t\tpr_emerg(\"vm_start %lx > vm_end %lx\\n\",\n\t\t\t\t  vma->vm_start, vma->vm_end);\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (vma->rb_subtree_gap != vma_compute_subtree_gap(vma)) {\n\t\t\tpr_emerg(\"free gap %lx, correct %lx\\n\",\n\t\t\t       vma->rb_subtree_gap,\n\t\t\t       vma_compute_subtree_gap(vma));\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_unlock(&mm->page_table_lock);\n\t\ti++;\n\t\tpn = nd;\n\t\tprev = vma->vm_start;\n\t\tpend = vma->vm_end;\n\t}\n\tj = 0;\n\tfor (nd = pn; nd; nd = rb_prev(nd))\n\t\tj++;\n\tif (i != j) {\n\t\tpr_emerg(\"backwards %d, forwards %d\\n\", j, i);\n\t\tbug = 1;\n\t}\n\treturn bug ? -1 : i;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int browse_rb(struct mm_struct *mm)\n{\n\tstruct rb_root *root = &mm->mm_rb;\n\tint i = 0, j, bug = 0;\n\tstruct rb_node *nd, *pn = NULL;\n\tunsigned long prev = 0, pend = 0;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tif (vma->vm_start < prev) {\n\t\t\tpr_emerg(\"vm_start %lx < prev %lx\\n\",\n\t\t\t\t  vma->vm_start, prev);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start < pend) {\n\t\t\tpr_emerg(\"vm_start %lx < pend %lx\\n\",\n\t\t\t\t  vma->vm_start, pend);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start > vma->vm_end) {\n\t\t\tpr_emerg(\"vm_start %lx > vm_end %lx\\n\",\n\t\t\t\t  vma->vm_start, vma->vm_end);\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (vma->rb_subtree_gap != vma_compute_subtree_gap(vma)) {\n\t\t\tpr_emerg(\"free gap %lx, correct %lx\\n\",\n\t\t\t       vma->rb_subtree_gap,\n\t\t\t       vma_compute_subtree_gap(vma));\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_unlock(&mm->page_table_lock);\n\t\ti++;\n\t\tpn = nd;\n\t\tprev = vma->vm_start;\n\t\tpend = vma->vm_end;\n\t}\n\tj = 0;\n\tfor (nd = pn; nd; nd = rb_prev(nd))\n\t\tj++;\n\tif (i != j) {\n\t\tpr_emerg(\"backwards %d, forwards %d\\n\", j, i);\n\t\tbug = 1;\n\t}\n\treturn bug ? -1 : i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"mm->highest_vm_end %lx, found %lx\\n\"",
            "mm->highest_vm_end",
            "highest_address"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"map_count %d vm_next %d\\n\"",
            "mm->map_count",
            "i"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_read",
          "args": [
            "anon_vma"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_verify",
          "args": [
            "avc"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "107-111",
          "snippet": "void anon_vma_interval_tree_verify(struct anon_vma_chain *node)\n{\n\tWARN_ON_ONCE(node->cached_vma_start != avc_start_pgoff(node));\n\tWARN_ON_ONCE(node->cached_vma_last != avc_last_pgoff(node));\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nvoid anon_vma_interval_tree_verify(struct anon_vma_chain *node)\n{\n\tWARN_ON_ONCE(node->cached_vma_start != avc_start_pgoff(node));\n\tWARN_ON_ONCE(node->cached_vma_last != avc_last_pgoff(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "avc",
            "&vma->anon_vma_chain",
            "same_vma"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_read",
          "args": [
            "anon_vma"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm(struct mm_struct *mm)\n{\n\tint bug = 0;\n\tint i = 0;\n\tunsigned long highest_address = 0;\n\tstruct vm_area_struct *vma = mm->mmap;\n\n\twhile (vma) {\n\t\tstruct anon_vma *anon_vma = vma->anon_vma;\n\t\tstruct anon_vma_chain *avc;\n\n\t\tif (anon_vma) {\n\t\t\tanon_vma_lock_read(anon_vma);\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tanon_vma_interval_tree_verify(avc);\n\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t}\n\n\t\thighest_address = vm_end_gap(vma);\n\t\tvma = vma->vm_next;\n\t\ti++;\n\t}\n\tif (i != mm->map_count) {\n\t\tpr_emerg(\"map_count %d vm_next %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tif (highest_address != mm->highest_vm_end) {\n\t\tpr_emerg(\"mm->highest_vm_end %lx, found %lx\\n\",\n\t\t\t  mm->highest_vm_end, highest_address);\n\t\tbug = 1;\n\t}\n\ti = browse_rb(mm);\n\tif (i != mm->map_count) {\n\t\tif (i != -1)\n\t\t\tpr_emerg(\"map_count %d rb %d\\n\", mm->map_count, i);\n\t\tbug = 1;\n\t}\n\tVM_BUG_ON_MM(bug, mm);\n}"
  },
  {
    "function_name": "validate_mm_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "372-383",
    "snippet": "static void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_VMA",
          "args": [
            "vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma)",
            "vma"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_compute_subtree_gap",
          "args": [
            "vma"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "vma_compute_subtree_gap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "290-321",
          "snippet": "static long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "nd",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "nd"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void validate_mm_rb(struct rb_root *root, struct vm_area_struct *ignore)\n{\n\tstruct rb_node *nd;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tVM_BUG_ON_VMA(vma != ignore &&\n\t\t\tvma->rb_subtree_gap != vma_compute_subtree_gap(vma),\n\t\t\tvma);\n\t}\n}"
  },
  {
    "function_name": "browse_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "324-370",
    "snippet": "static int browse_rb(struct mm_struct *mm)\n{\n\tstruct rb_root *root = &mm->mm_rb;\n\tint i = 0, j, bug = 0;\n\tstruct rb_node *nd, *pn = NULL;\n\tunsigned long prev = 0, pend = 0;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tif (vma->vm_start < prev) {\n\t\t\tpr_emerg(\"vm_start %lx < prev %lx\\n\",\n\t\t\t\t  vma->vm_start, prev);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start < pend) {\n\t\t\tpr_emerg(\"vm_start %lx < pend %lx\\n\",\n\t\t\t\t  vma->vm_start, pend);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start > vma->vm_end) {\n\t\t\tpr_emerg(\"vm_start %lx > vm_end %lx\\n\",\n\t\t\t\t  vma->vm_start, vma->vm_end);\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (vma->rb_subtree_gap != vma_compute_subtree_gap(vma)) {\n\t\t\tpr_emerg(\"free gap %lx, correct %lx\\n\",\n\t\t\t       vma->rb_subtree_gap,\n\t\t\t       vma_compute_subtree_gap(vma));\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_unlock(&mm->page_table_lock);\n\t\ti++;\n\t\tpn = nd;\n\t\tprev = vma->vm_start;\n\t\tpend = vma->vm_end;\n\t}\n\tj = 0;\n\tfor (nd = pn; nd; nd = rb_prev(nd))\n\t\tj++;\n\tif (i != j) {\n\t\tpr_emerg(\"backwards %d, forwards %d\\n\", j, i);\n\t\tbug = 1;\n\t}\n\treturn bug ? -1 : i;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"backwards %d, forwards %d\\n\"",
            "j",
            "i"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "nd"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"free gap %lx, correct %lx\\n\"",
            "vma->rb_subtree_gap",
            "vma_compute_subtree_gap(vma)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_compute_subtree_gap",
          "args": [
            "vma"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "vma_compute_subtree_gap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "290-321",
          "snippet": "static long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"vm_start %lx > vm_end %lx\\n\"",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"vm_start %lx < pend %lx\\n\"",
            "vma->vm_start",
            "pend"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"vm_start %lx < prev %lx\\n\"",
            "vma->vm_start",
            "prev"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "nd",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "nd"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int browse_rb(struct mm_struct *mm)\n{\n\tstruct rb_root *root = &mm->mm_rb;\n\tint i = 0, j, bug = 0;\n\tstruct rb_node *nd, *pn = NULL;\n\tunsigned long prev = 0, pend = 0;\n\n\tfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\n\t\tstruct vm_area_struct *vma;\n\t\tvma = rb_entry(nd, struct vm_area_struct, vm_rb);\n\t\tif (vma->vm_start < prev) {\n\t\t\tpr_emerg(\"vm_start %lx < prev %lx\\n\",\n\t\t\t\t  vma->vm_start, prev);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start < pend) {\n\t\t\tpr_emerg(\"vm_start %lx < pend %lx\\n\",\n\t\t\t\t  vma->vm_start, pend);\n\t\t\tbug = 1;\n\t\t}\n\t\tif (vma->vm_start > vma->vm_end) {\n\t\t\tpr_emerg(\"vm_start %lx > vm_end %lx\\n\",\n\t\t\t\t  vma->vm_start, vma->vm_end);\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_lock(&mm->page_table_lock);\n\t\tif (vma->rb_subtree_gap != vma_compute_subtree_gap(vma)) {\n\t\t\tpr_emerg(\"free gap %lx, correct %lx\\n\",\n\t\t\t       vma->rb_subtree_gap,\n\t\t\t       vma_compute_subtree_gap(vma));\n\t\t\tbug = 1;\n\t\t}\n\t\tspin_unlock(&mm->page_table_lock);\n\t\ti++;\n\t\tpn = nd;\n\t\tprev = vma->vm_start;\n\t\tpend = vma->vm_end;\n\t}\n\tj = 0;\n\tfor (nd = pn; nd; nd = rb_prev(nd))\n\t\tj++;\n\tif (i != j) {\n\t\tpr_emerg(\"backwards %d, forwards %d\\n\", j, i);\n\t\tbug = 1;\n\t}\n\treturn bug ? -1 : i;\n}"
  },
  {
    "function_name": "vma_compute_subtree_gap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "290-321",
    "snippet": "static long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "vma->vm_rb.rb_right",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "vma->vm_rb.rb_left",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_end_gap",
          "args": [
            "vma->vm_prev"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_start_gap",
          "args": [
            "vma"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}"
  },
  {
    "function_name": "remove_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "175-187",
    "snippet": "static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_area_free",
          "args": [
            "vma"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_put",
          "args": [
            "vma_policy(vma)"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "mpol_put_task_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "2345-2354",
          "snippet": "void mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "vma->vm_file"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->close",
          "args": [
            "vma"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct vm_area_struct *remove_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *next = vma->vm_next;\n\n\tmight_sleep();\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tvma->vm_ops->close(vma);\n\tif (vma->vm_file)\n\t\tfput(vma->vm_file);\n\tmpol_put(vma_policy(vma));\n\tvm_area_free(vma);\n\treturn next;\n}"
  },
  {
    "function_name": "unlink_file_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "160-170",
    "snippet": "void unlink_file_vma(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t\t__remove_shared_vm_struct(vma, file, mapping);\n\t\ti_mmap_unlock_write(mapping);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_shared_vm_struct",
          "args": [
            "vma",
            "file",
            "mapping"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_shared_vm_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "143-154",
          "snippet": "static void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid unlink_file_vma(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\n\tif (file) {\n\t\tstruct address_space *mapping = file->f_mapping;\n\t\ti_mmap_lock_write(mapping);\n\t\t__remove_shared_vm_struct(vma, file, mapping);\n\t\ti_mmap_unlock_write(mapping);\n\t}\n}"
  },
  {
    "function_name": "__remove_shared_vm_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "143-154",
    "snippet": "static void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_mmap_unlock",
          "args": [
            "mapping"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_remove",
          "args": [
            "vma",
            "&mapping->i_mmap"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "anon_vma_interval_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/interval_tree.c",
          "lines": "86-90",
          "snippet": "void anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}",
          "includes": [
            "#include <linux/interval_tree_generic.h>",
            "#include <linux/rmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interval_tree_generic.h>\n#include <linux/rmap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n\nvoid anon_vma_interval_tree_remove(struct anon_vma_chain *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\t__anon_vma_interval_tree_remove(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mmap_lock",
          "args": [
            "mapping"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_unmap_writable",
          "args": [
            "mapping"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&file_inode(file)->i_writecount"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __remove_shared_vm_struct(struct vm_area_struct *vma,\n\t\tstruct file *file, struct address_space *mapping)\n{\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tatomic_inc(&file_inode(file)->i_writecount);\n\tif (vma->vm_flags & VM_SHARED)\n\t\tmapping_unmap_writable(mapping);\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_interval_tree_remove(vma, &mapping->i_mmap);\n\tflush_dcache_mmap_unlock(mapping);\n}"
  },
  {
    "function_name": "vma_set_page_prot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "126-138",
    "snippet": "void vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "vma->vm_page_prot",
            "vm_page_prot"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_pgprot_modify",
          "args": [
            "vm_page_prot",
            "vm_flags"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "vm_pgprot_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "120-123",
          "snippet": "static pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_wants_writenotify",
          "args": [
            "vma",
            "vm_page_prot"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "vma_wants_writenotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1653-1683",
          "snippet": "int vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}"
  },
  {
    "function_name": "vm_pgprot_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "120-123",
    "snippet": "static pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pgprot_modify",
          "args": [
            "oldprot",
            "vm_get_page_prot(vm_flags)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "vm_pgprot_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "120-123",
          "snippet": "static pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "vm_get_page_prot",
          "args": [
            "vm_flags"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "vm_get_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "110-117",
          "snippet": "pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic pgprot_t vm_pgprot_modify(pgprot_t oldprot, unsigned long vm_flags)\n{\n\treturn pgprot_modify(oldprot, vm_get_page_prot(vm_flags));\n}"
  },
  {
    "function_name": "vm_get_page_prot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "110-117",
    "snippet": "pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "pgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_filter_pgprot",
          "args": [
            "ret"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "arch_filter_pgprot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "104-107",
          "snippet": "static inline pgprot_t arch_filter_pgprot(pgprot_t prot)\n{\n\treturn prot;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline pgprot_t arch_filter_pgprot(pgprot_t prot)\n{\n\treturn prot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pgprot",
          "args": [
            "pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "arch_vm_get_page_prot(vm_flags)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_vm_get_page_prot",
          "args": [
            "vm_flags"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}"
  },
  {
    "function_name": "arch_filter_pgprot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "104-107",
    "snippet": "static inline pgprot_t arch_filter_pgprot(pgprot_t prot)\n{\n\treturn prot;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline pgprot_t arch_filter_pgprot(pgprot_t prot)\n{\n\treturn prot;\n}"
  },
  {
    "function_name": "brk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "191-288",
    "snippet": "SYSCALL_DEFINE1(brk, unsigned long, brk)\n{\n\tunsigned long retval;\n\tunsigned long newbrk, oldbrk, origbrk;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *next;\n\tunsigned long min_brk;\n\tbool populate;\n\tbool downgraded = false;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\torigbrk = mm->brk;\n\n#ifdef CONFIG_COMPAT_BRK\n\t/*\n\t * CONFIG_COMPAT_BRK can still be overridden by setting\n\t * randomize_va_space to 2, which will still cause mm->start_brk\n\t * to be arbitrarily shifted\n\t */\n\tif (current->brk_randomized)\n\t\tmin_brk = mm->start_brk;\n\telse\n\t\tmin_brk = mm->end_data;\n#else\n\tmin_brk = mm->start_brk;\n#endif\n\tif (brk < min_brk)\n\t\tgoto out;\n\n\t/*\n\t * Check against rlimit here. If this check is done later after the test\n\t * of oldbrk with newbrk then it can escape the test and let the data\n\t * segment grow beyond its set limit the in case where the limit is\n\t * not page aligned -Ram Gupta\n\t */\n\tif (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm->start_brk,\n\t\t\t      mm->end_data, mm->start_data))\n\t\tgoto out;\n\n\tnewbrk = PAGE_ALIGN(brk);\n\toldbrk = PAGE_ALIGN(mm->brk);\n\tif (oldbrk == newbrk) {\n\t\tmm->brk = brk;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Always allow shrinking brk.\n\t * __do_munmap() may downgrade mmap_sem to read.\n\t */\n\tif (brk <= mm->brk) {\n\t\tint ret;\n\n\t\t/*\n\t\t * mm->brk must to be protected by write mmap_sem so update it\n\t\t * before downgrading mmap_sem. When __do_munmap() fails,\n\t\t * mm->brk will be restored from origbrk.\n\t\t */\n\t\tmm->brk = brk;\n\t\tret = __do_munmap(mm, newbrk, oldbrk-newbrk, &uf, true);\n\t\tif (ret < 0) {\n\t\t\tmm->brk = origbrk;\n\t\t\tgoto out;\n\t\t} else if (ret == 1) {\n\t\t\tdowngraded = true;\n\t\t}\n\t\tgoto success;\n\t}\n\n\t/* Check against existing mmap mappings. */\n\tnext = find_vma(mm, oldbrk);\n\tif (next && newbrk + PAGE_SIZE > vm_start_gap(next))\n\t\tgoto out;\n\n\t/* Ok, looks good - let it rip. */\n\tif (do_brk_flags(oldbrk, newbrk-oldbrk, 0, &uf) < 0)\n\t\tgoto out;\n\tmm->brk = brk;\n\nsuccess:\n\tpopulate = newbrk > oldbrk && (mm->def_flags & VM_LOCKED) != 0;\n\tif (downgraded)\n\t\tup_read(&mm->mmap_sem);\n\telse\n\t\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate)\n\t\tmm_populate(oldbrk, newbrk - oldbrk);\n\treturn brk;\n\nout:\n\tretval = origbrk;\n\tup_write(&mm->mmap_sem);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,\n\t\tstruct list_head *uf);\n\nSYSCALL_DEFINE1(brk, unsigned long, brk)\n{\n\tunsigned long retval;\n\tunsigned long newbrk, oldbrk, origbrk;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *next;\n\tunsigned long min_brk;\n\tbool populate;\n\tbool downgraded = false;\n\tLIST_HEAD(uf);\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\torigbrk = mm->brk;\n\n#ifdef CONFIG_COMPAT_BRK\n\t/*\n\t * CONFIG_COMPAT_BRK can still be overridden by setting\n\t * randomize_va_space to 2, which will still cause mm->start_brk\n\t * to be arbitrarily shifted\n\t */\n\tif (current->brk_randomized)\n\t\tmin_brk = mm->start_brk;\n\telse\n\t\tmin_brk = mm->end_data;\n#else\n\tmin_brk = mm->start_brk;\n#endif\n\tif (brk < min_brk)\n\t\tgoto out;\n\n\t/*\n\t * Check against rlimit here. If this check is done later after the test\n\t * of oldbrk with newbrk then it can escape the test and let the data\n\t * segment grow beyond its set limit the in case where the limit is\n\t * not page aligned -Ram Gupta\n\t */\n\tif (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm->start_brk,\n\t\t\t      mm->end_data, mm->start_data))\n\t\tgoto out;\n\n\tnewbrk = PAGE_ALIGN(brk);\n\toldbrk = PAGE_ALIGN(mm->brk);\n\tif (oldbrk == newbrk) {\n\t\tmm->brk = brk;\n\t\tgoto success;\n\t}\n\n\t/*\n\t * Always allow shrinking brk.\n\t * __do_munmap() may downgrade mmap_sem to read.\n\t */\n\tif (brk <= mm->brk) {\n\t\tint ret;\n\n\t\t/*\n\t\t * mm->brk must to be protected by write mmap_sem so update it\n\t\t * before downgrading mmap_sem. When __do_munmap() fails,\n\t\t * mm->brk will be restored from origbrk.\n\t\t */\n\t\tmm->brk = brk;\n\t\tret = __do_munmap(mm, newbrk, oldbrk-newbrk, &uf, true);\n\t\tif (ret < 0) {\n\t\t\tmm->brk = origbrk;\n\t\t\tgoto out;\n\t\t} else if (ret == 1) {\n\t\t\tdowngraded = true;\n\t\t}\n\t\tgoto success;\n\t}\n\n\t/* Check against existing mmap mappings. */\n\tnext = find_vma(mm, oldbrk);\n\tif (next && newbrk + PAGE_SIZE > vm_start_gap(next))\n\t\tgoto out;\n\n\t/* Ok, looks good - let it rip. */\n\tif (do_brk_flags(oldbrk, newbrk-oldbrk, 0, &uf) < 0)\n\t\tgoto out;\n\tmm->brk = brk;\n\nsuccess:\n\tpopulate = newbrk > oldbrk && (mm->def_flags & VM_LOCKED) != 0;\n\tif (downgraded)\n\t\tup_read(&mm->mmap_sem);\n\telse\n\t\tup_write(&mm->mmap_sem);\n\tuserfaultfd_unmap_complete(mm, &uf);\n\tif (populate)\n\t\tmm_populate(oldbrk, newbrk - oldbrk);\n\treturn brk;\n\nout:\n\tretval = origbrk;\n\tup_write(&mm->mmap_sem);\n\treturn retval;\n}"
  },
  {
    "function_name": "mmap_pgoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1616-1621",
    "snippet": "SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags,\n\t\tunsigned long, fd, unsigned long, pgoff)\n{\n\treturn ksys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags,\n\t\tunsigned long, fd, unsigned long, pgoff)\n{\n\treturn ksys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n}"
  },
  {
    "function_name": "old_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "1633-1644",
    "snippet": "SYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)\n{\n\tstruct mmap_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\tif (offset_in_page(a.offset))\n\t\treturn -EINVAL;\n\n\treturn ksys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n\t\t\t       a.offset >> PAGE_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)\n{\n\tstruct mmap_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\tif (offset_in_page(a.offset))\n\t\treturn -EINVAL;\n\n\treturn ksys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n\t\t\t       a.offset >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "munmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2859-2863",
    "snippet": "SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)\n{\n\tprofile_munmap(addr);\n\treturn __vm_munmap(addr, len, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)\n{\n\tprofile_munmap(addr);\n\treturn __vm_munmap(addr, len, true);\n}"
  },
  {
    "function_name": "remap_file_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
    "lines": "2869-2963",
    "snippet": "SYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,\n\t\tunsigned long, prot, unsigned long, pgoff, unsigned long, flags)\n{\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long populate = 0;\n\tunsigned long ret = -EINVAL;\n\tstruct file *file;\n\n\tpr_warn_once(\"%s (%d) uses deprecated remap_file_pages() syscall. See Documentation/vm/remap_file_pages.rst.\\n\",\n\t\t     current->comm, current->pid);\n\n\tif (prot)\n\t\treturn ret;\n\tstart = start & PAGE_MASK;\n\tsize = size & PAGE_MASK;\n\n\tif (start + size <= start)\n\t\treturn ret;\n\n\t/* Does pgoff wrap? */\n\tif (pgoff + (size >> PAGE_SHIFT) < pgoff)\n\t\treturn ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvma = find_vma(mm, start);\n\n\tif (!vma || !(vma->vm_flags & VM_SHARED))\n\t\tgoto out;\n\n\tif (start < vma->vm_start)\n\t\tgoto out;\n\n\tif (start + size > vma->vm_end) {\n\t\tstruct vm_area_struct *next;\n\n\t\tfor (next = vma->vm_next; next; next = next->vm_next) {\n\t\t\t/* hole between vmas ? */\n\t\t\tif (next->vm_start != next->vm_prev->vm_end)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_file != vma->vm_file)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_flags != vma->vm_flags)\n\t\t\t\tgoto out;\n\n\t\t\tif (start + size <= next->vm_end)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!next)\n\t\t\tgoto out;\n\t}\n\n\tprot |= vma->vm_flags & VM_READ ? PROT_READ : 0;\n\tprot |= vma->vm_flags & VM_WRITE ? PROT_WRITE : 0;\n\tprot |= vma->vm_flags & VM_EXEC ? PROT_EXEC : 0;\n\n\tflags &= MAP_NONBLOCK;\n\tflags |= MAP_SHARED | MAP_FIXED | MAP_POPULATE;\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tstruct vm_area_struct *tmp;\n\t\tflags |= MAP_LOCKED;\n\n\t\t/* drop PG_Mlocked flag for over-mapped range */\n\t\tfor (tmp = vma; tmp->vm_start >= start + size;\n\t\t\t\ttmp = tmp->vm_next) {\n\t\t\t/*\n\t\t\t * Split pmd and munlock page on the border\n\t\t\t * of the range.\n\t\t\t */\n\t\t\tvma_adjust_trans_huge(tmp, start, start + size, 0);\n\n\t\t\tmunlock_vma_pages_range(tmp,\n\t\t\t\t\tmax(tmp->vm_start, start),\n\t\t\t\t\tmin(tmp->vm_end, start + size));\n\t\t}\n\t}\n\n\tfile = get_file(vma->vm_file);\n\tret = do_mmap_pgoff(vma->vm_file, start, size,\n\t\t\tprot, flags, pgoff, &populate, NULL);\n\tfput(file);\nout:\n\tup_write(&mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(ret, populate);\n\tif (!IS_ERR_VALUE(ret))\n\t\tret = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/mmu_context.h>",
      "#include <asm/tlb.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/oom.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/printk.h>",
      "#include <linux/memory.h>",
      "#include <linux/notifier.h>",
      "#include <linux/rbtree_augmented.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/audit.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/mmdebug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/profile.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/personality.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/init.h>",
      "#include <linux/capability.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,\n\t\tunsigned long, prot, unsigned long, pgoff, unsigned long, flags)\n{\n\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long populate = 0;\n\tunsigned long ret = -EINVAL;\n\tstruct file *file;\n\n\tpr_warn_once(\"%s (%d) uses deprecated remap_file_pages() syscall. See Documentation/vm/remap_file_pages.rst.\\n\",\n\t\t     current->comm, current->pid);\n\n\tif (prot)\n\t\treturn ret;\n\tstart = start & PAGE_MASK;\n\tsize = size & PAGE_MASK;\n\n\tif (start + size <= start)\n\t\treturn ret;\n\n\t/* Does pgoff wrap? */\n\tif (pgoff + (size >> PAGE_SHIFT) < pgoff)\n\t\treturn ret;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvma = find_vma(mm, start);\n\n\tif (!vma || !(vma->vm_flags & VM_SHARED))\n\t\tgoto out;\n\n\tif (start < vma->vm_start)\n\t\tgoto out;\n\n\tif (start + size > vma->vm_end) {\n\t\tstruct vm_area_struct *next;\n\n\t\tfor (next = vma->vm_next; next; next = next->vm_next) {\n\t\t\t/* hole between vmas ? */\n\t\t\tif (next->vm_start != next->vm_prev->vm_end)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_file != vma->vm_file)\n\t\t\t\tgoto out;\n\n\t\t\tif (next->vm_flags != vma->vm_flags)\n\t\t\t\tgoto out;\n\n\t\t\tif (start + size <= next->vm_end)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!next)\n\t\t\tgoto out;\n\t}\n\n\tprot |= vma->vm_flags & VM_READ ? PROT_READ : 0;\n\tprot |= vma->vm_flags & VM_WRITE ? PROT_WRITE : 0;\n\tprot |= vma->vm_flags & VM_EXEC ? PROT_EXEC : 0;\n\n\tflags &= MAP_NONBLOCK;\n\tflags |= MAP_SHARED | MAP_FIXED | MAP_POPULATE;\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tstruct vm_area_struct *tmp;\n\t\tflags |= MAP_LOCKED;\n\n\t\t/* drop PG_Mlocked flag for over-mapped range */\n\t\tfor (tmp = vma; tmp->vm_start >= start + size;\n\t\t\t\ttmp = tmp->vm_next) {\n\t\t\t/*\n\t\t\t * Split pmd and munlock page on the border\n\t\t\t * of the range.\n\t\t\t */\n\t\t\tvma_adjust_trans_huge(tmp, start, start + size, 0);\n\n\t\t\tmunlock_vma_pages_range(tmp,\n\t\t\t\t\tmax(tmp->vm_start, start),\n\t\t\t\t\tmin(tmp->vm_end, start + size));\n\t\t}\n\t}\n\n\tfile = get_file(vma->vm_file);\n\tret = do_mmap_pgoff(vma->vm_file, start, size,\n\t\t\tprot, flags, pgoff, &populate, NULL);\n\tfput(file);\nout:\n\tup_write(&mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(ret, populate);\n\tif (!IS_ERR_VALUE(ret))\n\t\tret = 0;\n\treturn ret;\n}"
  }
]