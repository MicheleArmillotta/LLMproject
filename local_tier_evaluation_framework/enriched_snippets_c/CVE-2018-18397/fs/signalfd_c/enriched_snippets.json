[
  {
    "function_name": "do_compat_signalfd4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "334-345",
    "snippet": "static long do_compat_signalfd4(int ufd,\n\t\t\tconst compat_sigset_t __user *user_mask,\n\t\t\tcompat_size_t sigsetsize, int flags)\n{\n\tsigset_t mask;\n\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\tif (get_compat_sigset(&mask, user_mask))\n\t\treturn -EFAULT;\n\treturn do_signalfd4(ufd, &mask, flags);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_signalfd4",
          "args": [
            "ufd",
            "&mask",
            "flags"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "do_signalfd4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
          "lines": "262-309",
          "snippet": "static int do_signalfd4(int ufd, sigset_t *mask, int flags)\n{\n\tstruct signalfd_ctx *ctx;\n\n\t/* Check the SFD_* constants for consistency.  */\n\tBUILD_BUG_ON(SFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(SFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tsigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(mask);\n\n\tif (ufd == -1) {\n\t\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctx->sigmask = *mask;\n\n\t\t/*\n\t\t * When we call this, the initialization must be complete, since\n\t\t * anon_inode_getfd() will install the fd.\n\t\t */\n\t\tufd = anon_inode_getfd(\"[signalfd]\", &signalfd_fops, ctx,\n\t\t\t\t       O_RDWR | (flags & (O_CLOEXEC | O_NONBLOCK)));\n\t\tif (ufd < 0)\n\t\t\tkfree(ctx);\n\t} else {\n\t\tstruct fd f = fdget(ufd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tctx = f.file->private_data;\n\t\tif (f.file->f_op != &signalfd_fops) {\n\t\t\tfdput(f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tctx->sigmask = *mask;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\twake_up(&current->sighand->signalfd_wqh);\n\t\tfdput(f);\n\t}\n\n\treturn ufd;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/list.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations signalfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= signalfd_show_fdinfo,\n#endif\n\t.release\t= signalfd_release,\n\t.poll\t\t= signalfd_poll,\n\t.read\t\t= signalfd_read,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations signalfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= signalfd_show_fdinfo,\n#endif\n\t.release\t= signalfd_release,\n\t.poll\t\t= signalfd_poll,\n\t.read\t\t= signalfd_read,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int do_signalfd4(int ufd, sigset_t *mask, int flags)\n{\n\tstruct signalfd_ctx *ctx;\n\n\t/* Check the SFD_* constants for consistency.  */\n\tBUILD_BUG_ON(SFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(SFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tsigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(mask);\n\n\tif (ufd == -1) {\n\t\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctx->sigmask = *mask;\n\n\t\t/*\n\t\t * When we call this, the initialization must be complete, since\n\t\t * anon_inode_getfd() will install the fd.\n\t\t */\n\t\tufd = anon_inode_getfd(\"[signalfd]\", &signalfd_fops, ctx,\n\t\t\t\t       O_RDWR | (flags & (O_CLOEXEC | O_NONBLOCK)));\n\t\tif (ufd < 0)\n\t\t\tkfree(ctx);\n\t} else {\n\t\tstruct fd f = fdget(ufd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tctx = f.file->private_data;\n\t\tif (f.file->f_op != &signalfd_fops) {\n\t\t\tfdput(f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tctx->sigmask = *mask;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\twake_up(&current->sighand->signalfd_wqh);\n\t\tfdput(f);\n\t}\n\n\treturn ufd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_compat_sigset",
          "args": [
            "&mask",
            "user_mask"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic long do_compat_signalfd4(int ufd,\n\t\t\tconst compat_sigset_t __user *user_mask,\n\t\t\tcompat_size_t sigsetsize, int flags)\n{\n\tsigset_t mask;\n\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\tif (get_compat_sigset(&mask, user_mask))\n\t\treturn -EFAULT;\n\treturn do_signalfd4(ufd, &mask, flags);\n}"
  },
  {
    "function_name": "do_signalfd4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "262-309",
    "snippet": "static int do_signalfd4(int ufd, sigset_t *mask, int flags)\n{\n\tstruct signalfd_ctx *ctx;\n\n\t/* Check the SFD_* constants for consistency.  */\n\tBUILD_BUG_ON(SFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(SFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tsigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(mask);\n\n\tif (ufd == -1) {\n\t\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctx->sigmask = *mask;\n\n\t\t/*\n\t\t * When we call this, the initialization must be complete, since\n\t\t * anon_inode_getfd() will install the fd.\n\t\t */\n\t\tufd = anon_inode_getfd(\"[signalfd]\", &signalfd_fops, ctx,\n\t\t\t\t       O_RDWR | (flags & (O_CLOEXEC | O_NONBLOCK)));\n\t\tif (ufd < 0)\n\t\t\tkfree(ctx);\n\t} else {\n\t\tstruct fd f = fdget(ufd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tctx = f.file->private_data;\n\t\tif (f.file->f_op != &signalfd_fops) {\n\t\t\tfdput(f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tctx->sigmask = *mask;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\twake_up(&current->sighand->signalfd_wqh);\n\t\tfdput(f);\n\t}\n\n\treturn ufd;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations signalfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= signalfd_show_fdinfo,\n#endif\n\t.release\t= signalfd_release,\n\t.poll\t\t= signalfd_poll,\n\t.read\t\t= signalfd_read,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&current->sighand->signalfd_wqh"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"[signalfd]\"",
            "&signalfd_fops",
            "ctx",
            "O_RDWR | (flags & (O_CLOEXEC | O_NONBLOCK))"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "anon_inode_getfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
          "lines": "121-144",
          "snippet": "int anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nint anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ctx)",
            "GFP_KERNEL"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signotset",
          "args": [
            "mask"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "mask",
            "sigmask(SIGKILL) | sigmask(SIGSTOP)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "SFD_NONBLOCK != O_NONBLOCK"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "SFD_CLOEXEC != O_CLOEXEC"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic const struct file_operations signalfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= signalfd_show_fdinfo,\n#endif\n\t.release\t= signalfd_release,\n\t.poll\t\t= signalfd_poll,\n\t.read\t\t= signalfd_read,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int do_signalfd4(int ufd, sigset_t *mask, int flags)\n{\n\tstruct signalfd_ctx *ctx;\n\n\t/* Check the SFD_* constants for consistency.  */\n\tBUILD_BUG_ON(SFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(SFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(SFD_CLOEXEC | SFD_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tsigdelsetmask(mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(mask);\n\n\tif (ufd == -1) {\n\t\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\t\tif (!ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctx->sigmask = *mask;\n\n\t\t/*\n\t\t * When we call this, the initialization must be complete, since\n\t\t * anon_inode_getfd() will install the fd.\n\t\t */\n\t\tufd = anon_inode_getfd(\"[signalfd]\", &signalfd_fops, ctx,\n\t\t\t\t       O_RDWR | (flags & (O_CLOEXEC | O_NONBLOCK)));\n\t\tif (ufd < 0)\n\t\t\tkfree(ctx);\n\t} else {\n\t\tstruct fd f = fdget(ufd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tctx = f.file->private_data;\n\t\tif (f.file->f_op != &signalfd_fops) {\n\t\t\tfdput(f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tctx->sigmask = *mask;\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\twake_up(&current->sighand->signalfd_wqh);\n\t\tfdput(f);\n\t}\n\n\treturn ufd;\n}"
  },
  {
    "function_name": "signalfd_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "241-249",
    "snippet": "static void signalfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct signalfd_ctx *ctx = f->private_data;\n\tsigset_t sigmask;\n\n\tsigmask = ctx->sigmask;\n\tsignotset(&sigmask);\n\trender_sigset_t(m, \"sigmask:\\t\", &sigmask);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "render_sigset_t",
          "args": [
            "m",
            "\"sigmask:\\t\"",
            "&sigmask"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "render_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc/array.c",
          "lines": "229-249",
          "snippet": "void render_sigset_t(struct seq_file *m, const char *header,\n\t\t\t\tsigset_t *set)\n{\n\tint i;\n\n\tseq_puts(m, header);\n\n\ti = _NSIG;\n\tdo {\n\t\tint x = 0;\n\n\t\ti -= 4;\n\t\tif (sigismember(set, i+1)) x |= 1;\n\t\tif (sigismember(set, i+2)) x |= 2;\n\t\tif (sigismember(set, i+3)) x |= 4;\n\t\tif (sigismember(set, i+4)) x |= 8;\n\t\tseq_putc(m, hex_asc[x]);\n\t} while (i >= 4);\n\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/processor.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/prctl.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/times.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ioport.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/string.h>",
            "#include <linux/tty.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/processor.h>\n#include <asm/pgtable.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/string_helpers.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/prctl.h>\n#include <linux/pid_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/delayacct.h>\n#include <linux/rcupdate.h>\n#include <linux/cpuset.h>\n#include <linux/times.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/highmem.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/mman.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/kernel_stat.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nvoid render_sigset_t(struct seq_file *m, const char *header,\n\t\t\t\tsigset_t *set)\n{\n\tint i;\n\n\tseq_puts(m, header);\n\n\ti = _NSIG;\n\tdo {\n\t\tint x = 0;\n\n\t\ti -= 4;\n\t\tif (sigismember(set, i+1)) x |= 1;\n\t\tif (sigismember(set, i+2)) x |= 2;\n\t\tif (sigismember(set, i+3)) x |= 4;\n\t\tif (sigismember(set, i+4)) x |= 8;\n\t\tseq_putc(m, hex_asc[x]);\n\t} while (i >= 4);\n\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "signotset",
          "args": [
            "&sigmask"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic void signalfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct signalfd_ctx *ctx = f->private_data;\n\tsigset_t sigmask;\n\n\tsigmask = ctx->sigmask;\n\tsignotset(&sigmask);\n\trender_sigset_t(m, \"sigmask:\\t\", &sigmask);\n}"
  },
  {
    "function_name": "signalfd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "211-238",
    "snippet": "static ssize_t signalfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\tstruct signalfd_siginfo __user *siginfo;\n\tint nonblock = file->f_flags & O_NONBLOCK;\n\tssize_t ret, total = 0;\n\tkernel_siginfo_t info;\n\n\tcount /= sizeof(struct signalfd_siginfo);\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tsiginfo = (struct signalfd_siginfo __user *) buf;\n\tdo {\n\t\tret = signalfd_dequeue(ctx, &info, nonblock);\n\t\tif (unlikely(ret <= 0))\n\t\t\tbreak;\n\t\tret = signalfd_copyinfo(siginfo, &info);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tsiginfo++;\n\t\ttotal += ret;\n\t\tnonblock = 1;\n\t} while (--count);\n\n\treturn total ? total: ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signalfd_copyinfo",
          "args": [
            "siginfo",
            "&info"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "signalfd_copyinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
          "lines": "81-164",
          "snippet": "static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     kernel_siginfo_t const *kinfo)\n{\n\tstruct signalfd_siginfo new;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\tmemset(&new, 0, sizeof(new));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\tnew.ssi_signo = kinfo->si_signo;\n\tnew.ssi_errno = kinfo->si_errno;\n\tnew.ssi_code  = kinfo->si_code;\n\tswitch (siginfo_layout(kinfo->si_signo, kinfo->si_code)) {\n\tcase SIL_KILL:\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tnew.ssi_tid = kinfo->si_tid;\n\t\tnew.ssi_overrun = kinfo->si_overrun;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tnew.ssi_band = kinfo->si_band;\n\t\tnew.ssi_fd   = kinfo->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\t\t/*\n\t\t * Fall through to the SIL_FAULT case.  Both SIL_FAULT_BNDERR\n\t\t * and SIL_FAULT_PKUERR are only generated by faults that\n\t\t * deliver them synchronously to userspace.  In case someone\n\t\t * injects one of these signals and signalfd catches it treat\n\t\t * it as SIL_FAULT.\n\t\t */\n\tcase SIL_FAULT:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tnew.ssi_addr_lsb = (short) kinfo->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tnew.ssi_pid    = kinfo->si_pid;\n\t\tnew.ssi_uid    = kinfo->si_uid;\n\t\tnew.ssi_status = kinfo->si_status;\n\t\tnew.ssi_utime  = kinfo->si_utime;\n\t\tnew.ssi_stime  = kinfo->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tnew.ssi_call_addr = (long) kinfo->si_call_addr;\n\t\tnew.ssi_syscall   = kinfo->si_syscall;\n\t\tnew.ssi_arch      = kinfo->si_arch;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(uinfo, &new, sizeof(struct signalfd_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(*uinfo);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/list.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     kernel_siginfo_t const *kinfo)\n{\n\tstruct signalfd_siginfo new;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\tmemset(&new, 0, sizeof(new));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\tnew.ssi_signo = kinfo->si_signo;\n\tnew.ssi_errno = kinfo->si_errno;\n\tnew.ssi_code  = kinfo->si_code;\n\tswitch (siginfo_layout(kinfo->si_signo, kinfo->si_code)) {\n\tcase SIL_KILL:\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tnew.ssi_tid = kinfo->si_tid;\n\t\tnew.ssi_overrun = kinfo->si_overrun;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tnew.ssi_band = kinfo->si_band;\n\t\tnew.ssi_fd   = kinfo->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\t\t/*\n\t\t * Fall through to the SIL_FAULT case.  Both SIL_FAULT_BNDERR\n\t\t * and SIL_FAULT_PKUERR are only generated by faults that\n\t\t * deliver them synchronously to userspace.  In case someone\n\t\t * injects one of these signals and signalfd catches it treat\n\t\t * it as SIL_FAULT.\n\t\t */\n\tcase SIL_FAULT:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tnew.ssi_addr_lsb = (short) kinfo->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tnew.ssi_pid    = kinfo->si_pid;\n\t\tnew.ssi_uid    = kinfo->si_uid;\n\t\tnew.ssi_status = kinfo->si_status;\n\t\tnew.ssi_utime  = kinfo->si_utime;\n\t\tnew.ssi_stime  = kinfo->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tnew.ssi_call_addr = (long) kinfo->si_call_addr;\n\t\tnew.ssi_syscall   = kinfo->si_syscall;\n\t\tnew.ssi_arch      = kinfo->si_arch;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(uinfo, &new, sizeof(struct signalfd_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(*uinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd_dequeue",
          "args": [
            "ctx",
            "&info",
            "nonblock"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "signalfd_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
          "lines": "166-204",
          "snippet": "static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/list.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t signalfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\tstruct signalfd_siginfo __user *siginfo;\n\tint nonblock = file->f_flags & O_NONBLOCK;\n\tssize_t ret, total = 0;\n\tkernel_siginfo_t info;\n\n\tcount /= sizeof(struct signalfd_siginfo);\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tsiginfo = (struct signalfd_siginfo __user *) buf;\n\tdo {\n\t\tret = signalfd_dequeue(ctx, &info, nonblock);\n\t\tif (unlikely(ret <= 0))\n\t\t\tbreak;\n\t\tret = signalfd_copyinfo(siginfo, &info);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tsiginfo++;\n\t\ttotal += ret;\n\t\tnonblock = 1;\n\t} while (--count);\n\n\treturn total ? total: ret;\n}"
  },
  {
    "function_name": "signalfd_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "166-204",
    "snippet": "static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&current->sighand->signalfd_wqh",
            "&wait"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "current",
            "&ctx->sigmask",
            "info"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&current->sighand->signalfd_wqh",
            "&wait"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "current",
            "&ctx->sigmask",
            "info"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, kernel_siginfo_t *info,\n\t\t\t\tint nonblock)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tret = dequeue_signal(current, &ctx->sigmask, info);\n\tswitch (ret) {\n\tcase 0:\n\t\tif (!nonblock)\n\t\t\tbreak;\n\t\tret = -EAGAIN;\n\tdefault:\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn ret;\n\t}\n\n\tadd_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tret = dequeue_signal(current, &ctx->sigmask, info);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tschedule();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tremove_wait_queue(&current->sighand->signalfd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "signalfd_copyinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "81-164",
    "snippet": "static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     kernel_siginfo_t const *kinfo)\n{\n\tstruct signalfd_siginfo new;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\tmemset(&new, 0, sizeof(new));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\tnew.ssi_signo = kinfo->si_signo;\n\tnew.ssi_errno = kinfo->si_errno;\n\tnew.ssi_code  = kinfo->si_code;\n\tswitch (siginfo_layout(kinfo->si_signo, kinfo->si_code)) {\n\tcase SIL_KILL:\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tnew.ssi_tid = kinfo->si_tid;\n\t\tnew.ssi_overrun = kinfo->si_overrun;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tnew.ssi_band = kinfo->si_band;\n\t\tnew.ssi_fd   = kinfo->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\t\t/*\n\t\t * Fall through to the SIL_FAULT case.  Both SIL_FAULT_BNDERR\n\t\t * and SIL_FAULT_PKUERR are only generated by faults that\n\t\t * deliver them synchronously to userspace.  In case someone\n\t\t * injects one of these signals and signalfd catches it treat\n\t\t * it as SIL_FAULT.\n\t\t */\n\tcase SIL_FAULT:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tnew.ssi_addr_lsb = (short) kinfo->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tnew.ssi_pid    = kinfo->si_pid;\n\t\tnew.ssi_uid    = kinfo->si_uid;\n\t\tnew.ssi_status = kinfo->si_status;\n\t\tnew.ssi_utime  = kinfo->si_utime;\n\t\tnew.ssi_stime  = kinfo->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tnew.ssi_call_addr = (long) kinfo->si_call_addr;\n\t\tnew.ssi_syscall   = kinfo->si_syscall;\n\t\tnew.ssi_arch      = kinfo->si_arch;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(uinfo, &new, sizeof(struct signalfd_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(*uinfo);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&new",
            "sizeof(struct signalfd_siginfo)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_layout",
          "args": [
            "kinfo->si_signo",
            "kinfo->si_code"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new",
            "0",
            "sizeof(new)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct signalfd_siginfo) != 128"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,\n\t\t\t     kernel_siginfo_t const *kinfo)\n{\n\tstruct signalfd_siginfo new;\n\n\tBUILD_BUG_ON(sizeof(struct signalfd_siginfo) != 128);\n\n\t/*\n\t * Unused members should be zero ...\n\t */\n\tmemset(&new, 0, sizeof(new));\n\n\t/*\n\t * If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t */\n\tnew.ssi_signo = kinfo->si_signo;\n\tnew.ssi_errno = kinfo->si_errno;\n\tnew.ssi_code  = kinfo->si_code;\n\tswitch (siginfo_layout(kinfo->si_signo, kinfo->si_code)) {\n\tcase SIL_KILL:\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tnew.ssi_tid = kinfo->si_tid;\n\t\tnew.ssi_overrun = kinfo->si_overrun;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tnew.ssi_band = kinfo->si_band;\n\t\tnew.ssi_fd   = kinfo->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\t\t/*\n\t\t * Fall through to the SIL_FAULT case.  Both SIL_FAULT_BNDERR\n\t\t * and SIL_FAULT_PKUERR are only generated by faults that\n\t\t * deliver them synchronously to userspace.  In case someone\n\t\t * injects one of these signals and signalfd catches it treat\n\t\t * it as SIL_FAULT.\n\t\t */\n\tcase SIL_FAULT:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tnew.ssi_addr = (long) kinfo->si_addr;\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.ssi_trapno = kinfo->si_trapno;\n#endif\n\t\tnew.ssi_addr_lsb = (short) kinfo->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tnew.ssi_pid    = kinfo->si_pid;\n\t\tnew.ssi_uid    = kinfo->si_uid;\n\t\tnew.ssi_status = kinfo->si_status;\n\t\tnew.ssi_utime  = kinfo->si_utime;\n\t\tnew.ssi_stime  = kinfo->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\t/*\n\t\t * This case catches also the signals queued by sigqueue().\n\t\t */\n\t\tnew.ssi_pid = kinfo->si_pid;\n\t\tnew.ssi_uid = kinfo->si_uid;\n\t\tnew.ssi_ptr = (long) kinfo->si_ptr;\n\t\tnew.ssi_int = kinfo->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tnew.ssi_call_addr = (long) kinfo->si_call_addr;\n\t\tnew.ssi_syscall   = kinfo->si_syscall;\n\t\tnew.ssi_arch      = kinfo->si_arch;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(uinfo, &new, sizeof(struct signalfd_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn sizeof(*uinfo);\n}"
  },
  {
    "function_name": "signalfd_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "61-76",
    "snippet": "static __poll_t signalfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\t__poll_t events = 0;\n\n\tpoll_wait(file, &current->sighand->signalfd_wqh, wait);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (next_signal(&current->pending, &ctx->sigmask) ||\n\t    next_signal(&current->signal->shared_pending,\n\t\t\t&ctx->sigmask))\n\t\tevents |= EPOLLIN;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn events;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_signal",
          "args": [
            "&current->signal->shared_pending",
            "&ctx->sigmask"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_signal",
          "args": [
            "&current->pending",
            "&ctx->sigmask"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&current->sighand->signalfd_wqh",
            "wait"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic __poll_t signalfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct signalfd_ctx *ctx = file->private_data;\n\t__poll_t events = 0;\n\n\tpoll_wait(file, &current->sighand->signalfd_wqh, wait);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (next_signal(&current->pending, &ctx->sigmask) ||\n\t    next_signal(&current->signal->shared_pending,\n\t\t\t&ctx->sigmask))\n\t\tevents |= EPOLLIN;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn events;\n}"
  },
  {
    "function_name": "signalfd_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "55-59",
    "snippet": "static int signalfd_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file->private_data"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstatic int signalfd_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "signalfd_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "36-49",
    "snippet": "void signalfd_cleanup(struct sighand_struct *sighand)\n{\n\twait_queue_head_t *wqh = &sighand->signalfd_wqh;\n\t/*\n\t * The lockless check can race with remove_wait_queue() in progress,\n\t * but in this case its caller should run under rcu_read_lock() and\n\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU, we can safely return.\n\t */\n\tif (likely(!waitqueue_active(wqh)))\n\t\treturn;\n\n\t/* wait_queue_entry_t->func(POLLFREE) should do remove_wait_queue() */\n\twake_up_poll(wqh, EPOLLHUP | POLLFREE);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "wqh",
            "EPOLLHUP | POLLFREE"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!waitqueue_active(wqh)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "wqh"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid signalfd_cleanup(struct sighand_struct *sighand)\n{\n\twait_queue_head_t *wqh = &sighand->signalfd_wqh;\n\t/*\n\t * The lockless check can race with remove_wait_queue() in progress,\n\t * but in this case its caller should run under rcu_read_lock() and\n\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU, we can safely return.\n\t */\n\tif (likely(!waitqueue_active(wqh)))\n\t\treturn;\n\n\t/* wait_queue_entry_t->func(POLLFREE) should do remove_wait_queue() */\n\twake_up_poll(wqh, EPOLLHUP | POLLFREE);\n}"
  },
  {
    "function_name": "signalfd4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "311-320",
    "snippet": "SYSCALL_DEFINE4(signalfd4, int, ufd, sigset_t __user *, user_mask,\n\t\tsize_t, sizemask, int, flags)\n{\n\tsigset_t mask;\n\n\tif (sizemask != sizeof(sigset_t) ||\n\t    copy_from_user(&mask, user_mask, sizeof(mask)))\n\t\treturn -EINVAL;\n\treturn do_signalfd4(ufd, &mask, flags);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE4(signalfd4, int, ufd, sigset_t __user *, user_mask,\n\t\tsize_t, sizemask, int, flags)\n{\n\tsigset_t mask;\n\n\tif (sizemask != sizeof(sigset_t) ||\n\t    copy_from_user(&mask, user_mask, sizeof(mask)))\n\t\treturn -EINVAL;\n\treturn do_signalfd4(ufd, &mask, flags);\n}"
  },
  {
    "function_name": "signalfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "322-331",
    "snippet": "SYSCALL_DEFINE3(signalfd, int, ufd, sigset_t __user *, user_mask,\n\t\tsize_t, sizemask)\n{\n\tsigset_t mask;\n\n\tif (sizemask != sizeof(sigset_t) ||\n\t    copy_from_user(&mask, user_mask, sizeof(mask)))\n\t\treturn -EINVAL;\n\treturn do_signalfd4(ufd, &mask, 0);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE3(signalfd, int, ufd, sigset_t __user *, user_mask,\n\t\tsize_t, sizemask)\n{\n\tsigset_t mask;\n\n\tif (sizemask != sizeof(sigset_t) ||\n\t    copy_from_user(&mask, user_mask, sizeof(mask)))\n\t\treturn -EINVAL;\n\treturn do_signalfd4(ufd, &mask, 0);\n}"
  },
  {
    "function_name": "signalfd4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "347-353",
    "snippet": "SYSCALL_DEFINE4(signalfd4, int, ufd,\n\t\t     const compat_sigset_t __user *, user_mask,\n\t\t     compat_size_t, sigsetsize,\n\t\t     int, flags)\n{\n\treturn do_compat_signalfd4(ufd, user_mask, sigsetsize, flags);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE4(signalfd4, int, ufd,\n\t\t     const compat_sigset_t __user *, user_mask,\n\t\t     compat_size_t, sigsetsize,\n\t\t     int, flags)\n{\n\treturn do_compat_signalfd4(ufd, user_mask, sigsetsize, flags);\n}"
  },
  {
    "function_name": "signalfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/signalfd.c",
    "lines": "355-360",
    "snippet": "SYSCALL_DEFINE3(signalfd, int, ufd,\n\t\t     const compat_sigset_t __user *, user_mask,\n\t\t     compat_size_t, sigsetsize)\n{\n\treturn do_compat_signalfd4(ufd, user_mask, sigsetsize, 0);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/list.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/proc_fs.h>\n#include <linux/syscalls.h>\n#include <linux/signalfd.h>\n#include <linux/anon_inodes.h>\n#include <linux/list.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nSYSCALL_DEFINE3(signalfd, int, ufd,\n\t\t     const compat_sigset_t __user *, user_mask,\n\t\t     compat_size_t, sigsetsize)\n{\n\treturn do_compat_signalfd4(ufd, user_mask, sigsetsize, 0);\n}"
  }
]