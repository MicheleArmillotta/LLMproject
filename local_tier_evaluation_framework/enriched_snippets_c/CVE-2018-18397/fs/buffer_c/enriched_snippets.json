[
  {
    "function_name": "recalc_bh_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3345-3460",
    "snippet": "static void recalc_bh_state(void)\n{\n\tint i;\n\tint tot = 0;\n\n\tif (__this_cpu_inc_return(bh_accounting.ratelimit) - 1 < 4096)\n\t\treturn;\n\t__this_cpu_write(bh_accounting.ratelimit, 0);\n\tfor_each_online_cpu(i)\n\t\ttot += per_cpu(bh_accounting, i).nr;\n\tbuffer_heads_over_limit = (tot > max_buffer_heads);\n}\n\nstruct buffer_head *alloc_buffer_head(gfp_t gfp_flags)\n{\n\tstruct buffer_head *ret = kmem_cache_zalloc(bh_cachep, gfp_flags);\n\tif (ret) {\n\t\tINIT_LIST_HEAD(&ret->b_assoc_buffers);\n\t\tpreempt_disable();\n\t\t__this_cpu_inc(bh_accounting.nr);\n\t\trecalc_bh_state();\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(alloc_buffer_head);\n\nvoid free_buffer_head(struct buffer_head *bh)\n{\n\tBUG_ON(!list_empty(&bh->b_assoc_buffers));\n\tkmem_cache_free(bh_cachep, bh);\n\tpreempt_disable();\n\t__this_cpu_dec(bh_accounting.nr);\n\trecalc_bh_state();\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(free_buffer_head);\n\nstatic int buffer_exit_cpu_dead(unsigned int cpu)\n{\n\tint i;\n\tstruct bh_lru *b = &per_cpu(bh_lrus, cpu);\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tthis_cpu_add(bh_accounting.nr, per_cpu(bh_accounting, cpu).nr);\n\tper_cpu(bh_accounting, cpu).nr = 0;\n\treturn 0;\n}\n\n/**\n * bh_uptodate_or_lock - Test whether the buffer is uptodate\n * @bh: struct buffer_head\n *\n * Return true if the buffer is up-to-date and false,\n * with the buffer locked, if not.\n */\nint bh_uptodate_or_lock(struct buffer_head *bh)\n{\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\treturn 0;\n\t\tunlock_buffer(bh);\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(bh_uptodate_or_lock);\n\n/**\n * bh_submit_read - Submit a locked buffer for reading\n * @bh: struct buffer_head\n *\n * Returns zero on success and -EIO on error.\n */\nint bh_submit_read(struct buffer_head *bh)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(REQ_OP_READ, 0, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn 0;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(bh_submit_read);\n\nvoid __init buffer_init(void)\n{\n\tunsigned long nrpages;\n\tint ret;\n\n\tbh_cachep = kmem_cache_create(\"buffer_head\",\n\t\t\tsizeof(struct buffer_head), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tNULL);\n\n\t/*\n\t * Limit the bh occupancy to 10% of ZONE_NORMAL\n\t */\n\tnrpages = (nr_free_buffer_pages() * 10) / 100;\n\tmax_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));\n\tret = cpuhp_setup_state_nocalls(CPUHP_FS_BUFF_DEAD, \"fs/buffer:dead\",\n\t\t\t\t\tNULL, buffer_exit_cpu_dead);\n\tWARN_ON(ret < 0);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};",
      "static unsigned long max_buffer_heads;",
      "int buffer_heads_over_limit;",
      "static DEFINE_PER_CPU(struct bh_accounting, bh_accounting) = {0, 0};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_FS_BUFF_DEAD",
            "\"fs/buffer:dead\"",
            "NULL",
            "buffer_exit_cpu_dead"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"buffer_head\"",
            "sizeof(struct buffer_head)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD)",
            "NULL"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "bh_submit_read"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3435
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "REQ_OP_READ",
            "0",
            "bh"
          ],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3091-3094",
          "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(bh)"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "bh_uptodate_or_lock"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "bh_accounting",
            "cpu"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_add",
          "args": [
            "bh_accounting.nr",
            "per_cpu(bh_accounting, cpu).nr"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "bh_accounting",
            "cpu"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "b->bhs[i]"
          ],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "bh_lrus",
            "cpu"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "free_buffer_head"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_bh_state",
          "args": [],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_bh_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3345-3460",
          "snippet": "static void recalc_bh_state(void)\n{\n\tint i;\n\tint tot = 0;\n\n\tif (__this_cpu_inc_return(bh_accounting.ratelimit) - 1 < 4096)\n\t\treturn;\n\t__this_cpu_write(bh_accounting.ratelimit, 0);\n\tfor_each_online_cpu(i)\n\t\ttot += per_cpu(bh_accounting, i).nr;\n\tbuffer_heads_over_limit = (tot > max_buffer_heads);\n}\n\nstruct buffer_head *alloc_buffer_head(gfp_t gfp_flags)\n{\n\tstruct buffer_head *ret = kmem_cache_zalloc(bh_cachep, gfp_flags);\n\tif (ret) {\n\t\tINIT_LIST_HEAD(&ret->b_assoc_buffers);\n\t\tpreempt_disable();\n\t\t__this_cpu_inc(bh_accounting.nr);\n\t\trecalc_bh_state();\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(alloc_buffer_head);\n\nvoid free_buffer_head(struct buffer_head *bh)\n{\n\tBUG_ON(!list_empty(&bh->b_assoc_buffers));\n\tkmem_cache_free(bh_cachep, bh);\n\tpreempt_disable();\n\t__this_cpu_dec(bh_accounting.nr);\n\trecalc_bh_state();\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(free_buffer_head);\n\nstatic int buffer_exit_cpu_dead(unsigned int cpu)\n{\n\tint i;\n\tstruct bh_lru *b = &per_cpu(bh_lrus, cpu);\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tthis_cpu_add(bh_accounting.nr, per_cpu(bh_accounting, cpu).nr);\n\tper_cpu(bh_accounting, cpu).nr = 0;\n\treturn 0;\n}\n\n/**\n * bh_uptodate_or_lock - Test whether the buffer is uptodate\n * @bh: struct buffer_head\n *\n * Return true if the buffer is up-to-date and false,\n * with the buffer locked, if not.\n */\nint bh_uptodate_or_lock(struct buffer_head *bh)\n{\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\treturn 0;\n\t\tunlock_buffer(bh);\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(bh_uptodate_or_lock);\n\n/**\n * bh_submit_read - Submit a locked buffer for reading\n * @bh: struct buffer_head\n *\n * Returns zero on success and -EIO on error.\n */\nint bh_submit_read(struct buffer_head *bh)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(REQ_OP_READ, 0, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn 0;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(bh_submit_read);\n\nvoid __init buffer_init(void)\n{\n\tunsigned long nrpages;\n\tint ret;\n\n\tbh_cachep = kmem_cache_create(\"buffer_head\",\n\t\t\tsizeof(struct buffer_head), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tNULL);\n\n\t/*\n\t * Limit the bh occupancy to 10% of ZONE_NORMAL\n\t */\n\tnrpages = (nr_free_buffer_pages() * 10) / 100;\n\tmax_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));\n\tret = cpuhp_setup_state_nocalls(CPUHP_FS_BUFF_DEAD, \"fs/buffer:dead\",\n\t\t\t\t\tNULL, buffer_exit_cpu_dead);\n\tWARN_ON(ret < 0);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bh_accounting.nr"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "bh_cachep",
            "bh"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&bh->b_assoc_buffers)"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "alloc_buffer_head"
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "bh_accounting.nr"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ret->b_assoc_buffers"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "bh_cachep",
            "gfp_flags"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "bh_accounting.ratelimit",
            "0"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "bh_accounting.ratelimit"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\nstatic unsigned long max_buffer_heads;\nint buffer_heads_over_limit;\nstatic DEFINE_PER_CPU(struct bh_accounting, bh_accounting) = {0, 0};\n\nstatic void recalc_bh_state(void)\n{\n\tint i;\n\tint tot = 0;\n\n\tif (__this_cpu_inc_return(bh_accounting.ratelimit) - 1 < 4096)\n\t\treturn;\n\t__this_cpu_write(bh_accounting.ratelimit, 0);\n\tfor_each_online_cpu(i)\n\t\ttot += per_cpu(bh_accounting, i).nr;\n\tbuffer_heads_over_limit = (tot > max_buffer_heads);\n}\n\nstruct buffer_head *alloc_buffer_head(gfp_t gfp_flags)\n{\n\tstruct buffer_head *ret = kmem_cache_zalloc(bh_cachep, gfp_flags);\n\tif (ret) {\n\t\tINIT_LIST_HEAD(&ret->b_assoc_buffers);\n\t\tpreempt_disable();\n\t\t__this_cpu_inc(bh_accounting.nr);\n\t\trecalc_bh_state();\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(alloc_buffer_head);\n\nvoid free_buffer_head(struct buffer_head *bh)\n{\n\tBUG_ON(!list_empty(&bh->b_assoc_buffers));\n\tkmem_cache_free(bh_cachep, bh);\n\tpreempt_disable();\n\t__this_cpu_dec(bh_accounting.nr);\n\trecalc_bh_state();\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(free_buffer_head);\n\nstatic int buffer_exit_cpu_dead(unsigned int cpu)\n{\n\tint i;\n\tstruct bh_lru *b = &per_cpu(bh_lrus, cpu);\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tthis_cpu_add(bh_accounting.nr, per_cpu(bh_accounting, cpu).nr);\n\tper_cpu(bh_accounting, cpu).nr = 0;\n\treturn 0;\n}\n\n/**\n * bh_uptodate_or_lock - Test whether the buffer is uptodate\n * @bh: struct buffer_head\n *\n * Return true if the buffer is up-to-date and false,\n * with the buffer locked, if not.\n */\nint bh_uptodate_or_lock(struct buffer_head *bh)\n{\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\treturn 0;\n\t\tunlock_buffer(bh);\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(bh_uptodate_or_lock);\n\n/**\n * bh_submit_read - Submit a locked buffer for reading\n * @bh: struct buffer_head\n *\n * Returns zero on success and -EIO on error.\n */\nint bh_submit_read(struct buffer_head *bh)\n{\n\tBUG_ON(!buffer_locked(bh));\n\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(REQ_OP_READ, 0, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn 0;\n\treturn -EIO;\n}\nEXPORT_SYMBOL(bh_submit_read);\n\nvoid __init buffer_init(void)\n{\n\tunsigned long nrpages;\n\tint ret;\n\n\tbh_cachep = kmem_cache_create(\"buffer_head\",\n\t\t\tsizeof(struct buffer_head), 0,\n\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\tNULL);\n\n\t/*\n\t * Limit the bh occupancy to 10% of ZONE_NORMAL\n\t */\n\tnrpages = (nr_free_buffer_pages() * 10) / 100;\n\tmax_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));\n\tret = cpuhp_setup_state_nocalls(CPUHP_FS_BUFF_DEAD, \"fs/buffer:dead\",\n\t\t\t\t\tNULL, buffer_exit_cpu_dead);\n\tWARN_ON(ret < 0);\n}"
  },
  {
    "function_name": "try_to_free_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3249-3295",
    "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_dirty_page",
          "args": [
            "page"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_buffers",
          "args": [
            "page",
            "&buffers_to_free"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "drop_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3222-3247",
          "snippet": "static int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "drop_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3222-3247",
    "snippet": "static int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_page_buffers",
          "args": [
            "page"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "bh"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "450-455",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_busy",
          "args": [
            "bh"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3216-3220",
          "snippet": "static inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int\ndrop_buffers(struct page *page, struct buffer_head **buffers_to_free)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh;\n\n\tbh = head;\n\tdo {\n\t\tif (buffer_busy(bh))\n\t\t\tgoto failed;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\n\t\tif (bh->b_assoc_map)\n\t\t\t__remove_assoc_queue(bh);\n\t\tbh = next;\n\t} while (bh != head);\n\t*buffers_to_free = head;\n\t__clear_page_buffers(page);\n\treturn 1;\nfailed:\n\treturn 0;\n}"
  },
  {
    "function_name": "buffer_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3216-3220",
    "snippet": "static inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 3218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int buffer_busy(struct buffer_head *bh)\n{\n\treturn atomic_read(&bh->b_count) |\n\t\t(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));\n}"
  },
  {
    "function_name": "sync_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3190-3193",
    "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, REQ_SYNC);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_dirty_buffer",
          "args": [
            "bh",
            "REQ_SYNC"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3170-3187",
          "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(REQ_OP_WRITE, op_flags, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(REQ_OP_WRITE, op_flags, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, REQ_SYNC);\n}"
  },
  {
    "function_name": "__sync_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3170-3187",
    "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(REQ_OP_WRITE, op_flags, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "REQ_OP_WRITE",
            "op_flags",
            "bh"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3091-3094",
          "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&bh->b_count) < 1"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(REQ_OP_WRITE, op_flags, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "write_dirty_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3152-3162",
    "snippet": "void write_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_WRITE, op_flags, bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "REQ_OP_WRITE",
            "op_flags",
            "bh"
          ],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3091-3094",
          "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_WRITE, op_flags, bh);\n}"
  },
  {
    "function_name": "ll_rw_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3123-3149",
    "snippet": "void ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "op",
            "op_flags",
            "bh"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3091-3094",
          "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
  },
  {
    "function_name": "submit_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3091-3094",
    "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh_wbc",
          "args": [
            "op",
            "op_flags",
            "bh",
            "0",
            "NULL"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh_wbc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3040-3089",
          "snippet": "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint write_hint, struct writeback_control *wbc)\n{\n\tstruct bio *bio;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (op == REQ_OP_WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tif (wbc) {\n\t\twbc_init_bio(wbc, bio);\n\t\twbc_account_io(wbc, bh->b_page, bh->b_size);\n\t}\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio_set_dev(bio, bh->b_bdev);\n\tbio->bi_write_hint = write_hint;\n\n\tbio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n\tBUG_ON(bio->bi_iter.bi_size != bh->b_size);\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(op, bio);\n\n\tif (buffer_meta(bh))\n\t\top_flags |= REQ_META;\n\tif (buffer_prio(bh))\n\t\top_flags |= REQ_PRIO;\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tsubmit_bio(bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint write_hint, struct writeback_control *wbc)\n{\n\tstruct bio *bio;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (op == REQ_OP_WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tif (wbc) {\n\t\twbc_init_bio(wbc, bio);\n\t\twbc_account_io(wbc, bh->b_page, bh->b_size);\n\t}\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio_set_dev(bio, bh->b_bdev);\n\tbio->bi_write_hint = write_hint;\n\n\tbio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n\tBUG_ON(bio->bi_iter.bi_size != bh->b_size);\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(op, bio);\n\n\tif (buffer_meta(bh))\n\t\top_flags |= REQ_META;\n\tif (buffer_prio(bh))\n\t\top_flags |= REQ_PRIO;\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tsubmit_bio(bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
  },
  {
    "function_name": "submit_bh_wbc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3040-3089",
    "snippet": "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint write_hint, struct writeback_control *wbc)\n{\n\tstruct bio *bio;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (op == REQ_OP_WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tif (wbc) {\n\t\twbc_init_bio(wbc, bio);\n\t\twbc_account_io(wbc, bh->b_page, bh->b_size);\n\t}\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio_set_dev(bio, bh->b_bdev);\n\tbio->bi_write_hint = write_hint;\n\n\tbio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n\tBUG_ON(bio->bi_iter.bi_size != bh->b_size);\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(op, bio);\n\n\tif (buffer_meta(bh))\n\t\top_flags |= REQ_META;\n\tif (buffer_prio(bh))\n\t\top_flags |= REQ_PRIO;\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tsubmit_bio(bio);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-116",
          "snippet": "static struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\tbio_op(bio) == READ ? \"read\" : \"write\",\n\t\t\tbio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_set_op_attrs",
          "args": [
            "bio",
            "op",
            "op_flags"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_prio",
          "args": [
            "bh"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_meta",
          "args": [
            "bh"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guard_bio_eod",
          "args": [
            "op",
            "bio"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "guard_bio_eod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2996-3038",
          "snippet": "void guard_bio_eod(int op, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = bio_last_bvec_all(bio);\n\tunsigned truncated_bytes;\n\tstruct hd_struct *part;\n\n\trcu_read_lock();\n\tpart = __disk_get_part(bio->bi_disk, bio->bi_partno);\n\tif (part)\n\t\tmaxsector = part_nr_sects_read(part);\n\telse\n\t\tmaxsector = get_capacity(bio->bi_disk);\n\trcu_read_unlock();\n\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif (op == REQ_OP_READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid guard_bio_eod(int op, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = bio_last_bvec_all(bio);\n\tunsigned truncated_bytes;\n\tstruct hd_struct *part;\n\n\trcu_read_lock();\n\tpart = __disk_get_part(bio->bi_disk, bio->bi_partno);\n\tif (part)\n\t\tmaxsector = part_nr_sects_read(part);\n\telse\n\t\tmaxsector = get_capacity(bio->bi_disk);\n\trcu_read_unlock();\n\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif (op == REQ_OP_READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bio->bi_iter.bi_size != bh->b_size"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "bh->b_page",
            "bh->b_size",
            "bh_offset(bh)"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "bh->b_bdev"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbc_account_io",
          "args": [
            "wbc",
            "bh->b_page",
            "bh->b_size"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "wbc_account_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "683-714",
          "snippet": "void wbc_account_io(struct writeback_control *wbc, struct page *page,\n\t\t    size_t bytes)\n{\n\tint id;\n\n\t/*\n\t * pageout() path doesn't attach @wbc to the inode being written\n\t * out.  This is intentional as we don't want the function to block\n\t * behind a slow cgroup.  Ultimately, we want pageout() to kick off\n\t * regular writeback instead of writing things out itself.\n\t */\n\tif (!wbc->wb)\n\t\treturn;\n\n\tid = mem_cgroup_css_from_page(page)->id;\n\n\tif (id == wbc->wb_id) {\n\t\twbc->wb_bytes += bytes;\n\t\treturn;\n\t}\n\n\tif (id == wbc->wb_lcand_id)\n\t\twbc->wb_lcand_bytes += bytes;\n\n\t/* Boyer-Moore majority vote algorithm */\n\tif (!wbc->wb_tcand_bytes)\n\t\twbc->wb_tcand_id = id;\n\tif (id == wbc->wb_tcand_id)\n\t\twbc->wb_tcand_bytes += bytes;\n\telse\n\t\twbc->wb_tcand_bytes -= min(bytes, wbc->wb_tcand_bytes);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wbc_account_io(struct writeback_control *wbc, struct page *page,\n\t\t    size_t bytes)\n{\n\tint id;\n\n\t/*\n\t * pageout() path doesn't attach @wbc to the inode being written\n\t * out.  This is intentional as we don't want the function to block\n\t * behind a slow cgroup.  Ultimately, we want pageout() to kick off\n\t * regular writeback instead of writing things out itself.\n\t */\n\tif (!wbc->wb)\n\t\treturn;\n\n\tid = mem_cgroup_css_from_page(page)->id;\n\n\tif (id == wbc->wb_id) {\n\t\twbc->wb_bytes += bytes;\n\t\treturn;\n\t}\n\n\tif (id == wbc->wb_lcand_id)\n\t\twbc->wb_lcand_bytes += bytes;\n\n\t/* Boyer-Moore majority vote algorithm */\n\tif (!wbc->wb_tcand_bytes)\n\t\twbc->wb_tcand_id = id;\n\tif (id == wbc->wb_tcand_id)\n\t\twbc->wb_tcand_bytes += bytes;\n\telse\n\t\twbc->wb_tcand_bytes -= min(bytes, wbc->wb_tcand_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbc_init_bio",
          "args": [
            "wbc",
            "bio"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "1"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.c",
          "lines": "2667-2676",
          "snippet": "struct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set btrfs_bioset;\n\nstruct bio *btrfs_bio_alloc(struct block_device *bdev, u64 first_byte)\n{\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(GFP_NOFS, BIO_MAX_PAGES, &btrfs_bioset);\n\tbio_set_dev(bio, bdev);\n\tbio->bi_iter.bi_sector = first_byte >> 9;\n\tbtrfs_io_bio_init(btrfs_io_bio(bio));\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_buffer_req",
          "args": [
            "bh"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_unwritten(bh)"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_delay(bh)"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh->b_end_io"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_mapped(bh)"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(bh)"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint write_hint, struct writeback_control *wbc)\n{\n\tstruct bio *bio;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (op == REQ_OP_WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tif (wbc) {\n\t\twbc_init_bio(wbc, bio);\n\t\twbc_account_io(wbc, bh->b_page, bh->b_size);\n\t}\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio_set_dev(bio, bh->b_bdev);\n\tbio->bi_write_hint = write_hint;\n\n\tbio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n\tBUG_ON(bio->bi_iter.bi_size != bh->b_size);\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(op, bio);\n\n\tif (buffer_meta(bh))\n\t\top_flags |= REQ_META;\n\tif (buffer_prio(bh))\n\t\top_flags |= REQ_PRIO;\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tsubmit_bio(bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "guard_bio_eod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2996-3038",
    "snippet": "void guard_bio_eod(int op, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = bio_last_bvec_all(bio);\n\tunsigned truncated_bytes;\n\tstruct hd_struct *part;\n\n\trcu_read_lock();\n\tpart = __disk_get_part(bio->bi_disk, bio->bi_partno);\n\tif (part)\n\t\tmaxsector = part_nr_sects_read(part);\n\telse\n\t\tmaxsector = get_capacity(bio->bi_disk);\n\trcu_read_unlock();\n\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif (op == REQ_OP_READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "bvec->bv_page",
            "bvec->bv_offset + bvec->bv_len",
            "truncated_bytes"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(bio->bi_iter.bi_size >> 9) <= maxsector"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bio->bi_iter.bi_sector >= maxsector"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_capacity",
          "args": [
            "bio->bi_disk"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_nr_sects_read",
          "args": [
            "part"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__disk_get_part",
          "args": [
            "bio->bi_disk",
            "bio->bi_partno"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_last_bvec_all",
          "args": [
            "bio"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid guard_bio_eod(int op, struct bio *bio)\n{\n\tsector_t maxsector;\n\tstruct bio_vec *bvec = bio_last_bvec_all(bio);\n\tunsigned truncated_bytes;\n\tstruct hd_struct *part;\n\n\trcu_read_lock();\n\tpart = __disk_get_part(bio->bi_disk, bio->bi_partno);\n\tif (part)\n\t\tmaxsector = part_nr_sects_read(part);\n\telse\n\t\tmaxsector = get_capacity(bio->bi_disk);\n\trcu_read_unlock();\n\n\tif (!maxsector)\n\t\treturn;\n\n\t/*\n\t * If the *whole* IO is past the end of the device,\n\t * let it through, and the IO layer will turn it into\n\t * an EIO.\n\t */\n\tif (unlikely(bio->bi_iter.bi_sector >= maxsector))\n\t\treturn;\n\n\tmaxsector -= bio->bi_iter.bi_sector;\n\tif (likely((bio->bi_iter.bi_size >> 9) <= maxsector))\n\t\treturn;\n\n\t/* Uhhuh. We've got a bio that straddles the device size! */\n\ttruncated_bytes = bio->bi_iter.bi_size - (maxsector << 9);\n\n\t/* Truncate the bio.. */\n\tbio->bi_iter.bi_size -= truncated_bytes;\n\tbvec->bv_len -= truncated_bytes;\n\n\t/* ..and clear the end of the buffer for reads */\n\tif (op == REQ_OP_READ) {\n\t\tzero_user(bvec->bv_page, bvec->bv_offset + bvec->bv_len,\n\t\t\t\ttruncated_bytes);\n\t}\n}"
  },
  {
    "function_name": "end_bio_bh_io_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2973-2982",
    "snippet": "static void end_bio_bh_io_sync(struct bio *bio)\n{\n\tstruct buffer_head *bh = bio->bi_private;\n\n\tif (unlikely(bio_flagged(bio, BIO_QUIET)))\n\t\tset_bit(BH_Quiet, &bh->b_state);\n\n\tbh->b_end_io(bh, !bio->bi_status);\n\tbio_put(bio);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh->b_end_io",
          "args": [
            "bh",
            "!bio->bi_status"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BH_Quiet",
            "&bh->b_state"
          ],
          "line": 2978
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "914-918",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bio_flagged(bio, BIO_QUIET)"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_flagged",
          "args": [
            "bio",
            "BIO_QUIET"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void end_bio_bh_io_sync(struct bio *bio)\n{\n\tstruct buffer_head *bh = bio->bi_private;\n\n\tif (unlikely(bio_flagged(bio, BIO_QUIET)))\n\t\tset_bit(BH_Quiet, &bh->b_state);\n\n\tbh->b_end_io(bh, !bio->bi_status);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "generic_block_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2960-2970",
    "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head tmp = {\n\t\t.b_size = i_blocksize(inode),\n\t};\n\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "&tmp",
            "0"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head tmp = {\n\t\t.b_size = i_blocksize(inode),\n\t};\n\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
  },
  {
    "function_name": "block_write_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2921-2957",
    "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_full_page",
          "args": [
            "inode",
            "page",
            "get_block",
            "wbc",
            "end_buffer_async_write"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1667-1828",
          "snippet": "int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_flags = wbc_to_write_flags(wbc);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nint __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_flags = wbc_to_write_flags(wbc);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_SIZE"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_SIZE"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
  },
  {
    "function_name": "block_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2842-2915",
    "snippet": "int block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = i_blocksize(inode);\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "REQ_OP_READ",
            "0",
            "1",
            "&bh"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3123-3149",
          "snippet": "void ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "iblock",
            "bh",
            "0"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1511-1538",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = i_blocksize(inode);\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "nobh_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2764-2839",
    "snippet": "int nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = i_blocksize(inode);\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tput_page(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "614-649",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "NULL",
            "page"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&map_bh"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "iblock",
            "&map_bh",
            "0"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "mapping",
            "from",
            "get_block"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2842-2915",
          "snippet": "int block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = i_blocksize(inode);\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = i_blocksize(inode);\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = i_blocksize(inode);\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tput_page(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "nobh_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2717-2761",
    "snippet": "int nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_full_page",
          "args": [
            "inode",
            "page",
            "get_block",
            "wbc",
            "end_buffer_async_write"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1667-1828",
          "snippet": "int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_flags = wbc_to_write_flags(wbc);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nint __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_flags = wbc_to_write_flags(wbc);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_writepage",
          "args": [
            "page",
            "get_block",
            "wbc"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mpage.c",
          "lines": "742-758",
          "snippet": "int mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio) {\n\t\tint op_flags = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\t  REQ_SYNC : 0);\n\t\tmpage_bio_submit(REQ_OP_WRITE, op_flags, mpd.bio);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_writepage(struct page *page, get_block_t get_block,\n\tstruct writeback_control *wbc)\n{\n\tstruct mpage_data mpd = {\n\t\t.bio = NULL,\n\t\t.last_block_in_bio = 0,\n\t\t.get_block = get_block,\n\t\t.use_writepage = 0,\n\t};\n\tint ret = __mpage_writepage(page, wbc, &mpd);\n\tif (mpd.bio) {\n\t\tint op_flags = (wbc->sync_mode == WB_SYNC_ALL ?\n\t\t\t  REQ_SYNC : 0);\n\t\tmpage_bio_submit(REQ_OP_WRITE, op_flags, mpd.bio);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "offset",
            "PAGE_SIZE"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page->mapping->a_ops->invalidatepage",
          "args": [
            "page",
            "offset"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nint nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}"
  },
  {
    "function_name": "nobh_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2677-2709",
    "snippet": "int nobh_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *head = fsdata;\n\tstruct buffer_head *bh;\n\tBUG_ON(fsdata != NULL && page_has_buffers(page));\n\n\tif (unlikely(copied < len) && head)\n\t\tattach_nobh_buffers(page, head);\n\tif (page_has_buffers(page))\n\t\treturn generic_write_end(file, mapping, pos, len,\n\t\t\t\t\tcopied, page, fsdata);\n\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\twhile (head) {\n\t\tbh = head;\n\t\thead = head->b_this_page;\n\t\tfree_buffer_head(bh);\n\t}\n\n\treturn copied;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2059-2079",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos+copied"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "614-649",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2157-2163",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\treturn __generic_write_end(mapping->host, pos, copied, page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\treturn __generic_write_end(mapping->host, pos, copied, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_nobh_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "attach_nobh_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2512-2529",
          "snippet": "static void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fsdata != NULL && page_has_buffers(page)"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint nobh_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *head = fsdata;\n\tstruct buffer_head *bh;\n\tBUG_ON(fsdata != NULL && page_has_buffers(page));\n\n\tif (unlikely(copied < len) && head)\n\t\tattach_nobh_buffers(page, head);\n\tif (page_has_buffers(page))\n\t\treturn generic_write_end(file, mapping, pos, len,\n\t\t\t\t\tcopied, page, fsdata);\n\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\twhile (head) {\n\t\tbh = head;\n\t\thead = head->b_this_page;\n\t\tfree_buffer_head(bh);\n\t}\n\n\treturn copied;\n}"
  },
  {
    "function_name": "nobh_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2536-2674",
    "snippet": "int nobh_write_begin(struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block)\n{\n\tstruct inode *inode = mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *head, *bh;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\tunsigned block_in_page;\n\tunsigned block_start, block_end;\n\tsector_t block_in_file;\n\tint nr_reads = 0;\n\tint ret = 0;\n\tint is_mapped_to_disk = 1;\n\n\tindex = pos >> PAGE_SHIFT;\n\tfrom = pos & (PAGE_SIZE - 1);\n\tto = from + len;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\t*fsdata = NULL;\n\n\tif (page_has_buffers(page)) {\n\t\tret = __block_write_begin(page, pos, len, get_block);\n\t\tif (unlikely(ret))\n\t\t\tgoto out_release;\n\t\treturn ret;\n\t}\n\n\tif (PageMappedToDisk(page))\n\t\treturn 0;\n\n\t/*\n\t * Allocate buffers so that we can keep track of state, and potentially\n\t * attach them to the page if an error occurs. In the common case of\n\t * no error, they will just be freed again without ever being attached\n\t * to the page (which is all OK, because we're under the page lock).\n\t *\n\t * Be careful: the buffer linked list is a NULL terminated one, rather\n\t * than the circular one we're used to.\n\t */\n\thead = alloc_page_buffers(page, blocksize, false);\n\tif (!head) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\n\t/*\n\t * We loop across all blocks in the page, whether or not they are\n\t * part of the affected region.  This is so we can discover if the\n\t * page is fully mapped-to-disk.\n\t */\n\tfor (block_start = 0, block_in_page = 0, bh = head;\n\t\t  block_start < PAGE_SIZE;\n\t\t  block_in_page++, block_start += blocksize, bh = bh->b_this_page) {\n\t\tint create;\n\n\t\tblock_end = block_start + blocksize;\n\t\tbh->b_state = 0;\n\t\tcreate = 1;\n\t\tif (block_start >= to)\n\t\t\tcreate = 0;\n\t\tret = get_block(inode, block_in_file + block_in_page,\n\t\t\t\t\tbh, create);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t\tif (!buffer_mapped(bh))\n\t\t\tis_mapped_to_disk = 0;\n\t\tif (buffer_new(bh))\n\t\t\tclean_bdev_bh_alias(bh);\n\t\tif (PageUptodate(page)) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh) || !buffer_mapped(bh)) {\n\t\t\tzero_user_segments(page, block_start, from,\n\t\t\t\t\t\t\tto, block_end);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\t/* reiserfs does this */\n\t\tif (block_start < from || block_end > to) {\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_read_nobh;\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t\t\tnr_reads++;\n\t\t}\n\t}\n\n\tif (nr_reads) {\n\t\t/*\n\t\t * The page is locked, so these buffers are protected from\n\t\t * any VM or truncate activity.  Hence we don't need to care\n\t\t * for the buffer_head refcounts.\n\t\t */\n\t\tfor (bh = head; bh; bh = bh->b_this_page) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tif (is_mapped_to_disk)\n\t\tSetPageMappedToDisk(page);\n\n\t*fsdata = head; /* to be released by nobh_write_end */\n\n\treturn 0;\n\nfailed:\n\tBUG_ON(!ret);\n\t/*\n\t * Error recovery is a bit difficult. We need to zero out blocks that\n\t * were newly allocated, and dirty them to ensure they get written out.\n\t * Buffers need to be attached to the page at this point, otherwise\n\t * the handling of potential IO errors during writeout would be hard\n\t * (could try doing synchronous writeout, but what if that fails too?)\n\t */\n\tattach_nobh_buffers(page, head);\n\tpage_zero_new_buffers(page, from, to);\n\nout_release:\n\tunlock_page(page);\n\tput_page(page);\n\t*pagep = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "from",
            "to"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1836-1870",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_nobh_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "attach_nobh_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2512-2529",
          "snippet": "static void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ret"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "REQ_OP_READ",
            "0",
            "bh"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3091-3094",
          "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "block_start",
            "from",
            "to",
            "block_end"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_bdev_bh_alias",
          "args": [
            "bh"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block_in_file + block_in_page",
            "bh",
            "create"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "blocksize",
            "false"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "812-859",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "get_block"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2013-2017",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nint nobh_write_begin(struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block)\n{\n\tstruct inode *inode = mapping->host;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tstruct buffer_head *head, *bh;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\tunsigned block_in_page;\n\tunsigned block_start, block_end;\n\tsector_t block_in_file;\n\tint nr_reads = 0;\n\tint ret = 0;\n\tint is_mapped_to_disk = 1;\n\n\tindex = pos >> PAGE_SHIFT;\n\tfrom = pos & (PAGE_SIZE - 1);\n\tto = from + len;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\t*fsdata = NULL;\n\n\tif (page_has_buffers(page)) {\n\t\tret = __block_write_begin(page, pos, len, get_block);\n\t\tif (unlikely(ret))\n\t\t\tgoto out_release;\n\t\treturn ret;\n\t}\n\n\tif (PageMappedToDisk(page))\n\t\treturn 0;\n\n\t/*\n\t * Allocate buffers so that we can keep track of state, and potentially\n\t * attach them to the page if an error occurs. In the common case of\n\t * no error, they will just be freed again without ever being attached\n\t * to the page (which is all OK, because we're under the page lock).\n\t *\n\t * Be careful: the buffer linked list is a NULL terminated one, rather\n\t * than the circular one we're used to.\n\t */\n\thead = alloc_page_buffers(page, blocksize, false);\n\tif (!head) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tblock_in_file = (sector_t)page->index << (PAGE_SHIFT - blkbits);\n\n\t/*\n\t * We loop across all blocks in the page, whether or not they are\n\t * part of the affected region.  This is so we can discover if the\n\t * page is fully mapped-to-disk.\n\t */\n\tfor (block_start = 0, block_in_page = 0, bh = head;\n\t\t  block_start < PAGE_SIZE;\n\t\t  block_in_page++, block_start += blocksize, bh = bh->b_this_page) {\n\t\tint create;\n\n\t\tblock_end = block_start + blocksize;\n\t\tbh->b_state = 0;\n\t\tcreate = 1;\n\t\tif (block_start >= to)\n\t\t\tcreate = 0;\n\t\tret = get_block(inode, block_in_file + block_in_page,\n\t\t\t\t\tbh, create);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t\tif (!buffer_mapped(bh))\n\t\t\tis_mapped_to_disk = 0;\n\t\tif (buffer_new(bh))\n\t\t\tclean_bdev_bh_alias(bh);\n\t\tif (PageUptodate(page)) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh) || !buffer_mapped(bh)) {\n\t\t\tzero_user_segments(page, block_start, from,\n\t\t\t\t\t\t\tto, block_end);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\t/* reiserfs does this */\n\t\tif (block_start < from || block_end > to) {\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_read_nobh;\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t\t\tnr_reads++;\n\t\t}\n\t}\n\n\tif (nr_reads) {\n\t\t/*\n\t\t * The page is locked, so these buffers are protected from\n\t\t * any VM or truncate activity.  Hence we don't need to care\n\t\t * for the buffer_head refcounts.\n\t\t */\n\t\tfor (bh = head; bh; bh = bh->b_this_page) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tif (is_mapped_to_disk)\n\t\tSetPageMappedToDisk(page);\n\n\t*fsdata = head; /* to be released by nobh_write_end */\n\n\treturn 0;\n\nfailed:\n\tBUG_ON(!ret);\n\t/*\n\t * Error recovery is a bit difficult. We need to zero out blocks that\n\t * were newly allocated, and dirty them to ensure they get written out.\n\t * Buffers need to be attached to the page at this point, otherwise\n\t * the handling of potential IO errors during writeout would be hard\n\t * (could try doing synchronous writeout, but what if that fails too?)\n\t */\n\tattach_nobh_buffers(page, head);\n\tpage_zero_new_buffers(page, from, to);\n\nout_release:\n\tunlock_page(page);\n\tput_page(page);\n\t*pagep = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "attach_nobh_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2512-2529",
    "snippet": "static void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void attach_nobh_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh;\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock(&page->mapping->private_lock);\n\tbh = head;\n\tdo {\n\t\tif (PageDirty(page))\n\t\t\tset_buffer_dirty(bh);\n\t\tif (!bh->b_this_page)\n\t\t\tbh->b_this_page = head;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
  },
  {
    "function_name": "end_buffer_read_nobh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2502-2505",
    "snippet": "static void end_buffer_read_nobh(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_buffer_read_notouch",
          "args": [
            "bh",
            "uptodate"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "__end_buffer_read_notouch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "146-155",
          "snippet": "static void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed read-ahead attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed read-ahead attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void end_buffer_read_nobh(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n}"
  },
  {
    "function_name": "block_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2458-2494",
    "snippet": "int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_SHIFT) > size)\n\t\tend = size & ~PAGE_MASK;\n\telse\n\t\tend = PAGE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "614-649",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_commit_write",
          "args": [
            "page",
            "0",
            "end"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2432-2437",
          "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "0",
            "end",
            "get_block"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2013-2017",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_SHIFT) > size)\n\t\tend = size & ~PAGE_MASK;\n\telse\n\t\tend = PAGE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "block_commit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2432-2437",
    "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_commit_write",
          "args": [
            "inode",
            "page",
            "from",
            "to"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "__block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2020-2056",
          "snippet": "static int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
  },
  {
    "function_name": "cont_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2408-2429",
    "snippet": "int cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned int blocksize = i_blocksize(inode);\n\tunsigned int zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "get_block"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2064-2084",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cont_expand_zero",
          "args": [
            "file",
            "mapping",
            "pos",
            "bytes"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "cont_expand_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2332-2402",
          "snippet": "static int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned int blocksize = i_blocksize(inode);\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_SHIFT;\n\toffset = pos & ~PAGE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned int blocksize = i_blocksize(inode);\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_SHIFT;\n\toffset = pos & ~PAGE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint cont_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata,\n\t\t\tget_block_t *get_block, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned int blocksize = i_blocksize(inode);\n\tunsigned int zerofrom;\n\tint err;\n\n\terr = cont_expand_zero(file, mapping, pos, bytes);\n\tif (err)\n\t\treturn err;\n\n\tzerofrom = *bytes & ~PAGE_MASK;\n\tif (pos+len > *bytes && zerofrom & (blocksize-1)) {\n\t\t*bytes |= (blocksize-1);\n\t\t(*bytes)++;\n\t}\n\n\treturn block_write_begin(mapping, pos, len, flags, pagep, get_block);\n}"
  },
  {
    "function_name": "cont_expand_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2332-2402",
    "snippet": "static int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned int blocksize = i_blocksize(inode);\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_SHIFT;\n\toffset = pos & ~PAGE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != len"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "len",
            "page",
            "fsdata"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "zerofrom",
            "len"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "0",
            "&page",
            "&fsdata"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fatal_signal_pending(current)"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != len"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "len",
            "page",
            "fsdata"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "zerofrom",
            "len"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "file",
            "mapping",
            "curpos",
            "len",
            "0",
            "&page",
            "&fsdata"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int cont_expand_zero(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, loff_t *bytes)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned int blocksize = i_blocksize(inode);\n\tstruct page *page;\n\tvoid *fsdata;\n\tpgoff_t index, curidx;\n\tloff_t curpos;\n\tunsigned zerofrom, offset, len;\n\tint err = 0;\n\n\tindex = pos >> PAGE_SHIFT;\n\toffset = pos & ~PAGE_MASK;\n\n\twhile (index > (curidx = (curpos = *bytes)>>PAGE_SHIFT)) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = PAGE_SIZE - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* page covers the boundary, find the boundary offset */\n\tif (index == curidx) {\n\t\tzerofrom = curpos & ~PAGE_MASK;\n\t\t/* if we will expand the thing last block will be filled */\n\t\tif (offset <= zerofrom) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (zerofrom & (blocksize-1)) {\n\t\t\t*bytes |= (blocksize-1);\n\t\t\t(*bytes)++;\n\t\t}\n\t\tlen = offset - zerofrom;\n\n\t\terr = pagecache_write_begin(file, mapping, curpos, len, 0,\n\t\t\t\t\t    &page, &fsdata);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tzero_user(page, zerofrom, len);\n\t\terr = pagecache_write_end(file, mapping, curpos, len, len,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(err != len);\n\t\terr = 0;\n\t}\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "generic_cont_expand_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2308-2329",
    "snippet": "int generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t    AOP_FLAG_CONT_EXPAND, &page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err > 0"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "NULL",
            "mapping",
            "size",
            "0",
            "0",
            "page",
            "fsdata"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "NULL",
            "mapping",
            "size",
            "0",
            "AOP_FLAG_CONT_EXPAND",
            "&page",
            "&fsdata"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "size"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "135-160",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t    AOP_FLAG_CONT_EXPAND, &page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "block_read_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2218-2301",
    "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "REQ_OP_READ",
            "0",
            "bh"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3091-3094",
          "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_buffer_async_read",
          "args": [
            "bh",
            "1"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "end_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "251-306",
          "snippet": "static void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_async_read",
          "args": [
            "bh"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "378-382",
          "snippet": "static void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "i * blocksize",
            "blocksize"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "iblock",
            "bh",
            "0"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_size_bits",
          "args": [
            "blocksize"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1623-1626",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_page_buffers",
          "args": [
            "page",
            "inode",
            "0"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "create_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1628-1636",
          "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "block_is_partially_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2173-2208",
    "snippet": "int block_is_partially_uptodate(struct page *page, unsigned long from,\n\t\t\t\t\tunsigned long count)\n{\n\tunsigned block_start, block_end, blocksize;\n\tunsigned to;\n\tstruct buffer_head *bh, *head;\n\tint ret = 1;\n\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\thead = page_buffers(page);\n\tblocksize = head->b_size;\n\tto = min_t(unsigned, PAGE_SIZE - from, count);\n\tto = from + to;\n\tif (from < blocksize && to > PAGE_SIZE - blocksize)\n\t\treturn 0;\n\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end > from && block_start < to) {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (block_end >= to)\n\t\t\t\tbreak;\n\t\t}\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsigned",
            "PAGE_SIZE - from",
            "count"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_is_partially_uptodate(struct page *page, unsigned long from,\n\t\t\t\t\tunsigned long count)\n{\n\tunsigned block_start, block_end, blocksize;\n\tunsigned to;\n\tstruct buffer_head *bh, *head;\n\tint ret = 1;\n\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\thead = page_buffers(page);\n\tblocksize = head->b_size;\n\tto = min_t(unsigned, PAGE_SIZE - from, count);\n\tto = from + to;\n\tif (from < blocksize && to > PAGE_SIZE - blocksize)\n\t\treturn 0;\n\n\tbh = head;\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end > from && block_start < to) {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (block_end >= to)\n\t\t\t\tbreak;\n\t\t}\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2157-2163",
    "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\treturn __generic_write_end(mapping->host, pos, copied, page);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__generic_write_end",
          "args": [
            "mapping->host",
            "pos",
            "copied",
            "page"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2087-2119",
          "snippet": "int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2121-2154",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\treturn __generic_write_end(mapping->host, pos, copied, page);\n}"
  },
  {
    "function_name": "block_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2121-2154",
    "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_commit_write",
          "args": [
            "inode",
            "page",
            "start",
            "start+copied"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "__block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2020-2056",
          "snippet": "static int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "start+copied",
            "start+len"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1836-1870",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "__generic_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2087-2119",
    "snippet": "int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2059-2079",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_isize_extended",
          "args": [
            "inode",
            "old_size",
            "pos"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2436-2448",
          "snippet": "static inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void f2fs_i_size_write(struct inode *inode, loff_t i_size)\n{\n\tbool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);\n\tbool recover = is_inode_flag_set(inode, FI_AUTO_RECOVER);\n\n\tif (i_size_read(inode) == i_size)\n\t\treturn;\n\n\ti_size_write(inode, i_size);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (clean || recover)\n\t\tset_inode_flag(inode, FI_AUTO_RECOVER);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,\n\t\tstruct page *page)\n{\n\tloff_t old_size = inode->i_size;\n\tbool i_size_changed = false;\n\n\t/*\n\t * No need to use i_size_read() here, the i_size cannot change under us\n\t * because we hold i_rwsem.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos + copied > inode->i_size) {\n\t\ti_size_write(inode, pos + copied);\n\t\ti_size_changed = true;\n\t}\n\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\treturn copied;\n}"
  },
  {
    "function_name": "block_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2064-2084",
    "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "get_block"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "2013-2017",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
  },
  {
    "function_name": "__block_commit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2020-2056",
    "snippet": "static int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int __block_commit_write(struct inode *inode, struct page *page,\n\t\tunsigned from, unsigned to)\n{\n\tunsigned block_start, block_end;\n\tint partial = 0;\n\tunsigned blocksize;\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tblocksize = bh->b_size;\n\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tpartial = 1;\n\t\t} else {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\tclear_buffer_new(bh);\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * If this is a partial write which happened to make all buffers\n\t * uptodate then we can optimize away a bogus readpage() for\n\t * the next read(). Here we 'discover' whether the page went\n\t * uptodate as a result of this (potentially partial) write.\n\t */\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "__block_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "2013-2017",
    "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_begin_int",
          "args": [
            "page",
            "pos",
            "len",
            "get_block",
            "NULL"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1928-2011",
          "snippet": "int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\treturn __block_write_begin_int(page, pos, len, get_block, NULL);\n}"
  },
  {
    "function_name": "__block_write_begin_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1928-2011",
    "snippet": "int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "from",
            "to"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1836-1870",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "*wait_bh"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "*--wait_bh"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "REQ_OP_READ",
            "0",
            "1",
            "&bh"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3123-3149",
          "snippet": "void ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "to",
            "block_end",
            "block_start",
            "from"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_bdev_bh_alias",
          "args": [
            "bh"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iomap_to_bh",
          "args": [
            "inode",
            "block",
            "bh",
            "iomap"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "iomap_to_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1873-1926",
          "snippet": "static void\niomap_to_bh(struct inode *inode, sector_t block, struct buffer_head *bh,\n\t\tstruct iomap *iomap)\n{\n\tloff_t offset = block << inode->i_blkbits;\n\n\tbh->b_bdev = iomap->bdev;\n\n\t/*\n\t * Block points to offset in file we need to map, iomap contains\n\t * the offset at which the map starts. If the map ends before the\n\t * current block, then do not map the buffer and let the caller\n\t * handle it.\n\t */\n\tBUG_ON(offset >= iomap->offset + iomap->length);\n\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/*\n\t\t * If the buffer is not up to date or beyond the current EOF,\n\t\t * we need to mark it as new to ensure sub-block zeroing is\n\t\t * executed if necessary.\n\t\t */\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tbreak;\n\tcase IOMAP_DELALLOC:\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_mapped(bh);\n\t\tset_buffer_delay(bh);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\t/*\n\t\t * For unwritten regions, we always need to ensure that regions\n\t\t * in the block we are not writing to are zeroed. Mark the\n\t\t * buffer as new to ensure this.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_unwritten(bh);\n\t\t/* FALLTHRU */\n\tcase IOMAP_MAPPED:\n\t\tif ((iomap->flags & IOMAP_F_NEW) ||\n\t\t    offset >= i_size_read(inode))\n\t\t\tset_buffer_new(bh);\n\t\tbh->b_blocknr = (iomap->addr + offset - iomap->offset) >>\n\t\t\t\tinode->i_blkbits;\n\t\tset_buffer_mapped(bh);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\niomap_to_bh(struct inode *inode, sector_t block, struct buffer_head *bh,\n\t\tstruct iomap *iomap)\n{\n\tloff_t offset = block << inode->i_blkbits;\n\n\tbh->b_bdev = iomap->bdev;\n\n\t/*\n\t * Block points to offset in file we need to map, iomap contains\n\t * the offset at which the map starts. If the map ends before the\n\t * current block, then do not map the buffer and let the caller\n\t * handle it.\n\t */\n\tBUG_ON(offset >= iomap->offset + iomap->length);\n\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/*\n\t\t * If the buffer is not up to date or beyond the current EOF,\n\t\t * we need to mark it as new to ensure sub-block zeroing is\n\t\t * executed if necessary.\n\t\t */\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tbreak;\n\tcase IOMAP_DELALLOC:\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_mapped(bh);\n\t\tset_buffer_delay(bh);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\t/*\n\t\t * For unwritten regions, we always need to ensure that regions\n\t\t * in the block we are not writing to are zeroed. Mark the\n\t\t * buffer as new to ensure this.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_unwritten(bh);\n\t\t/* FALLTHRU */\n\tcase IOMAP_MAPPED:\n\t\tif ((iomap->flags & IOMAP_F_NEW) ||\n\t\t    offset >= i_size_read(inode))\n\t\t\tset_buffer_new(bh);\n\t\tbh->b_blocknr = (iomap->addr + offset - iomap->offset) >>\n\t\t\t\tinode->i_blkbits;\n\t\tset_buffer_mapped(bh);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "bh",
            "1"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_size_bits",
          "args": [
            "blocksize"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1623-1626",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_page_buffers",
          "args": [
            "page",
            "inode",
            "0"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "create_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1628-1636",
          "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "from > to"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "to > PAGE_SIZE"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "from > PAGE_SIZE"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __block_write_begin_int(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block, struct iomap *iomap)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\tif (get_block) {\n\t\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tiomap_to_bh(inode, block, bh, iomap);\n\t\t\t}\n\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(REQ_OP_READ, 0, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
  },
  {
    "function_name": "iomap_to_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1873-1926",
    "snippet": "static void\niomap_to_bh(struct inode *inode, sector_t block, struct buffer_head *bh,\n\t\tstruct iomap *iomap)\n{\n\tloff_t offset = block << inode->i_blkbits;\n\n\tbh->b_bdev = iomap->bdev;\n\n\t/*\n\t * Block points to offset in file we need to map, iomap contains\n\t * the offset at which the map starts. If the map ends before the\n\t * current block, then do not map the buffer and let the caller\n\t * handle it.\n\t */\n\tBUG_ON(offset >= iomap->offset + iomap->length);\n\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/*\n\t\t * If the buffer is not up to date or beyond the current EOF,\n\t\t * we need to mark it as new to ensure sub-block zeroing is\n\t\t * executed if necessary.\n\t\t */\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tbreak;\n\tcase IOMAP_DELALLOC:\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_mapped(bh);\n\t\tset_buffer_delay(bh);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\t/*\n\t\t * For unwritten regions, we always need to ensure that regions\n\t\t * in the block we are not writing to are zeroed. Mark the\n\t\t * buffer as new to ensure this.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_unwritten(bh);\n\t\t/* FALLTHRU */\n\tcase IOMAP_MAPPED:\n\t\tif ((iomap->flags & IOMAP_F_NEW) ||\n\t\t    offset >= i_size_read(inode))\n\t\t\tset_buffer_new(bh);\n\t\tbh->b_blocknr = (iomap->addr + offset - iomap->offset) >>\n\t\t\t\tinode->i_blkbits;\n\t\tset_buffer_mapped(bh);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset >= iomap->offset + iomap->length"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\niomap_to_bh(struct inode *inode, sector_t block, struct buffer_head *bh,\n\t\tstruct iomap *iomap)\n{\n\tloff_t offset = block << inode->i_blkbits;\n\n\tbh->b_bdev = iomap->bdev;\n\n\t/*\n\t * Block points to offset in file we need to map, iomap contains\n\t * the offset at which the map starts. If the map ends before the\n\t * current block, then do not map the buffer and let the caller\n\t * handle it.\n\t */\n\tBUG_ON(offset >= iomap->offset + iomap->length);\n\n\tswitch (iomap->type) {\n\tcase IOMAP_HOLE:\n\t\t/*\n\t\t * If the buffer is not up to date or beyond the current EOF,\n\t\t * we need to mark it as new to ensure sub-block zeroing is\n\t\t * executed if necessary.\n\t\t */\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tbreak;\n\tcase IOMAP_DELALLOC:\n\t\tif (!buffer_uptodate(bh) ||\n\t\t    (offset >= i_size_read(inode)))\n\t\t\tset_buffer_new(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_mapped(bh);\n\t\tset_buffer_delay(bh);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\t/*\n\t\t * For unwritten regions, we always need to ensure that regions\n\t\t * in the block we are not writing to are zeroed. Mark the\n\t\t * buffer as new to ensure this.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_unwritten(bh);\n\t\t/* FALLTHRU */\n\tcase IOMAP_MAPPED:\n\t\tif ((iomap->flags & IOMAP_F_NEW) ||\n\t\t    offset >= i_size_read(inode))\n\t\t\tset_buffer_new(bh);\n\t\tbh->b_blocknr = (iomap->addr + offset - iomap->offset) >>\n\t\t\t\tinode->i_blkbits;\n\t\tset_buffer_mapped(bh);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "page_zero_new_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1836-1870",
    "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "start",
            "size"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "to",
            "block_end"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "from",
            "block_start"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_max_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "876-886",
          "snippet": "static sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
  },
  {
    "function_name": "__block_write_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1667-1828",
    "snippet": "int __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_flags = wbc_to_write_flags(wbc);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh_wbc",
          "args": [
            "REQ_OP_WRITE",
            "write_flags",
            "bh",
            "inode->i_write_hint",
            "wbc"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh_wbc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3040-3089",
          "snippet": "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint write_hint, struct writeback_control *wbc)\n{\n\tstruct bio *bio;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (op == REQ_OP_WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tif (wbc) {\n\t\twbc_init_bio(wbc, bio);\n\t\twbc_account_io(wbc, bh->b_page, bh->b_size);\n\t}\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio_set_dev(bio, bh->b_bdev);\n\tbio->bi_write_hint = write_hint;\n\n\tbio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n\tBUG_ON(bio->bi_iter.bi_size != bh->b_size);\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(op, bio);\n\n\tif (buffer_meta(bh))\n\t\top_flags |= REQ_META;\n\tif (buffer_prio(bh))\n\t\top_flags |= REQ_PRIO;\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tsubmit_bio(bio);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint write_hint, struct writeback_control *wbc)\n{\n\tstruct bio *bio;\n\n\tBUG_ON(!buffer_locked(bh));\n\tBUG_ON(!buffer_mapped(bh));\n\tBUG_ON(!bh->b_end_io);\n\tBUG_ON(buffer_delay(bh));\n\tBUG_ON(buffer_unwritten(bh));\n\n\t/*\n\t * Only clear out a write error when rewriting\n\t */\n\tif (test_set_buffer_req(bh) && (op == REQ_OP_WRITE))\n\t\tclear_buffer_write_io_error(bh);\n\n\t/*\n\t * from here on down, it's all bio -- do the initial mapping,\n\t * submit_bio -> generic_make_request may further map this bio around\n\t */\n\tbio = bio_alloc(GFP_NOIO, 1);\n\n\tif (wbc) {\n\t\twbc_init_bio(wbc, bio);\n\t\twbc_account_io(wbc, bh->b_page, bh->b_size);\n\t}\n\n\tbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\n\tbio_set_dev(bio, bh->b_bdev);\n\tbio->bi_write_hint = write_hint;\n\n\tbio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh));\n\tBUG_ON(bio->bi_iter.bi_size != bh->b_size);\n\n\tbio->bi_end_io = end_bio_bh_io_sync;\n\tbio->bi_private = bh;\n\n\t/* Take care of bh's that straddle the end of the device */\n\tguard_bio_eod(op, bio);\n\n\tif (buffer_meta(bh))\n\t\top_flags |= REQ_META;\n\tif (buffer_prio(bh))\n\t\top_flags |= REQ_PRIO;\n\tbio_set_op_attrs(bio, op, op_flags);\n\n\tsubmit_bio(bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "391-394",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "333-344",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH)\n\t\tset_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH)\n\t\tset_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "page->mapping",
            "err"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_async_write_endio",
          "args": [
            "bh",
            "handler"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "384-389",
          "snippet": "static void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "346-360",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tbool is_done;\n\n\tis_done = nfs_page_group_sync_on_bit(req, PG_WB_END);\n\tnfs_unlock_request(req);\n\tif (!is_done)\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tbool is_done;\n\n\tis_done = nfs_page_group_sync_on_bit(req, PG_WB_END);\n\tnfs_unlock_request(req);\n\tif (!is_done)\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_bdev_bh_alias",
          "args": [
            "bh"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "bh",
            "1"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "152-160",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bh->b_size != blocksize"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_size_bits",
          "args": [
            "blocksize"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1623-1626",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_page_buffers",
          "args": [
            "page",
            "inode",
            "(1 << BH_Dirty)|(1 << BH_Uptodate)"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "create_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1628-1636",
          "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbc_to_write_flags",
          "args": [
            "wbc"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,\n\t\t\t enum rw_hint hint, struct writeback_control *wbc);\n\nint __block_write_full_page(struct inode *inode, struct page *page,\n\t\t\tget_block_t *get_block, struct writeback_control *wbc,\n\t\t\tbh_end_io_t *handler)\n{\n\tint err;\n\tsector_t block;\n\tsector_t last_block;\n\tstruct buffer_head *bh, *head;\n\tunsigned int blocksize, bbits;\n\tint nr_underway = 0;\n\tint write_flags = wbc_to_write_flags(wbc);\n\n\thead = create_page_buffers(page, inode,\n\t\t\t\t\t(1 << BH_Dirty)|(1 << BH_Uptodate));\n\n\t/*\n\t * Be very careful.  We have no exclusion from __set_page_dirty_buffers\n\t * here, and the (potentially unmapped) buffers may become dirty at\n\t * any time.  If a buffer becomes dirty here after we've inspected it\n\t * then we just miss that fact, and the page stays dirty.\n\t *\n\t * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;\n\t * handle that here by just cleaning them.\n\t */\n\n\tbh = head;\n\tblocksize = bh->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\tlast_block = (i_size_read(inode) - 1) >> bbits;\n\n\t/*\n\t * Get all the dirty buffers mapped to disk addresses and\n\t * handle any aliases from the underlying blockdev's mapping.\n\t */\n\tdo {\n\t\tif (block > last_block) {\n\t\t\t/*\n\t\t\t * mapped buffers outside i_size will occur, because\n\t\t\t * this page can be outside i_size when there is a\n\t\t\t * truncate in progress.\n\t\t\t */\n\t\t\t/*\n\t\t\t * The buffer was zeroed by block_write_full_page()\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t} else if ((!buffer_mapped(bh) || buffer_delay(bh)) &&\n\t\t\t   buffer_dirty(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tgoto recover;\n\t\t\tclear_buffer_delay(bh);\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\t/* blockdev mappings never come here */\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclean_bdev_bh_alias(bh);\n\t\t\t}\n\t\t}\n\t\tbh = bh->b_this_page;\n\t\tblock++;\n\t} while (bh != head);\n\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tcontinue;\n\t\t/*\n\t\t * If it's a fully non-blocking write attempt and we cannot\n\t\t * lock the buffer then redirty the page.  Note that this can\n\t\t * potentially cause a busy-wait loop from writeback threads\n\t\t * and kswapd activity, but those code paths have their own\n\t\t * higher-level throttling.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\tlock_buffer(bh);\n\t\t} else if (!trylock_buffer(bh)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tcontinue;\n\t\t}\n\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\tunlock_buffer(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/*\n\t * The page and its buffers are protected by PageWriteback(), so we can\n\t * drop the bh refcounts early.\n\t */\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\n\terr = 0;\ndone:\n\tif (nr_underway == 0) {\n\t\t/*\n\t\t * The page was marked dirty, but the buffers were\n\t\t * clean.  Someone wrote them back by hand with\n\t\t * ll_rw_block/submit_bh.  A rare case.\n\t\t */\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * The page and buffer_heads can be released at any time from\n\t\t * here on.\n\t\t */\n\t}\n\treturn err;\n\nrecover:\n\t/*\n\t * ENOSPC, or some other error.  We may already have added some\n\t * blocks to the file, so we need to write these out to avoid\n\t * exposing stale data.\n\t * The page is currently locked and not marked for writeback\n\t */\n\tbh = head;\n\t/* Recovery: lock and submit the mapped buffers */\n\tdo {\n\t\tif (buffer_mapped(bh) && buffer_dirty(bh) &&\n\t\t    !buffer_delay(bh)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmark_buffer_async_write_endio(bh, handler);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The buffer may have been set dirty during\n\t\t\t * attachment to a dirty page.\n\t\t\t */\n\t\t\tclear_buffer_dirty(bh);\n\t\t}\n\t} while ((bh = bh->b_this_page) != head);\n\tSetPageError(page);\n\tBUG_ON(PageWriteback(page));\n\tmapping_set_error(page->mapping, err);\n\tset_page_writeback(page);\n\tdo {\n\t\tstruct buffer_head *next = bh->b_this_page;\n\t\tif (buffer_async_write(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tsubmit_bh_wbc(REQ_OP_WRITE, write_flags, bh,\n\t\t\t\t\tinode->i_write_hint, wbc);\n\t\t\tnr_underway++;\n\t\t}\n\t\tbh = next;\n\t} while (bh != head);\n\tunlock_page(page);\n\tgoto done;\n}"
  },
  {
    "function_name": "create_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1628-1636",
    "snippet": "static struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "1 << READ_ONCE(inode->i_blkbits)",
            "b_state"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1511-1538",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "inode->i_blkbits"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *create_page_buffers(struct page *page, struct inode *inode, unsigned int b_state)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, 1 << READ_ONCE(inode->i_blkbits),\n\t\t\t\t     b_state);\n\treturn page_buffers(page);\n}"
  },
  {
    "function_name": "block_size_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1623-1626",
    "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "blocksize"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "ilog2_w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/compression.c",
          "lines": "1237-1240",
          "snippet": "static inline u32 ilog2_w(u64 n)\n{\n\treturn ilog2(n * n * n * n);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/log2.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/log2.h>\n#include <linux/sched/mm.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline u32 ilog2_w(u64 n)\n{\n\treturn ilog2(n * n * n * n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
  },
  {
    "function_name": "clean_bdev_aliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1561-1612",
    "snippet": "void clean_bdev_aliases(struct block_device *bdev, sector_t block, sector_t len)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = block >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpgoff_t end;\n\tint i, count;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\n\tend = (block + len - 1) >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpagevec_init(&pvec);\n\twhile (pagevec_lookup_range(&pvec, bd_mapping, &index, end)) {\n\t\tcount = pagevec_count(&pvec);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (!page_has_buffers(page))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We use page lock instead of bd_mapping->private_lock\n\t\t\t * to pin buffers here since we can afford to sleep and\n\t\t\t * it scales better than a global spinlock lock.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\t/* Recheck when the page is locked which pins bhs */\n\t\t\tif (!page_has_buffers(page))\n\t\t\t\tgoto unlock_page;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tif (!buffer_mapped(bh) || (bh->b_blocknr < block))\n\t\t\t\t\tgoto next;\n\t\t\t\tif (bh->b_blocknr >= block + len)\n\t\t\t\t\tbreak;\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tclear_buffer_req(bh);\nnext:\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh != head);\nunlock_page:\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\t/* End of range already reached? */\n\t\tif (index > end || !index)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/hugetlbfs/inode.c",
          "lines": "101-109",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/falloc.h>",
            "#include <linux/sched/signal.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/falloc.h>\n#include <linux/sched/signal.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "bh"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_range",
          "args": [
            "&pvec",
            "bd_mapping",
            "&index",
            "end"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid clean_bdev_aliases(struct block_device *bdev, sector_t block, sector_t len)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = block >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpgoff_t end;\n\tint i, count;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\n\tend = (block + len - 1) >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpagevec_init(&pvec);\n\twhile (pagevec_lookup_range(&pvec, bd_mapping, &index, end)) {\n\t\tcount = pagevec_count(&pvec);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (!page_has_buffers(page))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We use page lock instead of bd_mapping->private_lock\n\t\t\t * to pin buffers here since we can afford to sleep and\n\t\t\t * it scales better than a global spinlock lock.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\t/* Recheck when the page is locked which pins bhs */\n\t\t\tif (!page_has_buffers(page))\n\t\t\t\tgoto unlock_page;\n\t\t\thead = page_buffers(page);\n\t\t\tbh = head;\n\t\t\tdo {\n\t\t\t\tif (!buffer_mapped(bh) || (bh->b_blocknr < block))\n\t\t\t\t\tgoto next;\n\t\t\t\tif (bh->b_blocknr >= block + len)\n\t\t\t\t\tbreak;\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tclear_buffer_req(bh);\nnext:\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh != head);\nunlock_page:\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t\t/* End of range already reached? */\n\t\tif (index > end || !index)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "create_empty_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1511-1538",
    "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "blocksize",
            "true"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "812-859",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, true);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
  },
  {
    "function_name": "block_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1456-1502",
    "snippet": "void block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (length == PAGE_SIZE)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "0"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_buffer",
          "args": [
            "bh"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "discard_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1422-1438",
          "snippet": "static void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)\n\nstatic void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stop > PAGE_SIZE || stop < length"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (length == PAGE_SIZE)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "discard_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1422-1438",
    "snippet": "static void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&bh->b_state",
            "b_state",
            "(b_state & ~BUFFER_FLAGS_DISCARD)"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUFFER_FLAGS_DISCARD \\\n\t(1 << BH_Mapped | 1 << BH_New | 1 << BH_Req | \\\n\t 1 << BH_Delay | 1 << BH_Unwritten)\n\nstatic void discard_buffer(struct buffer_head * bh)\n{\n\tunsigned long b_state, b_state_old;\n\n\tlock_buffer(bh);\n\tclear_buffer_dirty(bh);\n\tbh->b_bdev = NULL;\n\tb_state = bh->b_state;\n\tfor (;;) {\n\t\tb_state_old = cmpxchg(&bh->b_state, b_state,\n\t\t\t\t      (b_state & ~BUFFER_FLAGS_DISCARD));\n\t\tif (b_state_old == b_state)\n\t\t\tbreak;\n\t\tb_state = b_state_old;\n\t}\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "set_bh_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1398-1410",
    "snippet": "void set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset >= PAGE_SIZE"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}"
  },
  {
    "function_name": "invalidate_bh_lrus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1392-1395",
    "snippet": "void invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_each_cpu_cond",
          "args": [
            "has_bh_in_lru",
            "invalidate_bh_lru",
            "NULL",
            "1",
            "GFP_KERNEL"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}"
  },
  {
    "function_name": "has_bh_in_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1379-1390",
    "snippet": "static bool has_bh_in_lru(int cpu, void *dummy)\n{\n\tstruct bh_lru *b = per_cpu_ptr(&bh_lrus, cpu);\n\tint i;\n\t\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tif (b->bhs[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&bh_lrus",
            "cpu"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic bool has_bh_in_lru(int cpu, void *dummy)\n{\n\tstruct bh_lru *b = per_cpu_ptr(&bh_lrus, cpu);\n\tint i;\n\t\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tif (b->bhs[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "invalidate_bh_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1367-1377",
    "snippet": "static void invalidate_bh_lru(void *arg)\n{\n\tstruct bh_lru *b = &get_cpu_var(bh_lrus);\n\tint i;\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tput_cpu_var(bh_lrus);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "bh_lrus"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "b->bhs[i]"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "bh_lrus"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic void invalidate_bh_lru(void *arg)\n{\n\tstruct bh_lru *b = &get_cpu_var(bh_lrus);\n\tint i;\n\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tbrelse(b->bhs[i]);\n\t\tb->bhs[i] = NULL;\n\t}\n\tput_cpu_var(bh_lrus);\n}"
  },
  {
    "function_name": "__bread_gfp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1350-1359",
    "snippet": "struct buffer_head *\n__bread_gfp(struct block_device *bdev, sector_t block,\n\t\t   unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __getblk_gfp(bdev, block, size, gfp);\n\n\tif (likely(bh) && !buffer_uptodate(bh))\n\t\tbh = __bread_slow(bh);\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bread_slow",
          "args": [
            "bh"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "__bread_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1166-1182",
          "snippet": "static struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bh"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk_gfp",
          "args": [
            "bdev",
            "block",
            "size",
            "gfp"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "__getblk_gfp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1312-1322",
          "snippet": "struct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__bread_gfp(struct block_device *bdev, sector_t block,\n\t\t   unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __getblk_gfp(bdev, block, size, gfp);\n\n\tif (likely(bh) && !buffer_uptodate(bh))\n\t\tbh = __bread_slow(bh);\n\treturn bh;\n}"
  },
  {
    "function_name": "__breadahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1328-1335",
    "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(REQ_OP_READ, REQ_RAHEAD, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "REQ_OP_READ",
            "REQ_RAHEAD",
            "1",
            "&bh"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3123-3149",
          "snippet": "void ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bh"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(REQ_OP_READ, REQ_RAHEAD, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
  },
  {
    "function_name": "__getblk_gfp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1312-1322",
    "snippet": "struct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__getblk_slow",
          "args": [
            "bdev",
            "block",
            "size",
            "gfp"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "__getblk_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1019-1047",
          "snippet": "static struct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1287-1301",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);\n\treturn bh;\n}"
  },
  {
    "function_name": "__find_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1287-1301",
    "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "touch_buffer",
          "args": [
            "bh"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "touch_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "56-60",
          "snippet": "inline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\ninline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_lru_install",
          "args": [
            "bh"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "bh_lru_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1226-1247",
          "snippet": "static void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = bh;\n\tstruct bh_lru *b;\n\tint i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\n\tb = this_cpu_ptr(&bh_lrus);\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tswap(evictee, b->bhs[i]);\n\t\tif (evictee == bh) {\n\t\t\tbh_lru_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tget_bh(bh);\n\tbh_lru_unlock();\n\tbrelse(evictee);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BH_LRU_SIZE\t16"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = bh;\n\tstruct bh_lru *b;\n\tint i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\n\tb = this_cpu_ptr(&bh_lrus);\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tswap(evictee, b->bhs[i]);\n\t\tif (evictee == bh) {\n\t\t\tbh_lru_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tget_bh(bh);\n\tbh_lru_unlock();\n\tbrelse(evictee);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block_slow",
          "args": [
            "bdev",
            "block"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "192-245",
          "snippet": "static struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %pg blocksize: %d\\n\", bdev,\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tput_page(page);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %pg blocksize: %d\\n\", bdev,\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tput_page(page);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_bh_lru",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_bh_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1252-1280",
          "snippet": "static struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BH_LRU_SIZE\t16"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
  },
  {
    "function_name": "lookup_bh_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1252-1280",
    "snippet": "static struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bh_lru_unlock",
          "args": [],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "bh_lrus.bhs[0]",
            "bh"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "bh_lrus.bhs[i]",
            "__this_cpu_read(bh_lrus.bhs[i - 1])"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bh_lrus.bhs[i - 1]"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bh_lrus.bhs[i]"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_lru_lock",
          "args": [],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irqs_on",
          "args": [],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "check_irqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1214-1219",
          "snippet": "static inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic struct buffer_head *\nlookup_bh_lru(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *ret = NULL;\n\tunsigned int i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tstruct buffer_head *bh = __this_cpu_read(bh_lrus.bhs[i]);\n\n\t\tif (bh && bh->b_blocknr == block && bh->b_bdev == bdev &&\n\t\t    bh->b_size == size) {\n\t\t\tif (i) {\n\t\t\t\twhile (i) {\n\t\t\t\t\t__this_cpu_write(bh_lrus.bhs[i],\n\t\t\t\t\t\t__this_cpu_read(bh_lrus.bhs[i - 1]));\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t__this_cpu_write(bh_lrus.bhs[0], bh);\n\t\t\t}\n\t\t\tget_bh(bh);\n\t\t\tret = bh;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbh_lru_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "bh_lru_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1226-1247",
    "snippet": "static void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = bh;\n\tstruct bh_lru *b;\n\tint i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\n\tb = this_cpu_ptr(&bh_lrus);\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tswap(evictee, b->bhs[i]);\n\t\tif (evictee == bh) {\n\t\t\tbh_lru_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tget_bh(bh);\n\tbh_lru_unlock();\n\tbrelse(evictee);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BH_LRU_SIZE\t16"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "evictee"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_lru_unlock",
          "args": [],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_lru_unlock",
          "args": [],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "evictee",
            "b->bhs[i]"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2632-2673",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bh_lrus"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_lru_lock",
          "args": [],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irqs_on",
          "args": [],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "check_irqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1214-1219",
          "snippet": "static inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BH_LRU_SIZE\t16\n\nstatic DEFINE_PER_CPU(struct bh_lru, bh_lrus) = {{ NULL }};\n\nstatic void bh_lru_install(struct buffer_head *bh)\n{\n\tstruct buffer_head *evictee = bh;\n\tstruct bh_lru *b;\n\tint i;\n\n\tcheck_irqs_on();\n\tbh_lru_lock();\n\n\tb = this_cpu_ptr(&bh_lrus);\n\tfor (i = 0; i < BH_LRU_SIZE; i++) {\n\t\tswap(evictee, b->bhs[i]);\n\t\tif (evictee == bh) {\n\t\t\tbh_lru_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tget_bh(bh);\n\tbh_lru_unlock();\n\tbrelse(evictee);\n}"
  },
  {
    "function_name": "check_irqs_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1214-1219",
    "snippet": "static inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irqs_disabled()"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline void check_irqs_on(void)\n{\n#ifdef irqs_disabled\n\tBUG_ON(irqs_disabled());\n#endif\n}"
  },
  {
    "function_name": "__bread_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1166-1182",
    "snippet": "static struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "REQ_OP_READ",
            "0",
            "bh"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3091-3094",
          "snippet": "int submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint submit_bh(int op, int op_flags, struct buffer_head *bh)\n{\n\treturn submit_bh_wbc(op, op_flags, bh, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *__bread_slow(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t} else {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t\twait_on_buffer(bh);\n\t\tif (buffer_uptodate(bh))\n\t\t\treturn bh;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__bforget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1151-1163",
    "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
  },
  {
    "function_name": "__brelse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1137-1144",
    "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\""
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "buf"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&buf->b_count"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
  },
  {
    "function_name": "mark_buffer_write_io_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1119-1127",
    "snippet": "void mark_buffer_write_io_error(struct buffer_head *bh)\n{\n\tset_buffer_write_io_error(bh);\n\t/* FIXME: do we need to set this in both places? */\n\tif (bh->b_page && bh->b_page->mapping)\n\t\tmapping_set_error(bh->b_page->mapping, -EIO);\n\tif (bh->b_assoc_map)\n\t\tmapping_set_error(bh->b_assoc_map, -EIO);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "bh->b_assoc_map",
            "-EIO"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "bh->b_page->mapping",
            "-EIO"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_write_io_error(struct buffer_head *bh)\n{\n\tset_buffer_write_io_error(bh);\n\t/* FIXME: do we need to set this in both places? */\n\tif (bh->b_page && bh->b_page->mapping)\n\t\tmapping_set_error(bh->b_page->mapping, -EIO);\n\tif (bh->b_assoc_map)\n\t\tmapping_set_error(bh->b_assoc_map, -EIO);\n}"
  },
  {
    "function_name": "mark_buffer_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1084-1116",
    "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2107-2217",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty",
          "args": [
            "page",
            "mapping",
            "0"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "573-586",
          "snippet": "void __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_memcg",
          "args": [
            "page"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_block_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
  },
  {
    "function_name": "__getblk_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "1019-1047",
    "snippet": "static struct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grow_buffers",
          "args": [
            "bdev",
            "block",
            "size",
            "gfp"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "grow_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "990-1017",
          "snippet": "static int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %pg\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdev);\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %pg\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdev);\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "block",
            "size"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1287-1301",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"logical block size: %d\\n\"",
            "bdev_logical_block_size(bdev)"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *\n__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "grow_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "990-1017",
    "snippet": "static int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %pg\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdev);\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grow_dev_page",
          "args": [
            "bdev",
            "block",
            "index",
            "size",
            "sizebits",
            "gfp"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "grow_dev_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "926-984",
          "snippet": "static int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, true);\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tput_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, true);\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tput_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %pg\\n\"",
            "__func__",
            "(unsigned long long)block",
            "bdev"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index != block >> sizebits"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_buffers(struct block_device *bdev, sector_t block, int size, gfp_t gfp)\n{\n\tpgoff_t index;\n\tint sizebits;\n\n\tsizebits = -1;\n\tdo {\n\t\tsizebits++;\n\t} while ((size << sizebits) < PAGE_SIZE);\n\n\tindex = block >> sizebits;\n\n\t/*\n\t * Check for a block which wants to lie outside our maximum possible\n\t * pagecache index.  (this comparison is done using sector_t types).\n\t */\n\tif (unlikely(index != block >> sizebits)) {\n\t\tprintk(KERN_ERR \"%s: requested out-of-range block %llu for \"\n\t\t\t\"device %pg\\n\",\n\t\t\t__func__, (unsigned long long)block,\n\t\t\tbdev);\n\t\treturn -EIO;\n\t}\n\n\t/* Create a page with the proper size buffers.. */\n\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);\n}"
  },
  {
    "function_name": "grow_dev_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "926-984",
    "snippet": "static int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, true);\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tput_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_mapping->private_lock"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_page_buffers",
          "args": [
            "page",
            "bdev",
            "(sector_t)index << sizebits",
            "size"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "init_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "891-919",
          "snippet": "static sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tbh->b_end_io = NULL;\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tbh->b_end_io = NULL;\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_dev_buffers",
          "args": [
            "page",
            "bh"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "link_dev_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "862-874",
          "snippet": "static inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_mapping->private_lock"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_buffers",
          "args": [
            "page",
            "size",
            "true"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "812-859",
          "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3249-3295",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index",
            "gfp_mask"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_constraint",
          "args": [
            "inode->i_mapping",
            "~__GFP_FS"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int\ngrow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\t\t/* Will call free_more_memory() */\n\tgfp_t gfp_mask;\n\n\tgfp_mask = mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (page_has_buffers(page)) {\n\t\tbh = page_buffers(page);\n\t\tif (bh->b_size == size) {\n\t\t\tend_block = init_page_buffers(page, bdev,\n\t\t\t\t\t\t(sector_t)index << sizebits,\n\t\t\t\t\t\tsize);\n\t\t\tgoto done;\n\t\t}\n\t\tif (!try_to_free_buffers(page))\n\t\t\tgoto failed;\n\t}\n\n\t/*\n\t * Allocate some buffers for this page\n\t */\n\tbh = alloc_page_buffers(page, size, true);\n\n\t/*\n\t * Link the page to the buffers and initialise them.  Take the\n\t * lock to be atomic wrt __find_get_block(), which does not\n\t * run under the page lock.\n\t */\n\tspin_lock(&inode->i_mapping->private_lock);\n\tlink_dev_buffers(page, bh);\n\tend_block = init_page_buffers(page, bdev, (sector_t)index << sizebits,\n\t\t\tsize);\n\tspin_unlock(&inode->i_mapping->private_lock);\ndone:\n\tret = (block < end_block) ? 1 : -ENXIO;\nfailed:\n\tunlock_page(page);\n\tput_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "891-919",
    "snippet": "static sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tbh->b_end_io = NULL;\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_max_block",
          "args": [
            "I_BDEV(bdev->bd_inode)",
            "size"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_max_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "876-886",
          "snippet": "static sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "51-54",
          "snippet": "struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic sector_t\ninit_page_buffers(struct page *page, struct block_device *bdev,\n\t\t\tsector_t block, int size)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tstruct buffer_head *bh = head;\n\tint uptodate = PageUptodate(page);\n\tsector_t end_block = blkdev_max_block(I_BDEV(bdev->bd_inode), size);\n\n\tdo {\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tbh->b_end_io = NULL;\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_bdev = bdev;\n\t\t\tbh->b_blocknr = block;\n\t\t\tif (uptodate)\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (block < end_block)\n\t\t\t\tset_buffer_mapped(bh);\n\t\t}\n\t\tblock++;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/*\n\t * Caller needs to validate requested block against end of device.\n\t */\n\treturn end_block;\n}"
  },
  {
    "function_name": "blkdev_max_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "876-886",
    "snippet": "static sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "size"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic sector_t blkdev_max_block(struct block_device *bdev, unsigned int size)\n{\n\tsector_t retval = ~((sector_t)0);\n\tloff_t sz = i_size_read(bdev->bd_inode);\n\n\tif (sz) {\n\t\tunsigned int sizebits = blksize_bits(size);\n\t\tretval = (sz >> sizebits);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "link_dev_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "862-874",
    "snippet": "static inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attach_page_buffers",
          "args": [
            "page",
            "head"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline void\nlink_dev_buffers(struct page *page, struct buffer_head *head)\n{\n\tstruct buffer_head *bh, *tail;\n\n\tbh = head;\n\tdo {\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\tattach_page_buffers(page, head);\n}"
  },
  {
    "function_name": "alloc_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "812-859",
    "snippet": "struct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_buffer_head",
          "args": [
            "bh"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_put",
          "args": [
            "memcg"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memalloc_unuse_memcg",
          "args": [],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bh_page",
          "args": [
            "bh",
            "page",
            "offset"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "set_bh_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1398-1410",
          "snippet": "void set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_buffer_head",
          "args": [
            "gfp"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memalloc_use_memcg",
          "args": [
            "memcg"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mem_cgroup_from_page",
          "args": [
            "page"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *alloc_page_buffers(struct page *page, unsigned long size,\n\t\tbool retry)\n{\n\tstruct buffer_head *bh, *head;\n\tgfp_t gfp = GFP_NOFS | __GFP_ACCOUNT;\n\tlong offset;\n\tstruct mem_cgroup *memcg;\n\n\tif (retry)\n\t\tgfp |= __GFP_NOFAIL;\n\n\tmemcg = get_mem_cgroup_from_page(page);\n\tmemalloc_use_memcg(memcg);\n\n\thead = NULL;\n\toffset = PAGE_SIZE;\n\twhile ((offset -= size) >= 0) {\n\t\tbh = alloc_buffer_head(gfp);\n\t\tif (!bh)\n\t\t\tgoto no_grow;\n\n\t\tbh->b_this_page = head;\n\t\tbh->b_blocknr = -1;\n\t\thead = bh;\n\n\t\tbh->b_size = size;\n\n\t\t/* Link the buffer to its page */\n\t\tset_bh_page(bh, page, offset);\n\t}\nout:\n\tmemalloc_unuse_memcg();\n\tmem_cgroup_put(memcg);\n\treturn head;\n/*\n * In case anything failed, we just free everything we got.\n */\nno_grow:\n\tif (head) {\n\t\tdo {\n\t\t\tbh = head;\n\t\t\thead = head->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t} while (head);\n\t}\n\n\tgoto out;\n}"
  },
  {
    "function_name": "remove_inode_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "780-801",
    "snippet": "int remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "bh"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "450-455",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "list->next"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "457-460",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nint remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "invalidate_inode_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "759-771",
    "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "BH_ENTRY(list->next)"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "450-455",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "list->next"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "457-460",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
  },
  {
    "function_name": "fsync_buffers_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "671-748",
    "snippet": "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, REQ_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "osync_buffers_list",
          "args": [
            "lock",
            "list"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "osync_buffers_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "472-495",
          "snippet": "static int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bh->b_assoc_buffers",
            "&mapping->private_list"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_assoc_queue",
          "args": [
            "bh"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_assoc_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "450-455",
          "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "tmp.prev"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "bh",
            "REQ_SYNC"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3152-3162",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_WRITE, op_flags, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int op_flags)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_WRITE, op_flags, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "list->next"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, REQ_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}"
  },
  {
    "function_name": "__set_page_dirty_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "614-649",
    "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2107-2217",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page_memcg",
          "args": [
            "page"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty",
          "args": [
            "page",
            "mapping",
            "1"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "573-586",
          "snippet": "void __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_memcg",
          "args": [
            "page"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mapping"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\t/*\n\t * Lock out page->mem_cgroup migration to keep PageDirty\n\t * synchronized with per-memcg dirty page counters.\n\t */\n\tlock_page_memcg(page);\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\n\tunlock_page_memcg(page);\n\n\tif (newly_dirty)\n\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\treturn newly_dirty;\n}"
  },
  {
    "function_name": "__set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "573-586",
    "snippet": "void __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_unlock_irqrestore",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xa_set_mark",
          "args": [
            "&mapping->i_pages",
            "page_index(page)",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_page_dirtied",
          "args": [
            "page",
            "mapping"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "warn && !PageUptodate(page)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irqsave",
          "args": [
            "&mapping->i_pages",
            "flags"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __set_page_dirty(struct page *page, struct address_space *mapping,\n\t\t\t     int warn)\n{\n\tunsigned long flags;\n\n\txa_lock_irqsave(&mapping->i_pages, flags);\n\tif (page->mapping) {\t/* Race with truncate? */\n\t\tWARN_ON_ONCE(warn && !PageUptodate(page));\n\t\taccount_page_dirtied(page, mapping);\n\t\t__xa_set_mark(&mapping->i_pages, page_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t}\n\txa_unlock_irqrestore(&mapping->i_pages, flags);\n}"
  },
  {
    "function_name": "mark_buffer_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "543-561",
    "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&bh->b_assoc_buffers",
            "&mapping->private_list"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&buffer_mapping->private_lock"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mapping->private_data != buffer_mapping"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
  },
  {
    "function_name": "write_boundary_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "532-541",
    "snippet": "void write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(REQ_OP_WRITE, 0, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "REQ_OP_WRITE",
            "0",
            "1",
            "&bh"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "3123-3149",
          "snippet": "void ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int op, int op_flags,  int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (op == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(op, op_flags, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_get_block",
          "args": [
            "bdev",
            "bblock + 1",
            "blocksize"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__find_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1287-1301",
          "snippet": "struct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstruct buffer_head *\n__find_get_block(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = lookup_bh_lru(bdev, block, size);\n\n\tif (bh == NULL) {\n\t\t/* __find_get_block_slow will mark the page accessed */\n\t\tbh = __find_get_block_slow(bdev, block);\n\t\tif (bh)\n\t\t\tbh_lru_install(bh);\n\t} else\n\t\ttouch_buffer(bh);\n\n\treturn bh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid write_boundary_block(struct block_device *bdev,\n\t\t\tsector_t bblock, unsigned blocksize)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, bblock + 1, blocksize);\n\tif (bh) {\n\t\tif (buffer_dirty(bh))\n\t\t\tll_rw_block(REQ_OP_WRITE, 0, 1, &bh);\n\t\tput_bh(bh);\n\t}\n}"
  },
  {
    "function_name": "sync_mapping_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "514-523",
    "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsync_buffers_list",
          "args": [
            "&buffer_mapping->private_lock",
            "&mapping->private_list"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "fsync_buffers_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "671-748",
          "snippet": "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, REQ_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head tmp;\n\tstruct address_space *mapping;\n\tint err = 0, err2;\n\tstruct blk_plug plug;\n\n\tINIT_LIST_HEAD(&tmp);\n\tblk_start_plug(&plug);\n\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tbh = BH_ENTRY(list->next);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh) || buffer_locked(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers, &tmp);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tspin_unlock(lock);\n\t\t\t\t/*\n\t\t\t\t * Ensure any pending I/O completes so that\n\t\t\t\t * write_dirty_buffer() actually writes the\n\t\t\t\t * current contents - it is a noop if I/O is\n\t\t\t\t * still in flight on potentially older\n\t\t\t\t * contents.\n\t\t\t\t */\n\t\t\t\twrite_dirty_buffer(bh, REQ_SYNC);\n\n\t\t\t\t/*\n\t\t\t\t * Kick off IO for the previous mapping. Note\n\t\t\t\t * that we will not run the very last mapping,\n\t\t\t\t * wait_on_buffer() will do that for us\n\t\t\t\t * through sync_buffer().\n\t\t\t\t */\n\t\t\t\tbrelse(bh);\n\t\t\t\tspin_lock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(lock);\n\tblk_finish_plug(&plug);\n\tspin_lock(lock);\n\n\twhile (!list_empty(&tmp)) {\n\t\tbh = BH_ENTRY(tmp.prev);\n\t\tget_bh(bh);\n\t\tmapping = bh->b_assoc_map;\n\t\t__remove_assoc_queue(bh);\n\t\t/* Avoid race with mark_buffer_dirty_inode() which does\n\t\t * a lockless check and we rely on seeing the dirty bit */\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_add(&bh->b_assoc_buffers,\n\t\t\t\t &mapping->private_list);\n\t\t\tbh->b_assoc_map = mapping;\n\t\t}\n\t\tspin_unlock(lock);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\terr = -EIO;\n\t\tbrelse(bh);\n\t\tspin_lock(lock);\n\t}\n\t\n\tspin_unlock(lock);\n\terr2 = osync_buffers_list(lock, list);\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn err2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mapping->private_list"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
  },
  {
    "function_name": "emergency_thaw_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "497-501",
    "snippet": "void emergency_thaw_bdev(struct super_block *sb)\n{\n\twhile (sb->s_bdev && !thaw_bdev(sb->s_bdev, sb))\n\t\tprintk(KERN_WARNING \"Emergency Thaw on %pg\\n\", sb->s_bdev);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Emergency Thaw on %pg\\n\"",
            "sb->s_bdev"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_bdev",
          "args": [
            "sb->s_bdev",
            "sb"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "538-562",
          "snippet": "int thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error)\n\t\tbdev->bd_fsfreeze_count++;\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error)\n\t\tbdev->bd_fsfreeze_count++;\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid emergency_thaw_bdev(struct super_block *sb)\n{\n\twhile (sb->s_bdev && !thaw_bdev(sb->s_bdev, sb))\n\t\tprintk(KERN_WARNING \"Emergency Thaw on %pg\\n\", sb->s_bdev);\n}"
  },
  {
    "function_name": "osync_buffers_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "472-495",
    "snippet": "static int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "116-119",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BH_ENTRY",
          "args": [
            "p"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_prev",
          "args": [
            "p",
            "list"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nstatic int osync_buffers_list(spinlock_t *lock, struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tspin_lock(lock);\nrepeat:\n\tlist_for_each_prev(p, list) {\n\t\tbh = BH_ENTRY(p);\n\t\tif (buffer_locked(bh)) {\n\t\t\tget_bh(bh);\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\terr = -EIO;\n\t\t\tbrelse(bh);\n\t\t\tspin_lock(lock);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n\tspin_unlock(lock);\n\treturn err;\n}"
  },
  {
    "function_name": "inode_has_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "457-460",
    "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_data.private_list"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
  },
  {
    "function_name": "__remove_assoc_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "450-455",
    "snippet": "static void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!bh->b_assoc_map"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __remove_assoc_queue(struct buffer_head *bh)\n{\n\tlist_del_init(&bh->b_assoc_buffers);\n\tWARN_ON(!bh->b_assoc_map);\n\tbh->b_assoc_map = NULL;\n}"
  },
  {
    "function_name": "mark_buffer_async_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "391-394",
    "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_async_write_endio",
          "args": [
            "bh",
            "end_buffer_async_write"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "384-389",
          "snippet": "static void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
  },
  {
    "function_name": "mark_buffer_async_write_endio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "384-389",
    "snippet": "static void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_write_endio(struct buffer_head *bh,\n\t\t\t\t\t  bh_end_io_t *handler)\n{\n\tbh->b_end_io = handler;\n\tset_buffer_async_write(bh);\n}"
  },
  {
    "function_name": "mark_buffer_async_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "378-382",
    "snippet": "static void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_async_read",
          "args": [
            "bh"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}"
  },
  {
    "function_name": "end_buffer_async_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "312-354",
    "snippet": "void end_buffer_async_write(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\n\tBUG_ON(!buffer_async_write(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost async page write\");\n\t\tmark_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t}\n\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\n\tclear_buffer_async_write(bh);\n\tunlock_buffer(bh);\n\ttmp = bh->b_this_page;\n\twhile (tmp != bh) {\n\t\tif (buffer_async_write(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t}\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\tend_page_writeback(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "346-360",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tbool is_done;\n\n\tis_done = nfs_page_group_sync_on_bit(req, PG_WB_END);\n\tnfs_unlock_request(req);\n\tif (!is_done)\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\tbool is_done;\n\n\tis_done = nfs_page_group_sync_on_bit(req, PG_WB_END);\n\tnfs_unlock_request(req);\n\tif (!is_done)\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(tmp)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tmp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "tmp"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "391-394",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_lock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_write_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1119-1127",
          "snippet": "void mark_buffer_write_io_error(struct buffer_head *bh)\n{\n\tset_buffer_write_io_error(bh);\n\t/* FIXME: do we need to set this in both places? */\n\tif (bh->b_page && bh->b_page->mapping)\n\t\tmapping_set_error(bh->b_page->mapping, -EIO);\n\tif (bh->b_assoc_map)\n\t\tmapping_set_error(bh->b_assoc_map, -EIO);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_write_io_error(struct buffer_head *bh)\n{\n\tset_buffer_write_io_error(bh);\n\t/* FIXME: do we need to set this in both places? */\n\tif (bh->b_page && bh->b_page->mapping)\n\t\tmapping_set_error(bh->b_page->mapping, -EIO);\n\tif (bh->b_assoc_map)\n\t\tmapping_set_error(bh->b_assoc_map, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_io_error",
          "args": [
            "bh",
            "\", lost async page write\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "130-136",
          "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_async_write(bh)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid end_buffer_async_write(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\n\tBUG_ON(!buffer_async_write(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost async page write\");\n\t\tmark_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t\tSetPageError(page);\n\t}\n\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\n\tclear_buffer_async_write(bh);\n\tunlock_buffer(bh);\n\ttmp = bh->b_this_page;\n\twhile (tmp != bh) {\n\t\tif (buffer_async_write(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t}\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\tend_page_writeback(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
  },
  {
    "function_name": "end_buffer_async_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "251-306",
    "snippet": "static void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_unlock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_locked(tmp)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tmp"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_read",
          "args": [
            "tmp"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "378-382",
          "snippet": "static void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void mark_buffer_async_read(struct buffer_head *bh)\n{\n\tbh->b_end_io = end_buffer_async_read;\n\tset_buffer_async_read(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tmp"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/extent_io.h",
          "lines": "446-449",
          "snippet": "static inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"ulist.h\"",
            "#include <linux/refcount.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BUFFER_UPTODATE 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ulist.h\"\n#include <linux/refcount.h>\n#include <linux/rbtree.h>\n\n#define EXTENT_BUFFER_UPTODATE 0\n\nstatic inline int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_read",
          "args": [
            "bh"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_spin_lock",
          "args": [
            "BH_Uptodate_Lock",
            "&first->b_state"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_io_error",
          "args": [
            "bh",
            "\", async page read\""
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "130-136",
          "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_async_read(bh)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void end_buffer_async_read(struct buffer_head *bh, int uptodate)\n{\n\tunsigned long flags;\n\tstruct buffer_head *first;\n\tstruct buffer_head *tmp;\n\tstruct page *page;\n\tint page_uptodate = 1;\n\n\tBUG_ON(!buffer_async_read(bh));\n\n\tpage = bh->b_page;\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tclear_buffer_uptodate(bh);\n\t\tbuffer_io_error(bh, \", async page read\");\n\t\tSetPageError(page);\n\t}\n\n\t/*\n\t * Be _very_ careful from here on. Bad things can happen if\n\t * two buffer heads end IO at almost the same time and both\n\t * decide that the page is now completely done.\n\t */\n\tfirst = page_buffers(page);\n\tlocal_irq_save(flags);\n\tbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\n\tclear_buffer_async_read(bh);\n\tunlock_buffer(bh);\n\ttmp = bh;\n\tdo {\n\t\tif (!buffer_uptodate(tmp))\n\t\t\tpage_uptodate = 0;\n\t\tif (buffer_async_read(tmp)) {\n\t\t\tBUG_ON(!buffer_locked(tmp));\n\t\t\tgoto still_busy;\n\t\t}\n\t\ttmp = tmp->b_this_page;\n\t} while (tmp != bh);\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * If none of the buffers had errors and they are all\n\t * uptodate then we can set the page uptodate.\n\t */\n\tif (page_uptodate && !PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn;\n\nstill_busy:\n\tbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\n\tlocal_irq_restore(flags);\n\treturn;\n}"
  },
  {
    "function_name": "__find_get_block_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "192-245",
    "snippet": "static struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %pg blocksize: %d\\n\", bdev,\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tput_page(page);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bd_mapping->private_lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"device %pg blocksize: %d\\n\"",
            "bdev",
            "1 << bd_inode->i_blkbits"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bd_mapping->private_lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page_flags",
          "args": [
            "bd_mapping",
            "index",
            "FGP_ACCESSED"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct buffer_head *\n__find_get_block_slow(struct block_device *bdev, sector_t block)\n{\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tstruct address_space *bd_mapping = bd_inode->i_mapping;\n\tstruct buffer_head *ret = NULL;\n\tpgoff_t index;\n\tstruct buffer_head *bh;\n\tstruct buffer_head *head;\n\tstruct page *page;\n\tint all_mapped = 1;\n\n\tindex = block >> (PAGE_SHIFT - bd_inode->i_blkbits);\n\tpage = find_get_page_flags(bd_mapping, index, FGP_ACCESSED);\n\tif (!page)\n\t\tgoto out;\n\n\tspin_lock(&bd_mapping->private_lock);\n\tif (!page_has_buffers(page))\n\t\tgoto out_unlock;\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (!buffer_mapped(bh))\n\t\t\tall_mapped = 0;\n\t\telse if (bh->b_blocknr == block) {\n\t\t\tret = bh;\n\t\t\tget_bh(bh);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\n\t/* we might be here because some of the buffers on this page are\n\t * not mapped.  This is due to various races between\n\t * file io on the block device and getblk.  It gets dealt with\n\t * elsewhere, don't buffer_error if we had some unmapped buffers\n\t */\n\tif (all_mapped) {\n\t\tprintk(\"__find_get_block_slow() failed. \"\n\t\t\t\"block=%llu, b_blocknr=%llu\\n\",\n\t\t\t(unsigned long long)block,\n\t\t\t(unsigned long long)bh->b_blocknr);\n\t\tprintk(\"b_state=0x%08lx, b_size=%zu\\n\",\n\t\t\tbh->b_state, bh->b_size);\n\t\tprintk(\"device %pg blocksize: %d\\n\", bdev,\n\t\t\t1 << bd_inode->i_blkbits);\n\t}\nout_unlock:\n\tspin_unlock(&bd_mapping->private_lock);\n\tput_page(page);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "end_buffer_write_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "168-179",
    "snippet": "void end_buffer_write_sync(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost sync page write\");\n\t\tmark_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_write_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1119-1127",
          "snippet": "void mark_buffer_write_io_error(struct buffer_head *bh)\n{\n\tset_buffer_write_io_error(bh);\n\t/* FIXME: do we need to set this in both places? */\n\tif (bh->b_page && bh->b_page->mapping)\n\t\tmapping_set_error(bh->b_page->mapping, -EIO);\n\tif (bh->b_assoc_map)\n\t\tmapping_set_error(bh->b_assoc_map, -EIO);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_write_io_error(struct buffer_head *bh)\n{\n\tset_buffer_write_io_error(bh);\n\t/* FIXME: do we need to set this in both places? */\n\tif (bh->b_page && bh->b_page->mapping)\n\t\tmapping_set_error(bh->b_page->mapping, -EIO);\n\tif (bh->b_assoc_map)\n\t\tmapping_set_error(bh->b_assoc_map, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_io_error",
          "args": [
            "bh",
            "\", lost sync page write\""
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_io_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "130-136",
          "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid end_buffer_write_sync(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\tbuffer_io_error(bh, \", lost sync page write\");\n\t\tmark_buffer_write_io_error(bh);\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}"
  },
  {
    "function_name": "end_buffer_read_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "161-165",
    "snippet": "void end_buffer_read_sync(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n\tput_bh(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__end_buffer_read_notouch",
          "args": [
            "bh",
            "uptodate"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__end_buffer_read_notouch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "146-155",
          "snippet": "static void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed read-ahead attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed read-ahead attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid end_buffer_read_sync(struct buffer_head *bh, int uptodate)\n{\n\t__end_buffer_read_notouch(bh, uptodate);\n\tput_bh(bh);\n}"
  },
  {
    "function_name": "__end_buffer_read_notouch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "146-155",
    "snippet": "static void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed read-ahead attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "69-74",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __end_buffer_read_notouch(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate) {\n\t\tset_buffer_uptodate(bh);\n\t} else {\n\t\t/* This happens, due to failed read-ahead attempts. */\n\t\tclear_buffer_uptodate(bh);\n\t}\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "buffer_io_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "130-136",
    "snippet": "static void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\"",
            "bh->b_bdev",
            "(unsigned long long)bh->b_blocknr",
            "msg"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BH_Quiet",
            "&bh->b_state"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void buffer_io_error(struct buffer_head *bh, char *msg)\n{\n\tif (!test_bit(BH_Quiet, &bh->b_state))\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"Buffer I/O error on dev %pg, logical block %llu%s\\n\",\n\t\t\tbh->b_bdev, (unsigned long long)bh->b_blocknr, msg);\n}"
  },
  {
    "function_name": "__clear_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "122-128",
    "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
  },
  {
    "function_name": "__wait_on_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "116-119",
    "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_io",
          "args": [
            "&bh->b_state",
            "BH_Lock",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "buffer_check_dirty_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "82-108",
    "snippet": "void buffer_check_dirty_writeback(struct page *page,\n\t\t\t\t     bool *dirty, bool *writeback)\n{\n\tstruct buffer_head *head, *bh;\n\t*dirty = false;\n\t*writeback = false;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tif (PageWriteback(page))\n\t\t*writeback = true;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (buffer_locked(bh))\n\t\t\t*writeback = true;\n\n\t\tif (buffer_dirty(bh))\n\t\t\t*dirty = true;\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1084-1116",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tstruct address_space *mapping = NULL;\n\n\t\tlock_page_memcg(page);\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tmapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t\tunlock_page_memcg(page);\n\t\tif (mapping)\n\t\t\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "122-128",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid buffer_check_dirty_writeback(struct page *page,\n\t\t\t\t     bool *dirty, bool *writeback)\n{\n\tstruct buffer_head *head, *bh;\n\t*dirty = false;\n\t*writeback = false;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tif (PageWriteback(page))\n\t\t*writeback = true;\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tif (buffer_locked(bh))\n\t\t\t*writeback = true;\n\n\t\tif (buffer_dirty(bh))\n\t\t\t*dirty = true;\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
  },
  {
    "function_name": "unlock_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "69-74",
    "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&bh->b_state",
            "BH_Lock"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "BH_Lock",
            "&bh->b_state"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
  },
  {
    "function_name": "__lock_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "63-66",
    "snippet": "void __lock_buffer(struct buffer_head *bh)\n{\n\twait_on_bit_lock_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_lock_io",
          "args": [
            "&bh->b_state",
            "BH_Lock",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __lock_buffer(struct buffer_head *bh)\n{\n\twait_on_bit_lock_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "touch_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "56-60",
    "snippet": "inline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "bh->b_page"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_block_touch_buffer",
          "args": [
            "bh"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\ninline void touch_buffer(struct buffer_head *bh)\n{\n\ttrace_block_touch_buffer(bh);\n\tmark_page_accessed(bh->b_page);\n}"
  },
  {
    "function_name": "bdflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
    "lines": "3305-3323",
    "snippet": "SYSCALL_DEFINE2(bdflush, int, func, long, data)\n{\n\tstatic int msg_count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (msg_count < 5) {\n\t\tmsg_count++;\n\t\tprintk(KERN_INFO\n\t\t\t\"warning: process `%s' used the obsolete bdflush\"\n\t\t\t\" system call\\n\", current->comm);\n\t\tprintk(KERN_INFO \"Fix your initscripts?\\n\");\n\t}\n\n\tif (func == 1)\n\t\tdo_exit(0);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/block.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/mpage.h>",
      "#include <linux/bitops.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bio.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/suspend.h>",
      "#include <linux/hash.h>",
      "#include <linux/writeback.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/export.h>",
      "#include <linux/highmem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/file.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mm.h>",
      "#include <linux/iomap.h>",
      "#include <linux/fs.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE2(bdflush, int, func, long, data)\n{\n\tstatic int msg_count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (msg_count < 5) {\n\t\tmsg_count++;\n\t\tprintk(KERN_INFO\n\t\t\t\"warning: process `%s' used the obsolete bdflush\"\n\t\t\t\" system call\\n\", current->comm);\n\t\tprintk(KERN_INFO \"Fix your initscripts?\\n\");\n\t}\n\n\tif (func == 1)\n\t\tdo_exit(0);\n\treturn 0;\n}"
  }
]