[
  {
    "function_name": "kcompat_sys_fstatfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "357-369",
    "snippet": "int kcompat_sys_fstatfs64(unsigned int fd, compat_size_t sz, struct compat_statfs64 __user * buf)\n{\n\tstruct kstatfs tmp;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = fd_statfs(fd, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs64(buf, &tmp);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_compat_statfs64",
          "args": [
            "buf",
            "&tmp"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "put_compat_statfs64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "304-336",
          "snippet": "static int put_compat_statfs64(struct compat_statfs64 __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs64 buf;\n\tif (sizeof(ubuf->f_bsize) == 4) {\n\t\tif ((kbuf->f_type | kbuf->f_bsize | kbuf->f_namelen |\n\t\t     kbuf->f_frsize | kbuf->f_flags) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs64));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int put_compat_statfs64(struct compat_statfs64 __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs64 buf;\n\tif (sizeof(ubuf->f_bsize) == 4) {\n\t\tif ((kbuf->f_type | kbuf->f_bsize | kbuf->f_namelen |\n\t\t     kbuf->f_frsize | kbuf->f_flags) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs64));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_statfs",
          "args": [
            "fd",
            "&tmp"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "fd_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "99-108",
          "snippet": "int fd_statfs(int fd, struct kstatfs *st)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error = -EBADF;\n\tif (f.file) {\n\t\terror = vfs_statfs(&f.file->f_path, st);\n\t\tfdput(f);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint fd_statfs(int fd, struct kstatfs *st)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error = -EBADF;\n\tif (f.file) {\n\t\terror = vfs_statfs(&f.file->f_path, st);\n\t\tfdput(f);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint kcompat_sys_fstatfs64(unsigned int fd, compat_size_t sz, struct compat_statfs64 __user * buf)\n{\n\tstruct kstatfs tmp;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = fd_statfs(fd, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs64(buf, &tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "kcompat_sys_statfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "338-350",
    "snippet": "int kcompat_sys_statfs64(const char __user * pathname, compat_size_t sz, struct compat_statfs64 __user * buf)\n{\n\tstruct kstatfs tmp;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = user_statfs(pathname, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs64(buf, &tmp);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_compat_statfs64",
          "args": [
            "buf",
            "&tmp"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "put_compat_statfs64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "304-336",
          "snippet": "static int put_compat_statfs64(struct compat_statfs64 __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs64 buf;\n\tif (sizeof(ubuf->f_bsize) == 4) {\n\t\tif ((kbuf->f_type | kbuf->f_bsize | kbuf->f_namelen |\n\t\t     kbuf->f_frsize | kbuf->f_flags) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs64));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int put_compat_statfs64(struct compat_statfs64 __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs64 buf;\n\tif (sizeof(ubuf->f_bsize) == 4) {\n\t\tif ((kbuf->f_type | kbuf->f_bsize | kbuf->f_namelen |\n\t\t     kbuf->f_frsize | kbuf->f_flags) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs64));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_statfs",
          "args": [
            "pathname",
            "&tmp"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "user_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "81-97",
          "snippet": "int user_statfs(const char __user *pathname, struct kstatfs *st)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_statfs(&path, st);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint user_statfs(const char __user *pathname, struct kstatfs *st)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_statfs(&path, st);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint kcompat_sys_statfs64(const char __user * pathname, compat_size_t sz, struct compat_statfs64 __user * buf)\n{\n\tstruct kstatfs tmp;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = user_statfs(pathname, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs64(buf, &tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "put_compat_statfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "304-336",
    "snippet": "static int put_compat_statfs64(struct compat_statfs64 __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs64 buf;\n\tif (sizeof(ubuf->f_bsize) == 4) {\n\t\tif ((kbuf->f_type | kbuf->f_bsize | kbuf->f_namelen |\n\t\t     kbuf->f_frsize | kbuf->f_flags) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs64));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf",
            "&buf",
            "sizeof(struct compat_statfs64)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&buf",
            "0",
            "sizeof(struct compat_statfs64)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int put_compat_statfs64(struct compat_statfs64 __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs64 buf;\n\tif (sizeof(ubuf->f_bsize) == 4) {\n\t\tif ((kbuf->f_type | kbuf->f_bsize | kbuf->f_namelen |\n\t\t     kbuf->f_frsize | kbuf->f_flags) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs64));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "put_compat_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "248-280",
    "snippet": "static int put_compat_statfs(struct compat_statfs __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs buf;\n\tif (sizeof ubuf->f_blocks == 4) {\n\t\tif ((kbuf->f_blocks | kbuf->f_bfree | kbuf->f_bavail |\n\t\t     kbuf->f_bsize | kbuf->f_frsize) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf",
            "&buf",
            "sizeof(struct compat_statfs)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&buf",
            "0",
            "sizeof(struct compat_statfs)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int put_compat_statfs(struct compat_statfs __user *ubuf, struct kstatfs *kbuf)\n{\n\tstruct compat_statfs buf;\n\tif (sizeof ubuf->f_blocks == 4) {\n\t\tif ((kbuf->f_blocks | kbuf->f_bfree | kbuf->f_bavail |\n\t\t     kbuf->f_bsize | kbuf->f_frsize) & 0xffffffff00000000ULL)\n\t\t\treturn -EOVERFLOW;\n\t\t/* f_files and f_ffree may be -1; it's okay\n\t\t * to stuff that into 32 bits */\n\t\tif (kbuf->f_files != 0xffffffffffffffffULL\n\t\t && (kbuf->f_files & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t\tif (kbuf->f_ffree != 0xffffffffffffffffULL\n\t\t && (kbuf->f_ffree & 0xffffffff00000000ULL))\n\t\t\treturn -EOVERFLOW;\n\t}\n\tmemset(&buf, 0, sizeof(struct compat_statfs));\n\tbuf.f_type = kbuf->f_type;\n\tbuf.f_bsize = kbuf->f_bsize;\n\tbuf.f_blocks = kbuf->f_blocks;\n\tbuf.f_bfree = kbuf->f_bfree;\n\tbuf.f_bavail = kbuf->f_bavail;\n\tbuf.f_files = kbuf->f_files;\n\tbuf.f_ffree = kbuf->f_ffree;\n\tbuf.f_namelen = kbuf->f_namelen;\n\tbuf.f_fsid.val[0] = kbuf->f_fsid.val[0];\n\tbuf.f_fsid.val[1] = kbuf->f_fsid.val[1];\n\tbuf.f_frsize = kbuf->f_frsize;\n\tbuf.f_flags = kbuf->f_flags;\n\tif (copy_to_user(ubuf, &buf, sizeof(struct compat_statfs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "vfs_ustat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "220-230",
    "snippet": "static int vfs_ustat(dev_t dev, struct kstatfs *sbuf)\n{\n\tstruct super_block *s = user_get_super(dev);\n\tint err;\n\tif (!s)\n\t\treturn -EINVAL;\n\n\terr = statfs_by_dentry(s->s_root, sbuf);\n\tdrop_super(s);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_super",
          "args": [
            "s"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "drop_super_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "583-587",
          "snippet": "void drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "statfs_by_dentry",
          "args": [
            "s->s_root",
            "sbuf"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "statfs_by_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "53-68",
          "snippet": "static int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint retval;\n\n\tif (!dentry->d_sb->s_op->statfs)\n\t\treturn -ENOSYS;\n\n\tmemset(buf, 0, sizeof(*buf));\n\tretval = security_sb_statfs(dentry);\n\tif (retval)\n\t\treturn retval;\n\tretval = dentry->d_sb->s_op->statfs(dentry, buf);\n\tif (retval == 0 && buf->f_frsize == 0)\n\t\tbuf->f_frsize = buf->f_bsize;\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint retval;\n\n\tif (!dentry->d_sb->s_op->statfs)\n\t\treturn -ENOSYS;\n\n\tmemset(buf, 0, sizeof(*buf));\n\tretval = security_sb_statfs(dentry);\n\tif (retval)\n\t\treturn retval;\n\tretval = dentry->d_sb->s_op->statfs(dentry, buf);\n\tif (retval == 0 && buf->f_frsize == 0)\n\t\tbuf->f_frsize = buf->f_bsize;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_get_super",
          "args": [
            "dev"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "user_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "809-834",
          "snippet": "struct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int vfs_ustat(dev_t dev, struct kstatfs *sbuf)\n{\n\tstruct super_block *s = user_get_super(dev);\n\tint err;\n\tif (!s)\n\t\treturn -EINVAL;\n\n\terr = statfs_by_dentry(s->s_root, sbuf);\n\tdrop_super(s);\n\treturn err;\n}"
  },
  {
    "function_name": "do_statfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "152-174",
    "snippet": "static int do_statfs64(struct kstatfs *st, struct statfs64 __user *p)\n{\n\tstruct statfs64 buf;\n\tif (sizeof(buf) == sizeof(*st))\n\t\tmemcpy(&buf, st, sizeof(*st));\n\telse {\n\t\tbuf.f_type = st->f_type;\n\t\tbuf.f_bsize = st->f_bsize;\n\t\tbuf.f_blocks = st->f_blocks;\n\t\tbuf.f_bfree = st->f_bfree;\n\t\tbuf.f_bavail = st->f_bavail;\n\t\tbuf.f_files = st->f_files;\n\t\tbuf.f_ffree = st->f_ffree;\n\t\tbuf.f_fsid = st->f_fsid;\n\t\tbuf.f_namelen = st->f_namelen;\n\t\tbuf.f_frsize = st->f_frsize;\n\t\tbuf.f_flags = st->f_flags;\n\t\tmemset(buf.f_spare, 0, sizeof(buf.f_spare));\n\t}\n\tif (copy_to_user(p, &buf, sizeof(buf)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "p",
            "&buf",
            "sizeof(buf)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf.f_spare",
            "0",
            "sizeof(buf.f_spare)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&buf",
            "st",
            "sizeof(*st)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int do_statfs64(struct kstatfs *st, struct statfs64 __user *p)\n{\n\tstruct statfs64 buf;\n\tif (sizeof(buf) == sizeof(*st))\n\t\tmemcpy(&buf, st, sizeof(*st));\n\telse {\n\t\tbuf.f_type = st->f_type;\n\t\tbuf.f_bsize = st->f_bsize;\n\t\tbuf.f_blocks = st->f_blocks;\n\t\tbuf.f_bfree = st->f_bfree;\n\t\tbuf.f_bavail = st->f_bavail;\n\t\tbuf.f_files = st->f_files;\n\t\tbuf.f_ffree = st->f_ffree;\n\t\tbuf.f_fsid = st->f_fsid;\n\t\tbuf.f_namelen = st->f_namelen;\n\t\tbuf.f_frsize = st->f_frsize;\n\t\tbuf.f_flags = st->f_flags;\n\t\tmemset(buf.f_spare, 0, sizeof(buf.f_spare));\n\t}\n\tif (copy_to_user(p, &buf, sizeof(buf)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_statfs_native",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "110-150",
    "snippet": "static int do_statfs_native(struct kstatfs *st, struct statfs __user *p)\n{\n\tstruct statfs buf;\n\n\tif (sizeof(buf) == sizeof(*st))\n\t\tmemcpy(&buf, st, sizeof(*st));\n\telse {\n\t\tif (sizeof buf.f_blocks == 4) {\n\t\t\tif ((st->f_blocks | st->f_bfree | st->f_bavail |\n\t\t\t     st->f_bsize | st->f_frsize) &\n\t\t\t    0xffffffff00000000ULL)\n\t\t\t\treturn -EOVERFLOW;\n\t\t\t/*\n\t\t\t * f_files and f_ffree may be -1; it's okay to stuff\n\t\t\t * that into 32 bits\n\t\t\t */\n\t\t\tif (st->f_files != -1 &&\n\t\t\t    (st->f_files & 0xffffffff00000000ULL))\n\t\t\t\treturn -EOVERFLOW;\n\t\t\tif (st->f_ffree != -1 &&\n\t\t\t    (st->f_ffree & 0xffffffff00000000ULL))\n\t\t\t\treturn -EOVERFLOW;\n\t\t}\n\n\t\tbuf.f_type = st->f_type;\n\t\tbuf.f_bsize = st->f_bsize;\n\t\tbuf.f_blocks = st->f_blocks;\n\t\tbuf.f_bfree = st->f_bfree;\n\t\tbuf.f_bavail = st->f_bavail;\n\t\tbuf.f_files = st->f_files;\n\t\tbuf.f_ffree = st->f_ffree;\n\t\tbuf.f_fsid = st->f_fsid;\n\t\tbuf.f_namelen = st->f_namelen;\n\t\tbuf.f_frsize = st->f_frsize;\n\t\tbuf.f_flags = st->f_flags;\n\t\tmemset(buf.f_spare, 0, sizeof(buf.f_spare));\n\t}\n\tif (copy_to_user(p, &buf, sizeof(buf)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "p",
            "&buf",
            "sizeof(buf)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf.f_spare",
            "0",
            "sizeof(buf.f_spare)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&buf",
            "st",
            "sizeof(*st)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int do_statfs_native(struct kstatfs *st, struct statfs __user *p)\n{\n\tstruct statfs buf;\n\n\tif (sizeof(buf) == sizeof(*st))\n\t\tmemcpy(&buf, st, sizeof(*st));\n\telse {\n\t\tif (sizeof buf.f_blocks == 4) {\n\t\t\tif ((st->f_blocks | st->f_bfree | st->f_bavail |\n\t\t\t     st->f_bsize | st->f_frsize) &\n\t\t\t    0xffffffff00000000ULL)\n\t\t\t\treturn -EOVERFLOW;\n\t\t\t/*\n\t\t\t * f_files and f_ffree may be -1; it's okay to stuff\n\t\t\t * that into 32 bits\n\t\t\t */\n\t\t\tif (st->f_files != -1 &&\n\t\t\t    (st->f_files & 0xffffffff00000000ULL))\n\t\t\t\treturn -EOVERFLOW;\n\t\t\tif (st->f_ffree != -1 &&\n\t\t\t    (st->f_ffree & 0xffffffff00000000ULL))\n\t\t\t\treturn -EOVERFLOW;\n\t\t}\n\n\t\tbuf.f_type = st->f_type;\n\t\tbuf.f_bsize = st->f_bsize;\n\t\tbuf.f_blocks = st->f_blocks;\n\t\tbuf.f_bfree = st->f_bfree;\n\t\tbuf.f_bavail = st->f_bavail;\n\t\tbuf.f_files = st->f_files;\n\t\tbuf.f_ffree = st->f_ffree;\n\t\tbuf.f_fsid = st->f_fsid;\n\t\tbuf.f_namelen = st->f_namelen;\n\t\tbuf.f_frsize = st->f_frsize;\n\t\tbuf.f_flags = st->f_flags;\n\t\tmemset(buf.f_spare, 0, sizeof(buf.f_spare));\n\t}\n\tif (copy_to_user(p, &buf, sizeof(buf)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "fd_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "99-108",
    "snippet": "int fd_statfs(int fd, struct kstatfs *st)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error = -EBADF;\n\tif (f.file) {\n\t\terror = vfs_statfs(&f.file->f_path, st);\n\t\tfdput(f);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "&f.file->f_path",
            "st"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "70-78",
          "snippet": "int vfs_statfs(const struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint vfs_statfs(const struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_raw",
          "args": [
            "fd"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "753-756",
          "snippet": "unsigned long __fdget_raw(unsigned int fd)\n{\n\treturn __fget_light(fd, 0);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_raw(unsigned int fd)\n{\n\treturn __fget_light(fd, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint fd_statfs(int fd, struct kstatfs *st)\n{\n\tstruct fd f = fdget_raw(fd);\n\tint error = -EBADF;\n\tif (f.file) {\n\t\terror = vfs_statfs(&f.file->f_path, st);\n\t\tfdput(f);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "user_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "81-97",
    "snippet": "int user_statfs(const char __user *pathname, struct kstatfs *st)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_statfs(&path, st);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "&path",
            "st"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "70-78",
          "snippet": "int vfs_statfs(const struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint vfs_statfs(const struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint user_statfs(const char __user *pathname, struct kstatfs *st)\n{\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (!error) {\n\t\terror = vfs_statfs(&path, st);\n\t\tpath_put(&path);\n\t\tif (retry_estale(error, lookup_flags)) {\n\t\t\tlookup_flags |= LOOKUP_REVAL;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "70-78",
    "snippet": "int vfs_statfs(const struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_f_flags",
          "args": [
            "path->mnt"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_f_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "47-51",
          "snippet": "static int calculate_f_flags(struct vfsmount *mnt)\n{\n\treturn ST_VALID | flags_by_mnt(mnt->mnt_flags) |\n\t\tflags_by_sb(mnt->mnt_sb->s_flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int calculate_f_flags(struct vfsmount *mnt)\n{\n\treturn ST_VALID | flags_by_mnt(mnt->mnt_flags) |\n\t\tflags_by_sb(mnt->mnt_sb->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "statfs_by_dentry",
          "args": [
            "path->dentry",
            "buf"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "statfs_by_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "53-68",
          "snippet": "static int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint retval;\n\n\tif (!dentry->d_sb->s_op->statfs)\n\t\treturn -ENOSYS;\n\n\tmemset(buf, 0, sizeof(*buf));\n\tretval = security_sb_statfs(dentry);\n\tif (retval)\n\t\treturn retval;\n\tretval = dentry->d_sb->s_op->statfs(dentry, buf);\n\tif (retval == 0 && buf->f_frsize == 0)\n\t\tbuf->f_frsize = buf->f_bsize;\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint retval;\n\n\tif (!dentry->d_sb->s_op->statfs)\n\t\treturn -ENOSYS;\n\n\tmemset(buf, 0, sizeof(*buf));\n\tretval = security_sb_statfs(dentry);\n\tif (retval)\n\t\treturn retval;\n\tretval = dentry->d_sb->s_op->statfs(dentry, buf);\n\tif (retval == 0 && buf->f_frsize == 0)\n\t\tbuf->f_frsize = buf->f_bsize;\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint vfs_statfs(const struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}"
  },
  {
    "function_name": "statfs_by_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "53-68",
    "snippet": "static int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint retval;\n\n\tif (!dentry->d_sb->s_op->statfs)\n\t\treturn -ENOSYS;\n\n\tmemset(buf, 0, sizeof(*buf));\n\tretval = security_sb_statfs(dentry);\n\tif (retval)\n\t\treturn retval;\n\tretval = dentry->d_sb->s_op->statfs(dentry, buf);\n\tif (retval == 0 && buf->f_frsize == 0)\n\t\tbuf->f_frsize = buf->f_bsize;\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dentry->d_sb->s_op->statfs",
          "args": [
            "dentry",
            "buf"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_statfs",
          "args": [
            "dentry"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(*buf)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)\n{\n\tint retval;\n\n\tif (!dentry->d_sb->s_op->statfs)\n\t\treturn -ENOSYS;\n\n\tmemset(buf, 0, sizeof(*buf));\n\tretval = security_sb_statfs(dentry);\n\tif (retval)\n\t\treturn retval;\n\tretval = dentry->d_sb->s_op->statfs(dentry, buf);\n\tif (retval == 0 && buf->f_frsize == 0)\n\t\tbuf->f_frsize = buf->f_bsize;\n\treturn retval;\n}"
  },
  {
    "function_name": "calculate_f_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "47-51",
    "snippet": "static int calculate_f_flags(struct vfsmount *mnt)\n{\n\treturn ST_VALID | flags_by_mnt(mnt->mnt_flags) |\n\t\tflags_by_sb(mnt->mnt_sb->s_flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flags_by_sb",
          "args": [
            "mnt->mnt_sb->s_flags"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "flags_by_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "35-45",
          "snippet": "static int flags_by_sb(int s_flags)\n{\n\tint flags = 0;\n\tif (s_flags & SB_SYNCHRONOUS)\n\t\tflags |= ST_SYNCHRONOUS;\n\tif (s_flags & SB_MANDLOCK)\n\t\tflags |= ST_MANDLOCK;\n\tif (s_flags & SB_RDONLY)\n\t\tflags |= ST_RDONLY;\n\treturn flags;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int flags_by_sb(int s_flags)\n{\n\tint flags = 0;\n\tif (s_flags & SB_SYNCHRONOUS)\n\t\tflags |= ST_SYNCHRONOUS;\n\tif (s_flags & SB_MANDLOCK)\n\t\tflags |= ST_MANDLOCK;\n\tif (s_flags & SB_RDONLY)\n\t\tflags |= ST_RDONLY;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flags_by_mnt",
          "args": [
            "mnt->mnt_flags"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "flags_by_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
          "lines": "14-33",
          "snippet": "static int flags_by_mnt(int mnt_flags)\n{\n\tint flags = 0;\n\n\tif (mnt_flags & MNT_READONLY)\n\t\tflags |= ST_RDONLY;\n\tif (mnt_flags & MNT_NOSUID)\n\t\tflags |= ST_NOSUID;\n\tif (mnt_flags & MNT_NODEV)\n\t\tflags |= ST_NODEV;\n\tif (mnt_flags & MNT_NOEXEC)\n\t\tflags |= ST_NOEXEC;\n\tif (mnt_flags & MNT_NOATIME)\n\t\tflags |= ST_NOATIME;\n\tif (mnt_flags & MNT_NODIRATIME)\n\t\tflags |= ST_NODIRATIME;\n\tif (mnt_flags & MNT_RELATIME)\n\t\tflags |= ST_RELATIME;\n\treturn flags;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int flags_by_mnt(int mnt_flags)\n{\n\tint flags = 0;\n\n\tif (mnt_flags & MNT_READONLY)\n\t\tflags |= ST_RDONLY;\n\tif (mnt_flags & MNT_NOSUID)\n\t\tflags |= ST_NOSUID;\n\tif (mnt_flags & MNT_NODEV)\n\t\tflags |= ST_NODEV;\n\tif (mnt_flags & MNT_NOEXEC)\n\t\tflags |= ST_NOEXEC;\n\tif (mnt_flags & MNT_NOATIME)\n\t\tflags |= ST_NOATIME;\n\tif (mnt_flags & MNT_NODIRATIME)\n\t\tflags |= ST_NODIRATIME;\n\tif (mnt_flags & MNT_RELATIME)\n\t\tflags |= ST_RELATIME;\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int calculate_f_flags(struct vfsmount *mnt)\n{\n\treturn ST_VALID | flags_by_mnt(mnt->mnt_flags) |\n\t\tflags_by_sb(mnt->mnt_sb->s_flags);\n}"
  },
  {
    "function_name": "flags_by_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "35-45",
    "snippet": "static int flags_by_sb(int s_flags)\n{\n\tint flags = 0;\n\tif (s_flags & SB_SYNCHRONOUS)\n\t\tflags |= ST_SYNCHRONOUS;\n\tif (s_flags & SB_MANDLOCK)\n\t\tflags |= ST_MANDLOCK;\n\tif (s_flags & SB_RDONLY)\n\t\tflags |= ST_RDONLY;\n\treturn flags;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int flags_by_sb(int s_flags)\n{\n\tint flags = 0;\n\tif (s_flags & SB_SYNCHRONOUS)\n\t\tflags |= ST_SYNCHRONOUS;\n\tif (s_flags & SB_MANDLOCK)\n\t\tflags |= ST_MANDLOCK;\n\tif (s_flags & SB_RDONLY)\n\t\tflags |= ST_RDONLY;\n\treturn flags;\n}"
  },
  {
    "function_name": "flags_by_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "14-33",
    "snippet": "static int flags_by_mnt(int mnt_flags)\n{\n\tint flags = 0;\n\n\tif (mnt_flags & MNT_READONLY)\n\t\tflags |= ST_RDONLY;\n\tif (mnt_flags & MNT_NOSUID)\n\t\tflags |= ST_NOSUID;\n\tif (mnt_flags & MNT_NODEV)\n\t\tflags |= ST_NODEV;\n\tif (mnt_flags & MNT_NOEXEC)\n\t\tflags |= ST_NOEXEC;\n\tif (mnt_flags & MNT_NOATIME)\n\t\tflags |= ST_NOATIME;\n\tif (mnt_flags & MNT_NODIRATIME)\n\t\tflags |= ST_NODIRATIME;\n\tif (mnt_flags & MNT_RELATIME)\n\t\tflags |= ST_RELATIME;\n\treturn flags;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int flags_by_mnt(int mnt_flags)\n{\n\tint flags = 0;\n\n\tif (mnt_flags & MNT_READONLY)\n\t\tflags |= ST_RDONLY;\n\tif (mnt_flags & MNT_NOSUID)\n\t\tflags |= ST_NOSUID;\n\tif (mnt_flags & MNT_NODEV)\n\t\tflags |= ST_NODEV;\n\tif (mnt_flags & MNT_NOEXEC)\n\t\tflags |= ST_NOEXEC;\n\tif (mnt_flags & MNT_NOATIME)\n\t\tflags |= ST_NOATIME;\n\tif (mnt_flags & MNT_NODIRATIME)\n\t\tflags |= ST_NODIRATIME;\n\tif (mnt_flags & MNT_RELATIME)\n\t\tflags |= ST_RELATIME;\n\treturn flags;\n}"
  },
  {
    "function_name": "statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "176-183",
    "snippet": "SYSCALL_DEFINE2(statfs, const char __user *, pathname, struct statfs __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error = user_statfs(pathname, &st);\n\tif (!error)\n\t\terror = do_statfs_native(&st, buf);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(statfs, const char __user *, pathname, struct statfs __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error = user_statfs(pathname, &st);\n\tif (!error)\n\t\terror = do_statfs_native(&st, buf);\n\treturn error;\n}"
  },
  {
    "function_name": "statfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "185-195",
    "snippet": "SYSCALL_DEFINE3(statfs64, const char __user *, pathname, size_t, sz, struct statfs64 __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error;\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\terror = user_statfs(pathname, &st);\n\tif (!error)\n\t\terror = do_statfs64(&st, buf);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(statfs64, const char __user *, pathname, size_t, sz, struct statfs64 __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error;\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\terror = user_statfs(pathname, &st);\n\tif (!error)\n\t\terror = do_statfs64(&st, buf);\n\treturn error;\n}"
  },
  {
    "function_name": "fstatfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "197-204",
    "snippet": "SYSCALL_DEFINE2(fstatfs, unsigned int, fd, struct statfs __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error = fd_statfs(fd, &st);\n\tif (!error)\n\t\terror = do_statfs_native(&st, buf);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(fstatfs, unsigned int, fd, struct statfs __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error = fd_statfs(fd, &st);\n\tif (!error)\n\t\terror = do_statfs_native(&st, buf);\n\treturn error;\n}"
  },
  {
    "function_name": "fstatfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "206-218",
    "snippet": "SYSCALL_DEFINE3(fstatfs64, unsigned int, fd, size_t, sz, struct statfs64 __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = fd_statfs(fd, &st);\n\tif (!error)\n\t\terror = do_statfs64(&st, buf);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(fstatfs64, unsigned int, fd, size_t, sz, struct statfs64 __user *, buf)\n{\n\tstruct kstatfs st;\n\tint error;\n\n\tif (sz != sizeof(*buf))\n\t\treturn -EINVAL;\n\n\terror = fd_statfs(fd, &st);\n\tif (!error)\n\t\terror = do_statfs64(&st, buf);\n\treturn error;\n}"
  },
  {
    "function_name": "ustat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "232-245",
    "snippet": "SYSCALL_DEFINE2(ustat, unsigned, dev, struct ustat __user *, ubuf)\n{\n\tstruct ustat tmp;\n\tstruct kstatfs sbuf;\n\tint err = vfs_ustat(new_decode_dev(dev), &sbuf);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&tmp,0,sizeof(struct ustat));\n\ttmp.f_tfree = sbuf.f_bfree;\n\ttmp.f_tinode = sbuf.f_ffree;\n\n\treturn copy_to_user(ubuf, &tmp, sizeof(struct ustat)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(ustat, unsigned, dev, struct ustat __user *, ubuf)\n{\n\tstruct ustat tmp;\n\tstruct kstatfs sbuf;\n\tint err = vfs_ustat(new_decode_dev(dev), &sbuf);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&tmp,0,sizeof(struct ustat));\n\ttmp.f_tfree = sbuf.f_bfree;\n\ttmp.f_tinode = sbuf.f_ffree;\n\n\treturn copy_to_user(ubuf, &tmp, sizeof(struct ustat)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "286-293",
    "snippet": "SYSCALL_DEFINE2(statfs, const char __user *, pathname, struct compat_statfs __user *, buf)\n{\n\tstruct kstatfs tmp;\n\tint error = user_statfs(pathname, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs(buf, &tmp);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(statfs, const char __user *, pathname, struct compat_statfs __user *, buf)\n{\n\tstruct kstatfs tmp;\n\tint error = user_statfs(pathname, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs(buf, &tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "fstatfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "295-302",
    "snippet": "SYSCALL_DEFINE2(fstatfs, unsigned int, fd, struct compat_statfs __user *, buf)\n{\n\tstruct kstatfs tmp;\n\tint error = fd_statfs(fd, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs(buf, &tmp);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(fstatfs, unsigned int, fd, struct compat_statfs __user *, buf)\n{\n\tstruct kstatfs tmp;\n\tint error = fd_statfs(fd, &tmp);\n\tif (!error)\n\t\terror = put_compat_statfs(buf, &tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "statfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "352-355",
    "snippet": "SYSCALL_DEFINE3(statfs64, const char __user *, pathname, compat_size_t, sz, struct compat_statfs64 __user *, buf)\n{\n\treturn kcompat_sys_statfs64(pathname, sz, buf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(statfs64, const char __user *, pathname, compat_size_t, sz, struct compat_statfs64 __user *, buf)\n{\n\treturn kcompat_sys_statfs64(pathname, sz, buf);\n}"
  },
  {
    "function_name": "fstatfs64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "371-374",
    "snippet": "SYSCALL_DEFINE3(fstatfs64, unsigned int, fd, compat_size_t, sz, struct compat_statfs64 __user *, buf)\n{\n\treturn kcompat_sys_fstatfs64(fd, sz, buf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(fstatfs64, unsigned int, fd, compat_size_t, sz, struct compat_statfs64 __user *, buf)\n{\n\treturn kcompat_sys_fstatfs64(fd, sz, buf);\n}"
  },
  {
    "function_name": "ustat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/statfs.c",
    "lines": "381-395",
    "snippet": "SYSCALL_DEFINE2(ustat, unsigned, dev, struct compat_ustat __user *, u)\n{\n\tstruct compat_ustat tmp;\n\tstruct kstatfs sbuf;\n\tint err = vfs_ustat(new_decode_dev(dev), &sbuf);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&tmp, 0, sizeof(struct compat_ustat));\n\ttmp.f_tfree = sbuf.f_bfree;\n\ttmp.f_tinode = sbuf.f_ffree;\n\tif (copy_to_user(u, &tmp, sizeof(struct compat_ustat)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/security.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(ustat, unsigned, dev, struct compat_ustat __user *, u)\n{\n\tstruct compat_ustat tmp;\n\tstruct kstatfs sbuf;\n\tint err = vfs_ustat(new_decode_dev(dev), &sbuf);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&tmp, 0, sizeof(struct compat_ustat));\n\ttmp.f_tfree = sbuf.f_bfree;\n\ttmp.f_tinode = sbuf.f_ffree;\n\tif (copy_to_user(u, &tmp, sizeof(struct compat_ustat)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  }
]