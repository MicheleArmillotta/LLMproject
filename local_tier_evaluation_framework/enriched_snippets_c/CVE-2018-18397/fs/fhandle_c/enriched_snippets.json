[
  {
    "function_name": "do_handle_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "215-243",
    "snippet": "static long do_handle_open(int mountdirfd, struct file_handle __user *ufh,\n\t\t\t   int open_flag)\n{\n\tlong retval = 0;\n\tstruct path path;\n\tstruct file *file;\n\tint fd;\n\n\tretval = handle_to_path(mountdirfd, ufh, &path);\n\tif (retval)\n\t\treturn retval;\n\n\tfd = get_unused_fd_flags(open_flag);\n\tif (fd < 0) {\n\t\tpath_put(&path);\n\t\treturn fd;\n\t}\n\tfile = file_open_root(path.dentry, path.mnt, \"\", open_flag, 0);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\tretval =  PTR_ERR(file);\n\t} else {\n\t\tretval = fd;\n\t\tfsnotify_open(file);\n\t\tfd_install(fd, file);\n\t}\n\tpath_put(&path);\n\treturn retval;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "file"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_open",
          "args": [
            "file"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "556-562",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_open_root",
          "args": [
            "path.dentry",
            "path.mnt",
            "\"\"",
            "open_flag",
            "0"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "file_open_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1037-1045",
          "snippet": "struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "open_flag"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_to_path",
          "args": [
            "mountdirfd",
            "ufh",
            "&path"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
          "lines": "167-213",
          "snippet": "static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * With handle we don't look at the execute bit on the\n\t * the directory. Ideally we would like CAP_DAC_SEARCH.\n\t * But we don't have that\n\t */\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * With handle we don't look at the execute bit on the\n\t * the directory. Ideally we would like CAP_DAC_SEARCH.\n\t * But we don't have that\n\t */\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic long do_handle_open(int mountdirfd, struct file_handle __user *ufh,\n\t\t\t   int open_flag)\n{\n\tlong retval = 0;\n\tstruct path path;\n\tstruct file *file;\n\tint fd;\n\n\tretval = handle_to_path(mountdirfd, ufh, &path);\n\tif (retval)\n\t\treturn retval;\n\n\tfd = get_unused_fd_flags(open_flag);\n\tif (fd < 0) {\n\t\tpath_put(&path);\n\t\treturn fd;\n\t}\n\tfile = file_open_root(path.dentry, path.mnt, \"\", open_flag, 0);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\tretval =  PTR_ERR(file);\n\t} else {\n\t\tretval = fd;\n\t\tfsnotify_open(file);\n\t\tfd_install(fd, file);\n\t}\n\tpath_put(&path);\n\treturn retval;\n}"
  },
  {
    "function_name": "handle_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "167-213",
    "snippet": "static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * With handle we don't look at the execute bit on the\n\t * the directory. Ideally we would like CAP_DAC_SEARCH.\n\t * But we don't have that\n\t */\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "handle"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_handle_to_path",
          "args": [
            "mountdirfd",
            "handle",
            "path"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "do_handle_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
          "lines": "139-165",
          "snippet": "static int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n\tint retval = 0;\n\tint handle_dwords;\n\n\tpath->mnt = get_vfsmount_from_fd(mountdirfd);\n\tif (IS_ERR(path->mnt)) {\n\t\tretval = PTR_ERR(path->mnt);\n\t\tgoto out_err;\n\t}\n\t/* change the handle size to multiple of sizeof(u32) */\n\thandle_dwords = handle->handle_bytes >> 2;\n\tpath->dentry = exportfs_decode_fh(path->mnt,\n\t\t\t\t\t  (struct fid *)handle->f_handle,\n\t\t\t\t\t  handle_dwords, handle->handle_type,\n\t\t\t\t\t  vfs_dentry_acceptable, NULL);\n\tif (IS_ERR(path->dentry)) {\n\t\tretval = PTR_ERR(path->dentry);\n\t\tgoto out_mnt;\n\t}\n\treturn 0;\nout_mnt:\n\tmntput(path->mnt);\nout_err:\n\treturn retval;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n\tint retval = 0;\n\tint handle_dwords;\n\n\tpath->mnt = get_vfsmount_from_fd(mountdirfd);\n\tif (IS_ERR(path->mnt)) {\n\t\tretval = PTR_ERR(path->mnt);\n\t\tgoto out_err;\n\t}\n\t/* change the handle size to multiple of sizeof(u32) */\n\thandle_dwords = handle->handle_bytes >> 2;\n\tpath->dentry = exportfs_decode_fh(path->mnt,\n\t\t\t\t\t  (struct fid *)handle->f_handle,\n\t\t\t\t\t  handle_dwords, handle->handle_type,\n\t\t\t\t\t  vfs_dentry_acceptable, NULL);\n\tif (IS_ERR(path->dentry)) {\n\t\tretval = PTR_ERR(path->dentry);\n\t\tgoto out_mnt;\n\t}\n\treturn 0;\nout_mnt:\n\tmntput(path->mnt);\nout_err:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&handle->f_handle",
            "&ufh->f_handle",
            "f_handle.handle_bytes"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct file_handle) + f_handle.handle_bytes",
            "GFP_KERNEL"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_DAC_READ_SEARCH"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * With handle we don't look at the execute bit on the\n\t * the directory. Ideally we would like CAP_DAC_SEARCH.\n\t * But we don't have that\n\t */\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\t/* copy the full handle */\n\t*handle = f_handle;\n\tif (copy_from_user(&handle->f_handle,\n\t\t\t   &ufh->f_handle,\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\n\tretval = do_handle_to_path(mountdirfd, handle, path);\n\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}"
  },
  {
    "function_name": "do_handle_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "139-165",
    "snippet": "static int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n\tint retval = 0;\n\tint handle_dwords;\n\n\tpath->mnt = get_vfsmount_from_fd(mountdirfd);\n\tif (IS_ERR(path->mnt)) {\n\t\tretval = PTR_ERR(path->mnt);\n\t\tgoto out_err;\n\t}\n\t/* change the handle size to multiple of sizeof(u32) */\n\thandle_dwords = handle->handle_bytes >> 2;\n\tpath->dentry = exportfs_decode_fh(path->mnt,\n\t\t\t\t\t  (struct fid *)handle->f_handle,\n\t\t\t\t\t  handle_dwords, handle->handle_type,\n\t\t\t\t\t  vfs_dentry_acceptable, NULL);\n\tif (IS_ERR(path->dentry)) {\n\t\tretval = PTR_ERR(path->dentry);\n\t\tgoto out_mnt;\n\t}\n\treturn 0;\nout_mnt:\n\tmntput(path->mnt);\nout_err:\n\treturn retval;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "path->mnt"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1180-1189",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path->dentry"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path->dentry"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportfs_decode_fh",
          "args": [
            "path->mnt",
            "(struct fid *)handle->f_handle",
            "handle_dwords",
            "handle->handle_type",
            "vfs_dentry_acceptable",
            "NULL"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exportfs/expfs.c",
          "lines": "419-559",
          "snippet": "struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (PTR_ERR(result) == -ENOMEM)\n\t\treturn ERR_CAST(result);\n\tif (IS_ERR_OR_NULL(result))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * If no acceptance criteria was specified by caller, a disconnected\n\t * dentry is also accepatable. Callers may use this mode to query if\n\t * file handle is stale or to get a reference to an inode without\n\t * risking the high overhead caused by directory reconnect.\n\t */\n\tif (!acceptable)\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tinode_lock(target_dir->d_inode);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tinode_unlock(target_dir->d_inode);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\tif (err != -ENOMEM)\n\t\terr = -ESTALE;\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_name(const struct path *path, char *name, struct dentry *child);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (PTR_ERR(result) == -ENOMEM)\n\t\treturn ERR_CAST(result);\n\tif (IS_ERR_OR_NULL(result))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * If no acceptance criteria was specified by caller, a disconnected\n\t * dentry is also accepatable. Callers may use this mode to query if\n\t * file handle is stale or to get a reference to an inode without\n\t * risking the high overhead caused by directory reconnect.\n\t */\n\tif (!acceptable)\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tinode_lock(target_dir->d_inode);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tinode_unlock(target_dir->d_inode);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\tif (err != -ENOMEM)\n\t\terr = -ESTALE;\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path->mnt"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path->mnt"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vfsmount_from_fd",
          "args": [
            "mountdirfd"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "get_vfsmount_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
          "lines": "115-132",
          "snippet": "static struct vfsmount *get_vfsmount_from_fd(int fd)\n{\n\tstruct vfsmount *mnt;\n\n\tif (fd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tspin_lock(&fs->lock);\n\t\tmnt = mntget(fs->pwd.mnt);\n\t\tspin_unlock(&fs->lock);\n\t} else {\n\t\tstruct fd f = fdget(fd);\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\t\tmnt = mntget(f.file->f_path.mnt);\n\t\tfdput(f);\n\t}\n\treturn mnt;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic struct vfsmount *get_vfsmount_from_fd(int fd)\n{\n\tstruct vfsmount *mnt;\n\n\tif (fd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tspin_lock(&fs->lock);\n\t\tmnt = mntget(fs->pwd.mnt);\n\t\tspin_unlock(&fs->lock);\n\t} else {\n\t\tstruct fd f = fdget(fd);\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\t\tmnt = mntget(f.file->f_path.mnt);\n\t\tfdput(f);\n\t}\n\treturn mnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic int do_handle_to_path(int mountdirfd, struct file_handle *handle,\n\t\t\t     struct path *path)\n{\n\tint retval = 0;\n\tint handle_dwords;\n\n\tpath->mnt = get_vfsmount_from_fd(mountdirfd);\n\tif (IS_ERR(path->mnt)) {\n\t\tretval = PTR_ERR(path->mnt);\n\t\tgoto out_err;\n\t}\n\t/* change the handle size to multiple of sizeof(u32) */\n\thandle_dwords = handle->handle_bytes >> 2;\n\tpath->dentry = exportfs_decode_fh(path->mnt,\n\t\t\t\t\t  (struct fid *)handle->f_handle,\n\t\t\t\t\t  handle_dwords, handle->handle_type,\n\t\t\t\t\t  vfs_dentry_acceptable, NULL);\n\tif (IS_ERR(path->dentry)) {\n\t\tretval = PTR_ERR(path->dentry);\n\t\tgoto out_mnt;\n\t}\n\treturn 0;\nout_mnt:\n\tmntput(path->mnt);\nout_err:\n\treturn retval;\n}"
  },
  {
    "function_name": "vfs_dentry_acceptable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "134-137",
    "snippet": "static int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "get_vfsmount_from_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "115-132",
    "snippet": "static struct vfsmount *get_vfsmount_from_fd(int fd)\n{\n\tstruct vfsmount *mnt;\n\n\tif (fd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tspin_lock(&fs->lock);\n\t\tmnt = mntget(fs->pwd.mnt);\n\t\tspin_unlock(&fs->lock);\n\t} else {\n\t\tstruct fd f = fdget(fd);\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\t\tmnt = mntget(f.file->f_path.mnt);\n\t\tfdput(f);\n\t}\n\treturn mnt;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "f.file->f_path.mnt"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1192-1197",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs->lock"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs->lock"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic struct vfsmount *get_vfsmount_from_fd(int fd)\n{\n\tstruct vfsmount *mnt;\n\n\tif (fd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tspin_lock(&fs->lock);\n\t\tmnt = mntget(fs->pwd.mnt);\n\t\tspin_unlock(&fs->lock);\n\t} else {\n\t\tstruct fd f = fdget(fd);\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\t\tmnt = mntget(f.file->f_path.mnt);\n\t\tfdput(f);\n\t}\n\treturn mnt;\n}"
  },
  {
    "function_name": "do_sys_name_to_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "17-78",
    "snippet": "static long do_sys_name_to_handle(struct path *path,\n\t\t\t\t  struct file_handle __user *ufh,\n\t\t\t\t  int __user *mnt_id)\n{\n\tlong retval;\n\tstruct file_handle f_handle;\n\tint handle_dwords, handle_bytes;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * We need to make sure whether the file system\n\t * support decoding of the file handle\n\t */\n\tif (!path->dentry->d_sb->s_export_op ||\n\t    !path->dentry->d_sb->s_export_op->fh_to_dentry)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle)))\n\t\treturn -EFAULT;\n\n\tif (f_handle.handle_bytes > MAX_HANDLE_SZ)\n\t\treturn -EINVAL;\n\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\t/* convert handle size to multiple of sizeof(u32) */\n\thandle_dwords = f_handle.handle_bytes >> 2;\n\n\t/* we ask for a non connected handle */\n\tretval = exportfs_encode_fh(path->dentry,\n\t\t\t\t    (struct fid *)handle->f_handle,\n\t\t\t\t    &handle_dwords,  0);\n\thandle->handle_type = retval;\n\t/* convert handle size to bytes */\n\thandle_bytes = handle_dwords * sizeof(u32);\n\thandle->handle_bytes = handle_bytes;\n\tif ((handle->handle_bytes > f_handle.handle_bytes) ||\n\t    (retval == FILEID_INVALID) || (retval == -ENOSPC)) {\n\t\t/* As per old exportfs_encode_fh documentation\n\t\t * we could return ENOSPC to indicate overflow\n\t\t * But file system returned 255 always. So handle\n\t\t * both the values\n\t\t */\n\t\t/*\n\t\t * set the handle size to zero so we copy only\n\t\t * non variable part of the file_handle\n\t\t */\n\t\thandle_bytes = 0;\n\t\tretval = -EOVERFLOW;\n\t} else\n\t\tretval = 0;\n\t/* copy the mount id */\n\tif (put_user(real_mount(path->mnt)->mnt_id, mnt_id) ||\n\t    copy_to_user(ufh, handle,\n\t\t\t sizeof(struct file_handle) + handle_bytes))\n\t\tretval = -EFAULT;\n\tkfree(handle);\n\treturn retval;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "handle"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ufh",
            "handle",
            "sizeof(struct file_handle) + handle_bytes"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "real_mount(path->mnt)->mnt_id",
            "mnt_id"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "path->mnt"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __legitimize_mnt(struct vfsmount *, unsigned);",
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern int __legitimize_mnt(struct vfsmount *, unsigned);\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exportfs_encode_fh",
          "args": [
            "path->dentry",
            "(struct fid *)handle->f_handle",
            "&handle_dwords",
            "0"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exportfs/expfs.c",
          "lines": "396-416",
          "snippet": "int exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\n\t\tint connectable)\n{\n\tint error;\n\tstruct dentry *p = NULL;\n\tstruct inode *inode = dentry->d_inode, *parent = NULL;\n\n\tif (connectable && !S_ISDIR(inode->i_mode)) {\n\t\tp = dget_parent(dentry);\n\t\t/*\n\t\t * note that while p might've ceased to be our parent already,\n\t\t * it's still pinned by and still positive.\n\t\t */\n\t\tparent = p->d_inode;\n\t}\n\n\terror = exportfs_encode_inode_fh(inode, fid, max_len, parent);\n\tdput(p);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nint exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\n\t\tint connectable)\n{\n\tint error;\n\tstruct dentry *p = NULL;\n\tstruct inode *inode = dentry->d_inode, *parent = NULL;\n\n\tif (connectable && !S_ISDIR(inode->i_mode)) {\n\t\tp = dget_parent(dentry);\n\t\t/*\n\t\t * note that while p might've ceased to be our parent already,\n\t\t * it's still pinned by and still positive.\n\t\t */\n\t\tparent = p->d_inode;\n\t}\n\n\terror = exportfs_encode_inode_fh(inode, fid, max_len, parent);\n\tdput(p);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct file_handle) + f_handle.handle_bytes",
            "GFP_KERNEL"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&f_handle",
            "ufh",
            "sizeof(struct file_handle)"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic long do_sys_name_to_handle(struct path *path,\n\t\t\t\t  struct file_handle __user *ufh,\n\t\t\t\t  int __user *mnt_id)\n{\n\tlong retval;\n\tstruct file_handle f_handle;\n\tint handle_dwords, handle_bytes;\n\tstruct file_handle *handle = NULL;\n\n\t/*\n\t * We need to make sure whether the file system\n\t * support decoding of the file handle\n\t */\n\tif (!path->dentry->d_sb->s_export_op ||\n\t    !path->dentry->d_sb->s_export_op->fh_to_dentry)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle)))\n\t\treturn -EFAULT;\n\n\tif (f_handle.handle_bytes > MAX_HANDLE_SZ)\n\t\treturn -EINVAL;\n\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\t/* convert handle size to multiple of sizeof(u32) */\n\thandle_dwords = f_handle.handle_bytes >> 2;\n\n\t/* we ask for a non connected handle */\n\tretval = exportfs_encode_fh(path->dentry,\n\t\t\t\t    (struct fid *)handle->f_handle,\n\t\t\t\t    &handle_dwords,  0);\n\thandle->handle_type = retval;\n\t/* convert handle size to bytes */\n\thandle_bytes = handle_dwords * sizeof(u32);\n\thandle->handle_bytes = handle_bytes;\n\tif ((handle->handle_bytes > f_handle.handle_bytes) ||\n\t    (retval == FILEID_INVALID) || (retval == -ENOSPC)) {\n\t\t/* As per old exportfs_encode_fh documentation\n\t\t * we could return ENOSPC to indicate overflow\n\t\t * But file system returned 255 always. So handle\n\t\t * both the values\n\t\t */\n\t\t/*\n\t\t * set the handle size to zero so we copy only\n\t\t * non variable part of the file_handle\n\t\t */\n\t\thandle_bytes = 0;\n\t\tretval = -EOVERFLOW;\n\t} else\n\t\tretval = 0;\n\t/* copy the mount id */\n\tif (put_user(real_mount(path->mnt)->mnt_id, mnt_id) ||\n\t    copy_to_user(ufh, handle,\n\t\t\t sizeof(struct file_handle) + handle_bytes))\n\t\tretval = -EFAULT;\n\tkfree(handle);\n\treturn retval;\n}"
  },
  {
    "function_name": "name_to_handle_at",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "93-113",
    "snippet": "SYSCALL_DEFINE5(name_to_handle_at, int, dfd, const char __user *, name,\n\t\tstruct file_handle __user *, handle, int __user *, mnt_id,\n\t\tint, flag)\n{\n\tstruct path path;\n\tint lookup_flags;\n\tint err;\n\n\tif ((flag & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\n\tlookup_flags = (flag & AT_SYMLINK_FOLLOW) ? LOOKUP_FOLLOW : 0;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\terr = user_path_at(dfd, name, lookup_flags, &path);\n\tif (!err) {\n\t\terr = do_sys_name_to_handle(&path, handle, mnt_id);\n\t\tpath_put(&path);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE5(name_to_handle_at, int, dfd, const char __user *, name,\n\t\tstruct file_handle __user *, handle, int __user *, mnt_id,\n\t\tint, flag)\n{\n\tstruct path path;\n\tint lookup_flags;\n\tint err;\n\n\tif ((flag & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\n\tlookup_flags = (flag & AT_SYMLINK_FOLLOW) ? LOOKUP_FOLLOW : 0;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\terr = user_path_at(dfd, name, lookup_flags, &path);\n\tif (!err) {\n\t\terr = do_sys_name_to_handle(&path, handle, mnt_id);\n\t\tpath_put(&path);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "open_by_handle_at",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "256-267",
    "snippet": "SYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\tstruct file_handle __user *, handle,\n\t\tint, flags)\n{\n\tlong ret;\n\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\tret = do_handle_open(mountdirfd, handle, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\tstruct file_handle __user *, handle,\n\t\tint, flags)\n{\n\tlong ret;\n\n\tif (force_o_largefile())\n\t\tflags |= O_LARGEFILE;\n\n\tret = do_handle_open(mountdirfd, handle, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "open_by_handle_at",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fhandle.c",
    "lines": "274-278",
    "snippet": "SYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\t\t     struct file_handle __user *, handle, int, flags)\n{\n\treturn do_handle_open(mountdirfd, handle, flags);\n}",
    "includes": [
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/compat.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/personality.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,\n\t\t\t     struct file_handle __user *, handle, int, flags)\n{\n\treturn do_handle_open(mountdirfd, handle, flags);\n}"
  }
]