[
  {
    "function_name": "filelock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2796-2815",
    "snippet": "static int __init filelock_init(void)\n{\n\tint i;\n\n\tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\n\n\tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\n\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);\n\n\t\tspin_lock_init(&fll->lock);\n\t\tINIT_HLIST_HEAD(&fll->hlist);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *flctx_cache",
      "static struct kmem_cache *filelock_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&fll->hlist"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fll->lock"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&file_lock_list",
            "i"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"file_lock_cache\"",
            "sizeof(struct file_lock)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"file_lock_ctx\"",
            "sizeof(struct file_lock_context)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\nstatic struct kmem_cache *filelock_cache;\n\nstatic int __init filelock_init(void)\n{\n\tint i;\n\n\tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\n\n\tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\n\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);\n\n\t\tspin_lock_init(&fll->lock);\n\t\tINIT_HLIST_HEAD(&fll->hlist);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_locks_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2787-2792",
    "snippet": "static int __init proc_locks_init(void)\n{\n\tproc_create_seq_private(\"locks\", 0, NULL, &locks_seq_operations,\n\t\t\tsizeof(struct locks_iterator), NULL);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq_private",
          "args": [
            "\"locks\"",
            "0",
            "NULL",
            "&locks_seq_operations",
            "sizeof(struct locks_iterator)",
            "NULL"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_seq_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc/generic.c",
          "lines": "583-596",
          "snippet": "struct proc_dir_entry *proc_create_seq_private(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, const struct seq_operations *ops,\n\t\tunsigned int state_size, void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tp->proc_fops = &proc_seq_fops;\n\tp->seq_ops = ops;\n\tp->state_size = state_size;\n\treturn proc_register(parent, p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations proc_seq_fops = {\n\t.open\t\t= proc_seq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_seq_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/cache.h>\n\nstatic const struct file_operations proc_seq_fops = {\n\t.open\t\t= proc_seq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= proc_seq_release,\n};\n\nstruct proc_dir_entry *proc_create_seq_private(const char *name, umode_t mode,\n\t\tstruct proc_dir_entry *parent, const struct seq_operations *ops,\n\t\tunsigned int state_size, void *data)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create_reg(name, mode, &parent, data);\n\tif (!p)\n\t\treturn NULL;\n\tp->proc_fops = &proc_seq_fops;\n\tp->seq_ops = ops;\n\tp->state_size = state_size;\n\treturn proc_register(parent, p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int __init proc_locks_init(void)\n{\n\tproc_create_seq_private(\"locks\", 0, NULL, &locks_seq_operations,\n\t\t\tsizeof(struct locks_iterator), NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "locks_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2773-2778",
    "snippet": "static void locks_stop(struct seq_file *f, void *v)\n\t__releases(&blocked_lock_lock)\n{\n\tspin_unlock(&blocked_lock_lock);\n\tpercpu_up_write(&file_rwsem);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);",
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&file_rwsem"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_stop(struct seq_file *f, void *v)\n\t__releases(&blocked_lock_lock)\n{\n\tspin_unlock(&blocked_lock_lock);\n\tpercpu_up_write(&file_rwsem);\n}"
  },
  {
    "function_name": "locks_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2765-2771",
    "snippet": "static void *locks_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\t++iter->li_pos;\n\treturn seq_hlist_next_percpu(v, &file_lock_list.hlist, &iter->li_cpu, pos);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_hlist_next_percpu",
          "args": [
            "v",
            "&file_lock_list.hlist",
            "&iter->li_cpu",
            "pos"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "seq_hlist_next_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "1074-1093",
          "snippet": "struct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nstruct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void *locks_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\t++iter->li_pos;\n\treturn seq_hlist_next_percpu(v, &file_lock_list.hlist, &iter->li_cpu, pos);\n}"
  },
  {
    "function_name": "locks_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2754-2763",
    "snippet": "static void *locks_start(struct seq_file *f, loff_t *pos)\n\t__acquires(&blocked_lock_lock)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\titer->li_pos = *pos + 1;\n\tpercpu_down_write(&file_rwsem);\n\tspin_lock(&blocked_lock_lock);\n\treturn seq_hlist_start_percpu(&file_lock_list.hlist, &iter->li_cpu, *pos);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);",
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_hlist_start_percpu",
          "args": [
            "&file_lock_list.hlist",
            "&iter->li_cpu",
            "*pos"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "seq_hlist_start_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "1050-1062",
          "snippet": "struct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nstruct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&file_rwsem"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void *locks_start(struct seq_file *f, loff_t *pos)\n\t__acquires(&blocked_lock_lock)\n{\n\tstruct locks_iterator *iter = f->private;\n\n\titer->li_pos = *pos + 1;\n\tpercpu_down_write(&file_rwsem);\n\tspin_lock(&blocked_lock_lock);\n\treturn seq_hlist_start_percpu(&file_lock_list.hlist, &iter->li_cpu, *pos);\n}"
  },
  {
    "function_name": "show_fd_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2736-2752",
    "snippet": "void show_fd_locks(struct seq_file *f,\n\t\t  struct file *filp, struct files_struct *files)\n{\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tint id = 0;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx)\n\t\treturn;\n\n\tspin_lock(&ctx->flc_lock);\n\t__show_fd_locks(f, &ctx->flc_flock, &id, filp, files);\n\t__show_fd_locks(f, &ctx->flc_posix, &id, filp, files);\n\t__show_fd_locks(f, &ctx->flc_lease, &id, filp, files);\n\tspin_unlock(&ctx->flc_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__show_fd_locks",
          "args": [
            "f",
            "&ctx->flc_lease",
            "&id",
            "filp",
            "files"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "__show_fd_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2716-2734",
          "snippet": "static void __show_fd_locks(struct seq_file *f,\n\t\t\tstruct list_head *head, int *id,\n\t\t\tstruct file *filp, struct files_struct *files)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, head, fl_list) {\n\n\t\tif (filp != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (fl->fl_owner != files &&\n\t\t    fl->fl_owner != filp)\n\t\t\tcontinue;\n\n\t\t(*id)++;\n\t\tseq_puts(f, \"lock:\\t\");\n\t\tlock_get_status(f, fl, *id, \"\");\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __show_fd_locks(struct seq_file *f,\n\t\t\tstruct list_head *head, int *id,\n\t\t\tstruct file *filp, struct files_struct *files)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, head, fl_list) {\n\n\t\tif (filp != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (fl->fl_owner != files &&\n\t\t    fl->fl_owner != filp)\n\t\t\tcontinue;\n\n\t\t(*id)++;\n\t\tseq_puts(f, \"lock:\\t\");\n\t\tlock_get_status(f, fl, *id, \"\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid show_fd_locks(struct seq_file *f,\n\t\t  struct file *filp, struct files_struct *files)\n{\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tint id = 0;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx)\n\t\treturn;\n\n\tspin_lock(&ctx->flc_lock);\n\t__show_fd_locks(f, &ctx->flc_flock, &id, filp, files);\n\t__show_fd_locks(f, &ctx->flc_posix, &id, filp, files);\n\t__show_fd_locks(f, &ctx->flc_lease, &id, filp, files);\n\tspin_unlock(&ctx->flc_lock);\n}"
  },
  {
    "function_name": "__show_fd_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2716-2734",
    "snippet": "static void __show_fd_locks(struct seq_file *f,\n\t\t\tstruct list_head *head, int *id,\n\t\t\tstruct file *filp, struct files_struct *files)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, head, fl_list) {\n\n\t\tif (filp != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (fl->fl_owner != files &&\n\t\t    fl->fl_owner != filp)\n\t\t\tcontinue;\n\n\t\t(*id)++;\n\t\tseq_puts(f, \"lock:\\t\");\n\t\tlock_get_status(f, fl, *id, \"\");\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_get_status",
          "args": [
            "f",
            "fl",
            "*id",
            "\"\""
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "lock_get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2618-2695",
          "snippet": "static void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl_pid = locks_translate_pid(fl, proc_pidns);\n\t/*\n\t * If lock owner is dead (and pid is freed) or not visible in current\n\t * pidns, zero is shown as a pid value. Check lock info from\n\t * init_pid_ns to get saved lock pid value.\n\t */\n\n\tif (fl->fl_file != NULL)\n\t\tinode = locks_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n\t\t/* userspace relies on this representation of dev_t */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl_pid = locks_translate_pid(fl, proc_pidns);\n\t/*\n\t * If lock owner is dead (and pid is freed) or not visible in current\n\t * pidns, zero is shown as a pid value. Check lock info from\n\t * init_pid_ns to get saved lock pid value.\n\t */\n\n\tif (fl->fl_file != NULL)\n\t\tinode = locks_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n\t\t/* userspace relies on this representation of dev_t */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "f",
            "\"lock:\\t\""
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "654-664",
          "snippet": "void seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "head",
            "fl_list"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __show_fd_locks(struct seq_file *f,\n\t\t\tstruct list_head *head, int *id,\n\t\t\tstruct file *filp, struct files_struct *files)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, head, fl_list) {\n\n\t\tif (filp != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (fl->fl_owner != files &&\n\t\t    fl->fl_owner != filp)\n\t\t\tcontinue;\n\n\t\t(*id)++;\n\t\tseq_puts(f, \"lock:\\t\");\n\t\tlock_get_status(f, fl, *id, \"\");\n\t}\n}"
  },
  {
    "function_name": "locks_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2697-2714",
    "snippet": "static int locks_show(struct seq_file *f, void *v)\n{\n\tstruct locks_iterator *iter = f->private;\n\tstruct file_lock *fl, *bfl;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl = hlist_entry(v, struct file_lock, fl_link);\n\n\tif (locks_translate_pid(fl, proc_pidns) == 0)\n\t\treturn 0;\n\n\tlock_get_status(f, fl, iter->li_pos, \"\");\n\n\tlist_for_each_entry(bfl, &fl->fl_block, fl_block)\n\t\tlock_get_status(f, bfl, iter->li_pos, \" ->\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_get_status",
          "args": [
            "f",
            "bfl",
            "iter->li_pos",
            "\" ->\""
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "lock_get_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2618-2695",
          "snippet": "static void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl_pid = locks_translate_pid(fl, proc_pidns);\n\t/*\n\t * If lock owner is dead (and pid is freed) or not visible in current\n\t * pidns, zero is shown as a pid value. Check lock info from\n\t * init_pid_ns to get saved lock pid value.\n\t */\n\n\tif (fl->fl_file != NULL)\n\t\tinode = locks_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n\t\t/* userspace relies on this representation of dev_t */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl_pid = locks_translate_pid(fl, proc_pidns);\n\t/*\n\t * If lock owner is dead (and pid is freed) or not visible in current\n\t * pidns, zero is shown as a pid value. Check lock info from\n\t * init_pid_ns to get saved lock pid value.\n\t */\n\n\tif (fl->fl_file != NULL)\n\t\tinode = locks_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n\t\t/* userspace relies on this representation of dev_t */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bfl",
            "&fl->fl_block",
            "fl_block"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_translate_pid",
          "args": [
            "fl",
            "proc_pidns"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "locks_translate_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2057-2079",
          "snippet": "static pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "v",
            "structfile_lock",
            "fl_link"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f->file"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int locks_show(struct seq_file *f, void *v)\n{\n\tstruct locks_iterator *iter = f->private;\n\tstruct file_lock *fl, *bfl;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl = hlist_entry(v, struct file_lock, fl_link);\n\n\tif (locks_translate_pid(fl, proc_pidns) == 0)\n\t\treturn 0;\n\n\tlock_get_status(f, fl, iter->li_pos, \"\");\n\n\tlist_for_each_entry(bfl, &fl->fl_block, fl_block)\n\t\tlock_get_status(f, bfl, iter->li_pos, \" ->\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_get_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2618-2695",
    "snippet": "static void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl_pid = locks_translate_pid(fl, proc_pidns);\n\t/*\n\t * If lock owner is dead (and pid is freed) or not visible in current\n\t * pidns, zero is shown as a pid value. Check lock info from\n\t * init_pid_ns to get saved lock pid value.\n\t */\n\n\tif (fl->fl_file != NULL)\n\t\tinode = locks_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n\t\t/* userspace relies on this representation of dev_t */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "f",
            "\"0 EOF\\n\""
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "654-664",
          "snippet": "void seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "f",
            "\"%Ld %Ld\\n\"",
            "fl->fl_start",
            "fl->fl_end"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "401-408",
          "snippet": "void seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "fl"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_breaking",
          "args": [
            "fl"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "lease_breaking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "142-145",
          "snippet": "static bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LEASE",
          "args": [
            "fl"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FLOCK",
          "args": [
            "fl"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1258-1283",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "fl"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "fl"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "fl->fl_file"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_translate_pid",
          "args": [
            "fl",
            "proc_pidns"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "locks_translate_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2057-2079",
          "snippet": "static pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f->file"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\n\t\t\t    loff_t id, char *pfx)\n{\n\tstruct inode *inode = NULL;\n\tunsigned int fl_pid;\n\tstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\n\n\tfl_pid = locks_translate_pid(fl, proc_pidns);\n\t/*\n\t * If lock owner is dead (and pid is freed) or not visible in current\n\t * pidns, zero is shown as a pid value. Check lock info from\n\t * init_pid_ns to get saved lock pid value.\n\t */\n\n\tif (fl->fl_file != NULL)\n\t\tinode = locks_inode(fl->fl_file);\n\n\tseq_printf(f, \"%lld:%s \", id, pfx);\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_flags & FL_ACCESS)\n\t\t\tseq_puts(f, \"ACCESS\");\n\t\telse if (IS_OFDLCK(fl))\n\t\t\tseq_puts(f, \"OFDLCK\");\n\t\telse\n\t\t\tseq_puts(f, \"POSIX \");\n\n\t\tseq_printf(f, \" %s \",\n\t\t\t     (inode == NULL) ? \"*NOINODE*\" :\n\t\t\t     mandatory_lock(inode) ? \"MANDATORY\" : \"ADVISORY \");\n\t} else if (IS_FLOCK(fl)) {\n\t\tif (fl->fl_type & LOCK_MAND) {\n\t\t\tseq_puts(f, \"FLOCK  MSNFS     \");\n\t\t} else {\n\t\t\tseq_puts(f, \"FLOCK  ADVISORY  \");\n\t\t}\n\t} else if (IS_LEASE(fl)) {\n\t\tif (fl->fl_flags & FL_DELEG)\n\t\t\tseq_puts(f, \"DELEG  \");\n\t\telse\n\t\t\tseq_puts(f, \"LEASE  \");\n\n\t\tif (lease_breaking(fl))\n\t\t\tseq_puts(f, \"BREAKING  \");\n\t\telse if (fl->fl_file)\n\t\t\tseq_puts(f, \"ACTIVE    \");\n\t\telse\n\t\t\tseq_puts(f, \"BREAKER   \");\n\t} else {\n\t\tseq_puts(f, \"UNKNOWN UNKNOWN  \");\n\t}\n\tif (fl->fl_type & LOCK_MAND) {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (fl->fl_type & LOCK_READ)\n\t\t\t       ? (fl->fl_type & LOCK_WRITE) ? \"RW   \" : \"READ \"\n\t\t\t       : (fl->fl_type & LOCK_WRITE) ? \"WRITE\" : \"NONE \");\n\t} else {\n\t\tseq_printf(f, \"%s \",\n\t\t\t       (lease_breaking(fl))\n\t\t\t       ? (fl->fl_type == F_UNLCK) ? \"UNLCK\" : \"READ \"\n\t\t\t       : (fl->fl_type == F_WRLCK) ? \"WRITE\" : \"READ \");\n\t}\n\tif (inode) {\n\t\t/* userspace relies on this representation of dev_t */\n\t\tseq_printf(f, \"%d %02x:%02x:%ld \", fl_pid,\n\t\t\t\tMAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino);\n\t} else {\n\t\tseq_printf(f, \"%d <none>:0 \", fl_pid);\n\t}\n\tif (IS_POSIX(fl)) {\n\t\tif (fl->fl_end == OFFSET_MAX)\n\t\t\tseq_printf(f, \"%Ld EOF\\n\", fl->fl_start);\n\t\telse\n\t\t\tseq_printf(f, \"%Ld %Ld\\n\", fl->fl_start, fl->fl_end);\n\t} else {\n\t\tseq_puts(f, \"0 EOF\\n\");\n\t}\n}"
  },
  {
    "function_name": "vfs_cancel_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2600-2605",
    "snippet": "int vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_CANCELLK, fl);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filp->f_op->lock",
          "args": [
            "filp",
            "F_CANCELLK",
            "fl"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_cancel_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_CANCELLK, fl);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_unblock_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2578-2590",
    "snippet": "int\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__locks_delete_block",
          "args": [
            "waiter"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "666-671",
          "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nint\nposix_unblock_lock(struct file_lock *waiter)\n{\n\tint status = 0;\n\n\tspin_lock(&blocked_lock_lock);\n\tif (waiter->fl_next)\n\t\t__locks_delete_block(waiter);\n\telse\n\t\tstatus = -ENOENT;\n\tspin_unlock(&blocked_lock_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "locks_remove_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2548-2570",
    "snippet": "void locks_remove_file(struct file *filp)\n{\n\tstruct file_lock_context *ctx;\n\n\tctx = smp_load_acquire(&locks_inode(filp)->i_flctx);\n\tif (!ctx)\n\t\treturn;\n\n\t/* remove any OFD locks */\n\tlocks_remove_posix(filp, filp);\n\n\t/* remove flock locks */\n\tlocks_remove_flock(filp, ctx);\n\n\t/* remove any leases */\n\tlocks_remove_lease(filp, ctx);\n\n\tspin_lock(&ctx->flc_lock);\n\tlocks_check_ctx_file_list(filp, &ctx->flc_posix, \"POSIX\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_flock, \"FLOCK\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_lease, \"LEASE\");\n\tspin_unlock(&ctx->flc_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_check_ctx_file_list",
          "args": [
            "filp",
            "&ctx->flc_lease",
            "\"LEASE\""
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "locks_check_ctx_file_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "265-279",
          "snippet": "static void\nlocks_check_ctx_file_list(struct file *filp, struct list_head *list,\n\t\t\t\tchar *list_type)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = locks_inode(filp);\n\n\tlist_for_each_entry(fl, list, fl_list)\n\t\tif (fl->fl_file == filp)\n\t\t\tpr_warn(\"Leaked %s lock on dev=0x%x:0x%x ino=0x%lx \"\n\t\t\t\t\" fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\",\n\t\t\t\tlist_type, MAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino,\n\t\t\t\tfl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_check_ctx_file_list(struct file *filp, struct list_head *list,\n\t\t\t\tchar *list_type)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = locks_inode(filp);\n\n\tlist_for_each_entry(fl, list, fl_list)\n\t\tif (fl->fl_file == filp)\n\t\t\tpr_warn(\"Leaked %s lock on dev=0x%x:0x%x ino=0x%lx \"\n\t\t\t\t\" fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\",\n\t\t\t\tlist_type, MAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino,\n\t\t\t\tfl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_remove_lease",
          "args": [
            "filp",
            "ctx"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2525-2543",
          "snippet": "static void\nlocks_remove_lease(struct file *filp, struct file_lock_context *ctx)\n{\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic void\nlocks_remove_lease(struct file *filp, struct file_lock_context *ctx)\n{\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_remove_flock",
          "args": [
            "filp",
            "ctx"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_flock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2499-2522",
          "snippet": "static void\nlocks_remove_flock(struct file *filp, struct file_lock_context *flctx)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK | FL_CLOSE,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct inode *inode = locks_inode(filp);\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_inode(inode, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_remove_flock(struct file *filp, struct file_lock_context *flctx)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK | FL_CLOSE,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct inode *inode = locks_inode(filp);\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_inode(inode, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_remove_posix",
          "args": [
            "filp",
            "filp"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_posix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2463-2494",
          "snippet": "void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tint error;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tctx =  smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\terror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n\ttrace_locks_remove_posix(inode, &lock, error);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tint error;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tctx =  smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\terror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n\ttrace_locks_remove_posix(inode, &lock, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&locks_inode(filp)->i_flctx"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_file(struct file *filp)\n{\n\tstruct file_lock_context *ctx;\n\n\tctx = smp_load_acquire(&locks_inode(filp)->i_flctx);\n\tif (!ctx)\n\t\treturn;\n\n\t/* remove any OFD locks */\n\tlocks_remove_posix(filp, filp);\n\n\t/* remove flock locks */\n\tlocks_remove_flock(filp, ctx);\n\n\t/* remove any leases */\n\tlocks_remove_lease(filp, ctx);\n\n\tspin_lock(&ctx->flc_lock);\n\tlocks_check_ctx_file_list(filp, &ctx->flc_posix, \"POSIX\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_flock, \"FLOCK\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_lease, \"LEASE\");\n\tspin_unlock(&ctx->flc_lock);\n}"
  },
  {
    "function_name": "locks_remove_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2525-2543",
    "snippet": "static void\nlocks_remove_lease(struct file *filp, struct file_lock_context *ctx)\n{\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "343-353",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "fl",
            "F_UNLCK",
            "&dispose"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "lease_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1359-1380",
          "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "fl",
            "tmp",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic void\nlocks_remove_lease(struct file *filp, struct file_lock_context *ctx)\n{\n\tstruct file_lock *fl, *tmp;\n\tLIST_HEAD(dispose);\n\n\tif (list_empty(&ctx->flc_lease))\n\t\treturn;\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\n\t\tif (filp == fl->fl_file)\n\t\t\tlease_modify(fl, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n}"
  },
  {
    "function_name": "locks_remove_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2499-2522",
    "snippet": "static void\nlocks_remove_flock(struct file *filp, struct file_lock_context *flctx)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK | FL_CLOSE,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct inode *inode = locks_inode(filp);\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_inode(inode, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl.fl_ops->fl_release_private",
          "args": [
            "&fl"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_inode",
          "args": [
            "inode",
            "&fl"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_inode_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1926-1942",
          "snippet": "static int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->flock",
          "args": [
            "filp",
            "F_SETLKW",
            "&fl"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&flctx->flc_flock"
          ],
          "line": 2512
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_remove_flock(struct file *filp, struct file_lock_context *flctx)\n{\n\tstruct file_lock fl = {\n\t\t.fl_owner = filp,\n\t\t.fl_pid = current->tgid,\n\t\t.fl_file = filp,\n\t\t.fl_flags = FL_FLOCK | FL_CLOSE,\n\t\t.fl_type = F_UNLCK,\n\t\t.fl_end = OFFSET_MAX,\n\t};\n\tstruct inode *inode = locks_inode(filp);\n\n\tif (list_empty(&flctx->flc_flock))\n\t\treturn;\n\n\tif (filp->f_op->flock)\n\t\tfilp->f_op->flock(filp, F_SETLKW, &fl);\n\telse\n\t\tflock_lock_inode(inode, &fl);\n\n\tif (fl.fl_ops && fl.fl_ops->fl_release_private)\n\t\tfl.fl_ops->fl_release_private(&fl);\n}"
  },
  {
    "function_name": "locks_remove_posix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2463-2494",
    "snippet": "void locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tint error;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tctx =  smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\terror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n\ttrace_locks_remove_posix(inode, &lock, error);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_locks_remove_posix",
          "args": [
            "inode",
            "&lock",
            "error"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.fl_ops->fl_release_private",
          "args": [
            "&lock"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "F_SETLK",
            "&lock",
            "NULL"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2191-2197",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_posix"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\n{\n\tint error;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock lock;\n\tstruct file_lock_context *ctx;\n\n\t/*\n\t * If there are no locks held on this file, we don't need to call\n\t * posix_lock_file().  Another process could be setting a lock on this\n\t * file at the same time, but we wouldn't remove that lock anyway.\n\t */\n\tctx =  smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty(&ctx->flc_posix))\n\t\treturn;\n\n\tlock.fl_type = F_UNLCK;\n\tlock.fl_flags = FL_POSIX | FL_CLOSE;\n\tlock.fl_start = 0;\n\tlock.fl_end = OFFSET_MAX;\n\tlock.fl_owner = owner;\n\tlock.fl_pid = current->tgid;\n\tlock.fl_file = filp;\n\tlock.fl_ops = NULL;\n\tlock.fl_lmops = NULL;\n\n\terror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\n\n\tif (lock.fl_ops && lock.fl_ops->fl_release_private)\n\t\tlock.fl_ops->fl_release_private(&lock);\n\ttrace_locks_remove_posix(inode, &lock, error);\n}"
  },
  {
    "function_name": "fcntl_setlk64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2374-2455",
    "snippet": "int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock64 *flock)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\terror = flock64_to_posix_lock(filp, file_lock, flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW64:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by releasing the\n\t * lock that was just acquired. There is no need to do that when we're\n\t * unlocking though, or for OFD locks.\n\t */\n\tif (!error && file_lock->fl_type != F_UNLCK &&\n\t    !(file_lock->fl_flags & FL_OFDLCK)) {\n\t\t/*\n\t\t * We need that spin_lock here - it prevents reordering between\n\t\t * update of i_flctx->flc_posix and check for it done in\n\t\t * close(). rcu_read_lock() wouldn't do.\n\t\t */\n\t\tspin_lock(&current->files->file_lock);\n\t\tf = fcheck(fd);\n\t\tspin_unlock(&current->files->file_lock);\n\t\tif (f != filp) {\n\t\t\tfile_lock->fl_type = F_UNLCK;\n\t\t\terror = do_lock_file_wait(filp, cmd, file_lock);\n\t\t\tWARN_ON_ONCE(error);\n\t\t\terror = -EBADF;\n\t\t}\n\t}\nout:\n\tlocks_free_lock(file_lock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "error"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lock_file_wait",
          "args": [
            "filp",
            "cmd",
            "file_lock"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "do_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2200-2222",
          "snippet": "static int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck",
          "args": [
            "fd"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_fmode_for_setlk",
          "args": [
            "file_lock"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "check_fmode_for_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2225-2238",
          "snippet": "static int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock64_to_posix_lock",
          "args": [
            "filp",
            "file_lock",
            "flock"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "flock64_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "455-500",
          "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "filp->f_mapping"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1258-1283",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock64 *flock)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\terror = flock64_to_posix_lock(filp, file_lock, flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW64;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW64:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by releasing the\n\t * lock that was just acquired. There is no need to do that when we're\n\t * unlocking though, or for OFD locks.\n\t */\n\tif (!error && file_lock->fl_type != F_UNLCK &&\n\t    !(file_lock->fl_flags & FL_OFDLCK)) {\n\t\t/*\n\t\t * We need that spin_lock here - it prevents reordering between\n\t\t * update of i_flctx->flc_posix and check for it done in\n\t\t * close(). rcu_read_lock() wouldn't do.\n\t\t */\n\t\tspin_lock(&current->files->file_lock);\n\t\tf = fcheck(fd);\n\t\tspin_unlock(&current->files->file_lock);\n\t\tif (f != filp) {\n\t\t\tfile_lock->fl_type = F_UNLCK;\n\t\t\terror = do_lock_file_wait(filp, cmd, file_lock);\n\t\t\tWARN_ON_ONCE(error);\n\t\t\terror = -EBADF;\n\t\t}\n\t}\nout:\n\tlocks_free_lock(file_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "fcntl_getlk64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2331-2369",
    "snippet": "int fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 *flock)\n{\n\tstruct file_lock *fl;\n\tint error;\n\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -EINVAL;\n\tif (flock->l_type != F_RDLCK && flock->l_type != F_WRLCK)\n\t\tgoto out;\n\n\terror = flock64_to_posix_lock(filp, fl, flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK64;\n\t\tfl->fl_flags |= FL_OFDLCK;\n\t\tfl->fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, fl);\n\tif (error)\n\t\tgoto out;\n\n\tflock->l_type = fl->fl_type;\n\tif (fl->fl_type != F_UNLCK)\n\t\tposix_lock_to_flock64(flock, fl);\n\nout:\n\tlocks_free_lock(fl);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_to_flock64",
          "args": [
            "flock",
            "fl"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_to_flock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2103-2111",
          "snippet": "static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_test_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2041-2047",
          "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock64_to_posix_lock",
          "args": [
            "filp",
            "fl",
            "flock"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "flock64_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "455-500",
          "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 *flock)\n{\n\tstruct file_lock *fl;\n\tint error;\n\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -EINVAL;\n\tif (flock->l_type != F_RDLCK && flock->l_type != F_WRLCK)\n\t\tgoto out;\n\n\terror = flock64_to_posix_lock(filp, fl, flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK64;\n\t\tfl->fl_flags |= FL_OFDLCK;\n\t\tfl->fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, fl);\n\tif (error)\n\t\tgoto out;\n\n\tflock->l_type = fl->fl_type;\n\tif (fl->fl_type != F_UNLCK)\n\t\tposix_lock_to_flock64(flock, fl);\n\nout:\n\tlocks_free_lock(fl);\n\treturn error;\n}"
  },
  {
    "function_name": "fcntl_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2243-2325",
    "snippet": "int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock *flock)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\terror = flock_to_posix_lock(filp, file_lock, flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by releasing the\n\t * lock that was just acquired. There is no need to do that when we're\n\t * unlocking though, or for OFD locks.\n\t */\n\tif (!error && file_lock->fl_type != F_UNLCK &&\n\t    !(file_lock->fl_flags & FL_OFDLCK)) {\n\t\t/*\n\t\t * We need that spin_lock here - it prevents reordering between\n\t\t * update of i_flctx->flc_posix and check for it done in\n\t\t * close(). rcu_read_lock() wouldn't do.\n\t\t */\n\t\tspin_lock(&current->files->file_lock);\n\t\tf = fcheck(fd);\n\t\tspin_unlock(&current->files->file_lock);\n\t\tif (f != filp) {\n\t\t\tfile_lock->fl_type = F_UNLCK;\n\t\t\terror = do_lock_file_wait(filp, cmd, file_lock);\n\t\t\tWARN_ON_ONCE(error);\n\t\t\terror = -EBADF;\n\t\t}\n\t}\nout:\n\ttrace_fcntl_setlk(inode, file_lock, error);\n\tlocks_free_lock(file_lock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_fcntl_setlk",
          "args": [
            "inode",
            "file_lock",
            "error"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "error"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lock_file_wait",
          "args": [
            "filp",
            "cmd",
            "file_lock"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "do_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2200-2222",
          "snippet": "static int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck",
          "args": [
            "fd"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&current->files->file_lock"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_fmode_for_setlk",
          "args": [
            "file_lock"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "check_fmode_for_setlk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2225-2238",
          "snippet": "static int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_to_posix_lock",
          "args": [
            "filp",
            "file_lock",
            "flock"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "flock_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "505-516",
          "snippet": "static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_writably_mapped",
          "args": [
            "filp->f_mapping"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1258-1283",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock *flock)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\t/* Don't allow mandatory locks on files that may be memory mapped\n\t * and shared.\n\t */\n\tif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\terror = flock_to_posix_lock(filp, file_lock, flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW;\n\t\tfile_lock->fl_flags |= FL_OFDLCK;\n\t\tfile_lock->fl_owner = filp;\n\t\t/* Fallthrough */\n\tcase F_SETLKW:\n\t\tfile_lock->fl_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Attempt to detect a close/fcntl race and recover by releasing the\n\t * lock that was just acquired. There is no need to do that when we're\n\t * unlocking though, or for OFD locks.\n\t */\n\tif (!error && file_lock->fl_type != F_UNLCK &&\n\t    !(file_lock->fl_flags & FL_OFDLCK)) {\n\t\t/*\n\t\t * We need that spin_lock here - it prevents reordering between\n\t\t * update of i_flctx->flc_posix and check for it done in\n\t\t * close(). rcu_read_lock() wouldn't do.\n\t\t */\n\t\tspin_lock(&current->files->file_lock);\n\t\tf = fcheck(fd);\n\t\tspin_unlock(&current->files->file_lock);\n\t\tif (f != filp) {\n\t\t\tfile_lock->fl_type = F_UNLCK;\n\t\t\terror = do_lock_file_wait(filp, cmd, file_lock);\n\t\t\tWARN_ON_ONCE(error);\n\t\t\terror = -EBADF;\n\t\t}\n\t}\nout:\n\ttrace_fcntl_setlk(inode, file_lock, error);\n\tlocks_free_lock(file_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "check_fmode_for_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2225-2238",
    "snippet": "static int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_fmode_for_setlk(struct file_lock *fl)\n{\n\tswitch (fl->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(fl->fl_file->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_lock_file_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2200-2222",
    "snippet": "static int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "fl"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "673-678",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl->fl_wait",
            "!fl->fl_next"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "cmd",
            "fl",
            "NULL"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2191-2197",
          "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_file_lock",
          "args": [
            "filp",
            "fl->fl_type"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\n\t\t\t     struct file_lock *fl)\n{\n\tint error;\n\n\terror = security_file_lock(filp, fl->fl_type);\n\tif (error)\n\t\treturn error;\n\n\tfor (;;) {\n\t\terror = vfs_lock_file(filp, cmd, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_lock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2191-2197",
    "snippet": "int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_lock_file",
          "args": [
            "filp",
            "fl",
            "conf"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1218-1222",
          "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn posix_lock_inode(locks_inode(filp), fl, conflock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn posix_lock_inode(locks_inode(filp), fl, conflock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->lock",
          "args": [
            "filp",
            "cmd",
            "fl"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, cmd, fl);\n\telse\n\t\treturn posix_lock_file(filp, fl, conf);\n}"
  },
  {
    "function_name": "fcntl_getlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2117-2156",
    "snippet": "int fcntl_getlk(struct file *filp, unsigned int cmd, struct flock *flock)\n{\n\tstruct file_lock *fl;\n\tint error;\n\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn -ENOMEM;\n\terror = -EINVAL;\n\tif (flock->l_type != F_RDLCK && flock->l_type != F_WRLCK)\n\t\tgoto out;\n\n\terror = flock_to_posix_lock(filp, fl, flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK;\n\t\tfl->fl_flags |= FL_OFDLCK;\n\t\tfl->fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, fl);\n\tif (error)\n\t\tgoto out;\n \n\tflock->l_type = fl->fl_type;\n\tif (fl->fl_type != F_UNLCK) {\n\t\terror = posix_lock_to_flock(flock, fl);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\nout:\n\tlocks_free_lock(fl);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_to_flock",
          "args": [
            "flock",
            "fl"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_to_flock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2103-2111",
          "snippet": "static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_test_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2041-2047",
          "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_to_posix_lock",
          "args": [
            "filp",
            "fl",
            "flock"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "flock_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "505-516",
          "snippet": "static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_getlk(struct file *filp, unsigned int cmd, struct flock *flock)\n{\n\tstruct file_lock *fl;\n\tint error;\n\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn -ENOMEM;\n\terror = -EINVAL;\n\tif (flock->l_type != F_RDLCK && flock->l_type != F_WRLCK)\n\t\tgoto out;\n\n\terror = flock_to_posix_lock(filp, fl, flock);\n\tif (error)\n\t\tgoto out;\n\n\tif (cmd == F_OFD_GETLK) {\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_GETLK;\n\t\tfl->fl_flags |= FL_OFDLCK;\n\t\tfl->fl_owner = filp;\n\t}\n\n\terror = vfs_test_lock(filp, fl);\n\tif (error)\n\t\tgoto out;\n \n\tflock->l_type = fl->fl_type;\n\tif (fl->fl_type != F_UNLCK) {\n\t\terror = posix_lock_to_flock(flock, fl);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\nout:\n\tlocks_free_lock(fl);\n\treturn error;\n}"
  },
  {
    "function_name": "posix_lock_to_flock64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2103-2111",
    "snippet": "static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_translate_pid",
          "args": [
            "fl",
            "task_active_pid_ns(current)"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "locks_translate_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2057-2079",
          "snippet": "static pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n}"
  },
  {
    "function_name": "posix_lock_to_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2081-2100",
    "snippet": "static int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n#if BITS_PER_LONG == 32\n\t/*\n\t * Make sure we can represent the posix lock via\n\t * legacy 32bit flock.\n\t */\n\tif (fl->fl_start > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n\tif (fl->fl_end != OFFSET_MAX && fl->fl_end > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n#endif\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_translate_pid",
          "args": [
            "fl",
            "task_active_pid_ns(current)"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "locks_translate_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2057-2079",
          "snippet": "static pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)\n{\n\tflock->l_pid = locks_translate_pid(fl, task_active_pid_ns(current));\n#if BITS_PER_LONG == 32\n\t/*\n\t * Make sure we can represent the posix lock via\n\t * legacy 32bit flock.\n\t */\n\tif (fl->fl_start > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n\tif (fl->fl_end != OFFSET_MAX && fl->fl_end > OFFT_OFFSET_MAX)\n\t\treturn -EOVERFLOW;\n#endif\n\tflock->l_start = fl->fl_start;\n\tflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\n\t\tfl->fl_end - fl->fl_start + 1;\n\tflock->l_whence = 0;\n\tflock->l_type = fl->fl_type;\n\treturn 0;\n}"
  },
  {
    "function_name": "locks_translate_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2057-2079",
    "snippet": "static pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_nr_ns",
          "args": [
            "pid",
            "ns"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_pid_ns",
          "args": [
            "fl->fl_pid",
            "&init_pid_ns"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_REMOTELCK",
          "args": [
            "fl"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "fl"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic pid_t locks_translate_pid(struct file_lock *fl, struct pid_namespace *ns)\n{\n\tpid_t vnr;\n\tstruct pid *pid;\n\n\tif (IS_OFDLCK(fl))\n\t\treturn -1;\n\tif (IS_REMOTELCK(fl))\n\t\treturn fl->fl_pid;\n\t/*\n\t * If the flock owner process is dead and its pid has been already\n\t * freed, the translation below won't work, but we still want to show\n\t * flock owner pid number in init pidns.\n\t */\n\tif (ns == &init_pid_ns)\n\t\treturn (pid_t)fl->fl_pid;\n\n\trcu_read_lock();\n\tpid = find_pid_ns(fl->fl_pid, &init_pid_ns);\n\tvnr = pid_nr_ns(pid, ns);\n\trcu_read_unlock();\n\treturn vnr;\n}"
  },
  {
    "function_name": "vfs_test_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "2041-2047",
    "snippet": "int vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_test_lock",
          "args": [
            "filp",
            "fl"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "posix_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "812-836",
          "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = locks_inode(filp);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = locks_inode(filp);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->lock",
          "args": [
            "filp",
            "F_GETLK",
            "fl"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tif (filp->f_op->lock)\n\t\treturn filp->f_op->lock(filp, F_GETLK, fl);\n\tposix_test_lock(filp, fl);\n\treturn 0;\n}"
  },
  {
    "function_name": "locks_lock_inode_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1951-1965",
    "snippet": "int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_inode_wait(inode, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_inode_wait(inode, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_inode_wait",
          "args": [
            "inode",
            "fl"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_inode_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1926-1942",
          "snippet": "static int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_lock_inode_wait",
          "args": [
            "inode",
            "fl"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_inode_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1232-1248",
          "snippet": "static int posix_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_inode(inode, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_inode(inode, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_inode_wait(inode, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_inode_wait(inode, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "flock_lock_inode_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1926-1942",
    "snippet": "static int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "fl"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "673-678",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl->fl_wait",
            "!fl->fl_next"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_inode",
          "args": [
            "inode",
            "fl"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_inode_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1926-1942",
          "snippet": "static int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_inode(inode, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "fcntl_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1912-1917",
    "snippet": "int fcntl_setlease(unsigned int fd, struct file *filp, long arg)\n{\n\tif (arg == F_UNLCK)\n\t\treturn vfs_setlease(filp, F_UNLCK, NULL, (void **)&filp);\n\treturn do_fcntl_add_lease(fd, filp, arg);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_fcntl_add_lease",
          "args": [
            "fd",
            "filp",
            "arg"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "do_fcntl_add_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1877-1900",
          "snippet": "static int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "F_UNLCK",
            "NULL",
            "(void **)&filp"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1867-1874",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint fcntl_setlease(unsigned int fd, struct file *filp, long arg)\n{\n\tif (arg == F_UNLCK)\n\t\treturn vfs_setlease(filp, F_UNLCK, NULL, (void **)&filp);\n\treturn do_fcntl_add_lease(fd, filp, arg);\n}"
  },
  {
    "function_name": "do_fcntl_add_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1877-1900",
    "snippet": "static int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fasync_free",
          "args": [
            "new"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "903-906",
          "snippet": "void fasync_free(struct fasync_struct *new)\n{\n\tkmem_cache_free(fasync_cache, new);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fasync_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *fasync_cache;\n\nvoid fasync_free(struct fasync_struct *new)\n{\n\tkmem_cache_free(fasync_cache, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "arg",
            "&fl",
            "(void **)&new"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1867-1874",
          "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fasync_alloc",
          "args": [],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "893-896",
          "snippet": "struct fasync_struct *fasync_alloc(void)\n{\n\treturn kmem_cache_alloc(fasync_cache, GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fasync_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *fasync_cache;\n\nstruct fasync_struct *fasync_alloc(void)\n{\n\treturn kmem_cache_alloc(fasync_cache, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fl"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fl"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_alloc",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "lease_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "570-584",
          "snippet": "static struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\n{\n\tstruct file_lock *fl;\n\tstruct fasync_struct *new;\n\tint error;\n\n\tfl = lease_alloc(filp, arg);\n\tif (IS_ERR(fl))\n\t\treturn PTR_ERR(fl);\n\n\tnew = fasync_alloc();\n\tif (!new) {\n\t\tlocks_free_lock(fl);\n\t\treturn -ENOMEM;\n\t}\n\tnew->fa_fd = fd;\n\n\terror = vfs_setlease(filp, arg, &fl, (void **)&new);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (new)\n\t\tfasync_free(new);\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1867-1874",
    "snippet": "int\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_setlease",
          "args": [
            "filp",
            "arg",
            "lease",
            "priv"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "generic_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1819-1847",
          "snippet": "int generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct inode *inode = locks_inode(filp);\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct inode *inode = locks_inode(filp);\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp->f_op->setlease",
          "args": [
            "filp",
            "arg",
            "lease",
            "priv"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\n{\n\tif (filp->f_op->setlease)\n\t\treturn filp->f_op->setlease(filp, arg, lease, priv);\n\telse\n\t\treturn generic_setlease(filp, arg, lease, priv);\n}"
  },
  {
    "function_name": "generic_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1819-1847",
    "snippet": "int generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct inode *inode = locks_inode(filp);\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_add_lease",
          "args": [
            "filp",
            "arg",
            "flp",
            "priv"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "generic_add_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1659-1774",
          "snippet": "static int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\t/* Note that arg is never F_UNLCK here */\n\tctx = locks_get_lock_context(inode, arg);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !inode_trylock(inode))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tinode_unlock(inode);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tinode_unlock(inode);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int leases_enable = 1;",
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint leases_enable = 1;\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\t/* Note that arg is never F_UNLCK here */\n\tctx = locks_get_lock_context(inode, arg);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !inode_trylock(inode))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tinode_unlock(inode);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tinode_unlock(inode);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_delete_lease",
          "args": [
            "filp",
            "*priv"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "generic_delete_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1776-1806",
          "snippet": "static int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tLIST_HEAD(dispose);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tLIST_HEAD(dispose);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_file_lock",
          "args": [
            "filp",
            "arg"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LEASE"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint generic_setlease(struct file *filp, long arg, struct file_lock **flp,\n\t\t\tvoid **priv)\n{\n\tstruct inode *inode = locks_inode(filp);\n\tint error;\n\n\tif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\n\t\treturn -EACCES;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\terror = security_file_lock(filp, arg);\n\tif (error)\n\t\treturn error;\n\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\treturn generic_delete_lease(filp, *priv);\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (!(*flp)->fl_lmops->lm_break) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -ENOLCK;\n\t\t}\n\n\t\treturn generic_add_lease(filp, arg, flp, priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "generic_delete_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1776-1806",
    "snippet": "static int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tLIST_HEAD(dispose);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "343-353",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_change",
          "args": [
            "victim",
            "F_UNLCK",
            "&dispose"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_generic_delete_lease",
          "args": [
            "inode",
            "victim"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_generic_delete_lease",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic int generic_delete_lease(struct file *filp, void *owner)\n{\n\tint error = -EAGAIN;\n\tstruct file_lock *fl, *victim = NULL;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tLIST_HEAD(dispose);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx) {\n\t\ttrace_generic_delete_lease(inode, NULL);\n\t\treturn error;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == owner) {\n\t\t\tvictim = fl;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttrace_generic_delete_lease(inode, victim);\n\tif (victim)\n\t\terror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\treturn error;\n}"
  },
  {
    "function_name": "generic_add_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1659-1774",
    "snippet": "static int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\t/* Note that arg is never F_UNLCK here */\n\tctx = locks_get_lock_context(inode, arg);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !inode_trylock(inode))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tinode_unlock(inode);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tinode_unlock(inode);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int leases_enable = 1;",
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "343-353",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease->fl_lmops->lm_setup",
          "args": [
            "lease",
            "priv"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_unlink_lock_ctx",
          "args": [
            "lease"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "locks_unlink_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "748-754",
          "snippet": "static void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tlocks_wake_up_blocks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tlocks_wake_up_blocks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_conflicting_open",
          "args": [
            "dentry",
            "arg",
            "lease->fl_flags"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "check_conflicting_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1640-1657",
          "snippet": "static int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_insert_lock_ctx",
          "args": [
            "lease",
            "&ctx->flc_lease"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "741-746",
          "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease->fl_lmops->lm_change",
          "args": [
            "lease",
            "arg",
            "&dispose"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_out_leases",
          "args": [
            "inode",
            "&dispose"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "time_out_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1391-1405",
          "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_trylock",
          "args": [
            "inode"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_get_lock_context",
          "args": [
            "inode",
            "arg"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "locks_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "206-236",
          "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_generic_add_lease",
          "args": [
            "inode",
            "lease"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint leases_enable = 1;\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic int\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\n{\n\tstruct file_lock *fl, *my_fl = NULL, *lease;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct file_lock_context *ctx;\n\tbool is_deleg = (*flp)->fl_flags & FL_DELEG;\n\tint error;\n\tLIST_HEAD(dispose);\n\n\tlease = *flp;\n\ttrace_generic_add_lease(inode, lease);\n\n\t/* Note that arg is never F_UNLCK here */\n\tctx = locks_get_lock_context(inode, arg);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * In the delegation case we need mutual exclusion with\n\t * a number of operations that take the i_mutex.  We trylock\n\t * because delegations are an optional optimization, and if\n\t * there's some chance of a conflict--we'd rather not\n\t * bother, maybe that's a sign this just isn't a good file to\n\t * hand out a delegation on.\n\t */\n\tif (is_deleg && !inode_trylock(inode))\n\t\treturn -EAGAIN;\n\n\tif (is_deleg && arg == F_WRLCK) {\n\t\t/* Write delegations are not currently supported: */\n\t\tinode_unlock(inode);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttime_out_leases(inode, &dispose);\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * At this point, we know that if there is an exclusive\n\t * lease on this file, then we hold it on this filp\n\t * (otherwise our open of this file would have blocked).\n\t * And if we are trying to acquire an exclusive lease,\n\t * then the file is not open by anyone (including us)\n\t * except for this filp.\n\t */\n\terror = -EAGAIN;\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (fl->fl_file == filp &&\n\t\t    fl->fl_owner == lease->fl_owner) {\n\t\t\tmy_fl = fl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * No exclusive leases if someone else has a lease on\n\t\t * this file:\n\t\t */\n\t\tif (arg == F_WRLCK)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Modifying our existing lease is OK, but no getting a\n\t\t * new lease if someone else is opening for write:\n\t\t */\n\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\tgoto out;\n\t}\n\n\tif (my_fl != NULL) {\n\t\tlease = my_fl;\n\t\terror = lease->fl_lmops->lm_change(lease, arg, &dispose);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tgoto out_setup;\n\t}\n\n\terror = -EINVAL;\n\tif (!leases_enable)\n\t\tgoto out;\n\n\tlocks_insert_lock_ctx(lease, &ctx->flc_lease);\n\t/*\n\t * The check in break_lease() is lockless. It's possible for another\n\t * open to race in after we did the earlier check for a conflicting\n\t * open but before the lease was inserted. Check again for a\n\t * conflicting open and cancel the lease if there is one.\n\t *\n\t * We also add a barrier here to ensure that the insertion of the lock\n\t * precedes these checks.\n\t */\n\tsmp_mb();\n\terror = check_conflicting_open(dentry, arg, lease->fl_flags);\n\tif (error) {\n\t\tlocks_unlink_lock_ctx(lease);\n\t\tgoto out;\n\t}\n\nout_setup:\n\tif (lease->fl_lmops->lm_setup)\n\t\tlease->fl_lmops->lm_setup(lease, priv);\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\tif (is_deleg)\n\t\tinode_unlock(inode);\n\tif (!error && !my_fl)\n\t\t*flp = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "check_conflicting_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1640-1657",
    "snippet": "static int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "dentry"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/nfs4state.c",
          "lines": "480-484",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"nfs4idmap.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"nfs4idmap.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\n{\n\tint ret = 0;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (flags & FL_LAYOUT)\n\t\treturn 0;\n\n\tif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\n\t\treturn -EAGAIN;\n\n\tif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\n\t    (atomic_read(&inode->i_count) > 1)))\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fcntl_getlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1602-1627",
    "snippet": "int fcntl_getlease(struct file *filp)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tint type = F_UNLCK;\n\tLIST_HEAD(dispose);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tpercpu_down_read_preempt_disable(&file_rwsem);\n\t\tspin_lock(&ctx->flc_lock);\n\t\ttime_out_leases(inode, &dispose);\n\t\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\t\tif (fl->fl_file != filp)\n\t\t\t\tcontinue;\n\t\t\ttype = target_leasetype(fl);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\t\tlocks_dispose_list(&dispose);\n\t}\n\treturn type;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "343-353",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "target_leasetype",
          "args": [
            "fl"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "target_leasetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "147-154",
          "snippet": "static int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_out_leases",
          "args": [
            "inode",
            "&dispose"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "time_out_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1391-1405",
          "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nint fcntl_getlease(struct file *filp)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = locks_inode(filp);\n\tstruct file_lock_context *ctx;\n\tint type = F_UNLCK;\n\tLIST_HEAD(dispose);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tpercpu_down_read_preempt_disable(&file_rwsem);\n\t\tspin_lock(&ctx->flc_lock);\n\t\ttime_out_leases(inode, &dispose);\n\t\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\t\tif (fl->fl_file != filp)\n\t\t\t\tcontinue;\n\t\t\ttype = target_leasetype(fl);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->flc_lock);\n\t\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\t\tlocks_dispose_list(&dispose);\n\t}\n\treturn type;\n}"
  },
  {
    "function_name": "lease_get_mtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1557-1575",
    "snippet": "void lease_get_mtime(struct inode *inode, struct timespec64 *time)\n{\n\tbool has_lease = false;\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tfl = list_first_entry_or_null(&ctx->flc_lease,\n\t\t\t\t\t      struct file_lock, fl_list);\n\t\tif (fl && (fl->fl_type == F_WRLCK))\n\t\t\thas_lease = true;\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\n\tif (has_lease)\n\t\t*time = current_time(inode);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&ctx->flc_lease",
            "structfile_lock",
            "fl_list"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid lease_get_mtime(struct inode *inode, struct timespec64 *time)\n{\n\tbool has_lease = false;\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (ctx && !list_empty_careful(&ctx->flc_lease)) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tfl = list_first_entry_or_null(&ctx->flc_lease,\n\t\t\t\t\t      struct file_lock, fl_list);\n\t\tif (fl && (fl->fl_type == F_WRLCK))\n\t\t\thas_lease = true;\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\n\tif (has_lease)\n\t\t*time = current_time(inode);\n}"
  },
  {
    "function_name": "__break_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1444-1544",
    "snippet": "int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\tint error = 0;\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *new_fl, *fl, *tmp;\n\tunsigned long break_time;\n\tint want_write = (mode & O_ACCMODE) != O_RDONLY;\n\tLIST_HEAD(dispose);\n\n\tnew_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);\n\tif (IS_ERR(new_fl))\n\t\treturn PTR_ERR(new_fl);\n\tnew_fl->fl_flags = type;\n\n\t/* typically we will check that ctx is non-NULL before calling */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn error;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\n\ttime_out_leases(inode, &dispose);\n\n\tif (!any_leases_conflict(inode, new_fl))\n\t\tgoto out;\n\n\tbreak_time = 0;\n\tif (lease_break_time > 0) {\n\t\tbreak_time = jiffies + lease_break_time * HZ;\n\t\tif (break_time == 0)\n\t\t\tbreak_time++;\t/* so that 0 means no break time */\n\t}\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\tif (!leases_conflict(fl, new_fl))\n\t\t\tcontinue;\n\t\tif (want_write) {\n\t\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_UNLOCK_PENDING;\n\t\t\tfl->fl_break_time = break_time;\n\t\t} else {\n\t\t\tif (lease_breaking(fl))\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_DOWNGRADE_PENDING;\n\t\t\tfl->fl_downgrade_time = break_time;\n\t\t}\n\t\tif (fl->fl_lmops->lm_break(fl))\n\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t}\n\n\tif (list_empty(&ctx->flc_lease))\n\t\tgoto out;\n\n\tif (mode & O_NONBLOCK) {\n\t\ttrace_break_lease_noblock(inode, new_fl);\n\t\terror = -EWOULDBLOCK;\n\t\tgoto out;\n\t}\n\nrestart:\n\tfl = list_first_entry(&ctx->flc_lease, struct file_lock, fl_list);\n\tbreak_time = fl->fl_break_time;\n\tif (break_time != 0)\n\t\tbreak_time -= jiffies;\n\tif (break_time == 0)\n\t\tbreak_time++;\n\tlocks_insert_block(fl, new_fl);\n\ttrace_break_lease_block(inode, new_fl);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n\terror = wait_event_interruptible_timeout(new_fl->fl_wait,\n\t\t\t\t\t\t!new_fl->fl_next, break_time);\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttrace_break_lease_unblock(inode, new_fl);\n\tlocks_delete_block(new_fl);\n\tif (error >= 0) {\n\t\t/*\n\t\t * Wait for the next conflicting lease that has not been\n\t\t * broken yet\n\t\t */\n\t\tif (error == 0)\n\t\t\ttime_out_leases(inode, &dispose);\n\t\tif (any_leases_conflict(inode, new_fl))\n\t\t\tgoto restart;\n\t\terror = 0;\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\tlocks_free_lock(new_fl);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int lease_break_time = 45;",
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "new_fl"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "343-353",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_leases_conflict",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "any_leases_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1416-1429",
          "snippet": "static bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_out_leases",
          "args": [
            "inode",
            "&dispose"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "time_out_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1391-1405",
          "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "new_fl"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "673-678",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_break_lease_unblock",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "new_fl->fl_wait",
            "!new_fl->fl_next",
            "break_time"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_break_lease_block",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_insert_block",
          "args": [
            "fl",
            "new_fl"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "701-707",
          "snippet": "static void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ctx->flc_lease",
            "structfile_lock",
            "fl_list"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_break_lease_noblock",
          "args": [
            "inode",
            "new_fl"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "&dispose"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "756-764",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_break",
          "args": [
            "fl"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_breaking",
          "args": [
            "fl"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "lease_breaking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "142-145",
          "snippet": "static bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "fl",
            "tmp",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_fl"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_fl"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease_alloc",
          "args": [
            "NULL",
            "want_write ? F_WRLCK : F_RDLCK"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "lease_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "570-584",
          "snippet": "static struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_break_time = 45;\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nint __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\n{\n\tint error = 0;\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *new_fl, *fl, *tmp;\n\tunsigned long break_time;\n\tint want_write = (mode & O_ACCMODE) != O_RDONLY;\n\tLIST_HEAD(dispose);\n\n\tnew_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);\n\tif (IS_ERR(new_fl))\n\t\treturn PTR_ERR(new_fl);\n\tnew_fl->fl_flags = type;\n\n\t/* typically we will check that ctx is non-NULL before calling */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn error;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\n\ttime_out_leases(inode, &dispose);\n\n\tif (!any_leases_conflict(inode, new_fl))\n\t\tgoto out;\n\n\tbreak_time = 0;\n\tif (lease_break_time > 0) {\n\t\tbreak_time = jiffies + lease_break_time * HZ;\n\t\tif (break_time == 0)\n\t\t\tbreak_time++;\t/* so that 0 means no break time */\n\t}\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\tif (!leases_conflict(fl, new_fl))\n\t\t\tcontinue;\n\t\tif (want_write) {\n\t\t\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_UNLOCK_PENDING;\n\t\t\tfl->fl_break_time = break_time;\n\t\t} else {\n\t\t\tif (lease_breaking(fl))\n\t\t\t\tcontinue;\n\t\t\tfl->fl_flags |= FL_DOWNGRADE_PENDING;\n\t\t\tfl->fl_downgrade_time = break_time;\n\t\t}\n\t\tif (fl->fl_lmops->lm_break(fl))\n\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t}\n\n\tif (list_empty(&ctx->flc_lease))\n\t\tgoto out;\n\n\tif (mode & O_NONBLOCK) {\n\t\ttrace_break_lease_noblock(inode, new_fl);\n\t\terror = -EWOULDBLOCK;\n\t\tgoto out;\n\t}\n\nrestart:\n\tfl = list_first_entry(&ctx->flc_lease, struct file_lock, fl_list);\n\tbreak_time = fl->fl_break_time;\n\tif (break_time != 0)\n\t\tbreak_time -= jiffies;\n\tif (break_time == 0)\n\t\tbreak_time++;\n\tlocks_insert_block(fl, new_fl);\n\ttrace_break_lease_block(inode, new_fl);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\n\tlocks_dispose_list(&dispose);\n\terror = wait_event_interruptible_timeout(new_fl->fl_wait,\n\t\t\t\t\t\t!new_fl->fl_next, break_time);\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\ttrace_break_lease_unblock(inode, new_fl);\n\tlocks_delete_block(new_fl);\n\tif (error >= 0) {\n\t\t/*\n\t\t * Wait for the next conflicting lease that has not been\n\t\t * broken yet\n\t\t */\n\t\tif (error == 0)\n\t\t\ttime_out_leases(inode, &dispose);\n\t\tif (any_leases_conflict(inode, new_fl))\n\t\t\tgoto restart;\n\t\terror = 0;\n\t}\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tlocks_dispose_list(&dispose);\n\tlocks_free_lock(new_fl);\n\treturn error;\n}"
  },
  {
    "function_name": "any_leases_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1416-1429",
    "snippet": "static bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leases_conflict",
          "args": [
            "fl",
            "breaker"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "any_leases_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1416-1429",
          "snippet": "static bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\n\t\tif (leases_conflict(fl, breaker))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "leases_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1407-1414",
    "snippet": "static bool leases_conflict(struct file_lock *lease, struct file_lock *breaker)\n{\n\tif ((breaker->fl_flags & FL_LAYOUT) != (lease->fl_flags & FL_LAYOUT))\n\t\treturn false;\n\tif ((breaker->fl_flags & FL_DELEG) && (lease->fl_flags & FL_LEASE))\n\t\treturn false;\n\treturn locks_conflict(breaker, lease);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_conflict",
          "args": [
            "breaker",
            "lease"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "799-810",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool leases_conflict(struct file_lock *lease, struct file_lock *breaker)\n{\n\tif ((breaker->fl_flags & FL_LAYOUT) != (lease->fl_flags & FL_LAYOUT))\n\t\treturn false;\n\tif ((breaker->fl_flags & FL_DELEG) && (lease->fl_flags & FL_LEASE))\n\t\treturn false;\n\treturn locks_conflict(breaker, lease);\n}"
  },
  {
    "function_name": "time_out_leases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1391-1405",
    "snippet": "static void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "fl",
            "F_UNLCK",
            "dispose"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "lease_modify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1359-1380",
          "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "past_time",
          "args": [
            "fl->fl_break_time"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "past_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1383-1389",
          "snippet": "static bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_time_out_leases",
          "args": [
            "inode",
            "fl"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "fl",
            "tmp",
            "&ctx->flc_lease",
            "fl_list"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tstruct file_lock *fl, *tmp;\n\n\tlockdep_assert_held(&ctx->flc_lock);\n\n\tlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\n\t\ttrace_time_out_leases(inode, fl);\n\t\tif (past_time(fl->fl_downgrade_time))\n\t\t\tlease_modify(fl, F_RDLCK, dispose);\n\t\tif (past_time(fl->fl_break_time))\n\t\t\tlease_modify(fl, F_UNLCK, dispose);\n\t}\n}"
  },
  {
    "function_name": "past_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1383-1389",
    "snippet": "static bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "then"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool past_time(unsigned long then)\n{\n\tif (!then)\n\t\t/* 0 is a special value meaning \"this never expires\": */\n\t\treturn false;\n\treturn time_after(jiffies, then);\n}"
  },
  {
    "function_name": "lease_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1359-1380",
    "snippet": "int lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "dispose"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "756-764",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"locks_delete_lock: fasync == %p\\n\"",
            "fl->fl_fasync"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fasync_helper",
          "args": [
            "0",
            "fl->fl_file",
            "0",
            "&fl->fl_fasync"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "978-983",
          "snippet": "int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nint fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f_delown",
          "args": [
            "filp"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "f_delown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "144-147",
          "snippet": "void f_delown(struct file *filp)\n{\n\tf_modown(filp, NULL, PIDTYPE_TGID, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid f_delown(struct file *filp)\n{\n\tf_modown(filp, NULL, PIDTYPE_TGID, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_wake_up_blocks",
          "args": [
            "fl"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_clear_pending",
          "args": [
            "fl",
            "arg"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "lease_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1347-1356",
          "snippet": "static void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assign_type",
          "args": [
            "fl",
            "arg"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "assign_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "441-453",
          "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\n{\n\tint error = assign_type(fl, arg);\n\n\tif (error)\n\t\treturn error;\n\tlease_clear_pending(fl, arg);\n\tlocks_wake_up_blocks(fl);\n\tif (arg == F_UNLCK) {\n\t\tstruct file *filp = fl->fl_file;\n\n\t\tf_delown(filp);\n\t\tfilp->f_owner.signum = 0;\n\t\tfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\n\t\tif (fl->fl_fasync != NULL) {\n\t\t\tprintk(KERN_ERR \"locks_delete_lock: fasync == %p\\n\", fl->fl_fasync);\n\t\t\tfl->fl_fasync = NULL;\n\t\t}\n\t\tlocks_delete_lock_ctx(fl, dispose);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lease_clear_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1347-1356",
    "snippet": "static void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void lease_clear_pending(struct file_lock *fl, int arg)\n{\n\tswitch (arg) {\n\tcase F_UNLCK:\n\t\tfl->fl_flags &= ~FL_UNLOCK_PENDING;\n\t\t/* fall through: */\n\tcase F_RDLCK:\n\t\tfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\n\t}\n}"
  },
  {
    "function_name": "locks_mandatory_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1295-1342",
    "snippet": "int locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,\n\t\t\t loff_t end, unsigned char type)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = type;\n\tfl.fl_start = start;\n\tfl.fl_end = end;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "&fl"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "673-678",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl.fl_wait",
            "!fl.fl_next"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_inode",
          "args": [
            "inode",
            "&fl",
            "NULL"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "988-1202",
          "snippet": "static int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);",
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "&fl"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "355-359",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,\n\t\t\t loff_t end, unsigned char type)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = type;\n\tfl.fl_start = start;\n\tfl.fl_end = end;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "locks_mandatory_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1258-1283",
    "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_posix"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "file"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_lock_inode_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1232-1248",
    "snippet": "static int posix_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_inode(inode, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_delete_block",
          "args": [
            "fl"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "673-678",
          "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "fl->fl_wait",
            "!fl->fl_next"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_lock_inode",
          "args": [
            "inode",
            "fl",
            "NULL"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "988-1202",
          "snippet": "static int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);",
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_lock_inode_wait(struct inode *inode, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep ();\n\tfor (;;) {\n\t\terror = posix_lock_inode(inode, fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "posix_lock_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1218-1222",
    "snippet": "int posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn posix_lock_inode(locks_inode(filp), fl, conflock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_lock_inode",
          "args": [
            "locks_inode(filp)",
            "fl",
            "conflock"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "posix_lock_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "988-1202",
          "snippet": "static int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);",
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint posix_lock_file(struct file *filp, struct file_lock *fl,\n\t\t\tstruct file_lock *conflock)\n{\n\treturn posix_lock_inode(locks_inode(filp), fl, conflock);\n}"
  },
  {
    "function_name": "posix_lock_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "988-1202",
    "snippet": "static int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);",
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_posix_lock_inode",
          "args": [
            "inode",
            "request",
            "error"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "343-353",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "new_fl2"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_wake_up_blocks",
          "args": [
            "left"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_insert_lock_ctx",
          "args": [
            "left",
            "&fl->fl_list"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "741-746",
          "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_lock",
          "args": [
            "left",
            "right"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "385-399",
          "snippet": "void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "&dispose"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "756-764",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "request",
            "fl"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "597-603",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_from",
          "args": [
            "fl",
            "tmp",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__locks_insert_block",
          "args": [
            "fl",
            "request"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "690-698",
          "snippet": "static void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!posix_locks_deadlock(request, fl)"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_locks_deadlock",
          "args": [
            "request",
            "fl"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "posix_locks_deadlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "887-908",
          "snippet": "static int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define MAX_DEADLK_ITERATIONS 10"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\n#define MAX_DEADLK_ITERATIONS 10\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_conflock",
          "args": [
            "conflock",
            "fl"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_conflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "366-382",
          "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_locks_conflict",
          "args": [
            "request",
            "fl"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "posix_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "781-794",
          "snippet": "static int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_get_lock_context",
          "args": [
            "inode",
            "request->fl_type"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "locks_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "206-236",
          "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx)\n\t\treturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->fl_flags & FL_ACCESS) &&\n\t    (request->fl_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->fl_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\t\tif (!posix_locks_conflict(request, fl))\n\t\t\t\tcontinue;\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(fl, request);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n  \t\t}\n  \t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_same_owner(request, fl))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\n\t\tif (!posix_same_owner(request, fl))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->fl_type == fl->fl_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (request->fl_type == F_UNLCK)\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(request, &fl->fl_list);\n\t\t\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (request->fl_type == F_UNLCK) {\n\t\t\tif (request->fl_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_insert_lock_ctx(new_fl, &fl->fl_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(left, &fl->fl_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(right);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(left);\n\t}\n out:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\ttrace_posix_lock_inode(inode, request, error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "flock_lock_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "917-986",
    "snippet": "static int flock_lock_inode(struct inode *inode, struct file_lock *request)\n{\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *fl;\n\tstruct file_lock_context *ctx;\n\tint error = 0;\n\tbool found = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx) {\n\t\tif (request->fl_type != F_UNLCK)\n\t\t\treturn -ENOMEM;\n\t\treturn (request->fl_flags & FL_EXISTS) ? -ENOENT : 0;\n\t}\n\n\tif (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tif (!new_fl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto find_conflict;\n\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (request->fl_file != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (request->fl_type == fl->fl_type)\n\t\t\tgoto out;\n\t\tfound = true;\n\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\tbreak;\n\t}\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif ((request->fl_flags & FL_EXISTS) && !found)\n\t\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\nfind_conflict:\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (!flock_locks_conflict(request, fl))\n\t\t\tcontinue;\n\t\terror = -EAGAIN;\n\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\tgoto out;\n\t\terror = FILE_LOCK_DEFERRED;\n\t\tlocks_insert_block(fl, request);\n\t\tgoto out;\n\t}\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\tlocks_copy_lock(new_fl, request);\n\tlocks_insert_lock_ctx(new_fl, &ctx->flc_flock);\n\tnew_fl = NULL;\n\terror = 0;\n\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tlocks_dispose_list(&dispose);\n\ttrace_flock_lock_inode(inode, request, error);\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_flock_lock_inode",
          "args": [
            "inode",
            "request",
            "error"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "343-353",
          "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "new_fl"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_read_preempt_enable",
          "args": [
            "&file_rwsem"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_insert_lock_ctx",
          "args": [
            "new_fl",
            "&ctx->flc_flock"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "741-746",
          "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_lock",
          "args": [
            "new_fl",
            "request"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "385-399",
          "snippet": "void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_insert_block",
          "args": [
            "fl",
            "request"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "701-707",
          "snippet": "static void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_locks_conflict",
          "args": [
            "request",
            "fl"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "799-810",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_flock",
            "fl_list"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_delete_lock_ctx",
          "args": [
            "fl",
            "&dispose"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "756-764",
          "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&ctx->flc_flock",
            "fl_list"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_read_preempt_disable",
          "args": [
            "&file_rwsem"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_get_lock_context",
          "args": [
            "inode",
            "request->fl_type"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "locks_get_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "206-236",
          "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic int flock_lock_inode(struct inode *inode, struct file_lock *request)\n{\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *fl;\n\tstruct file_lock_context *ctx;\n\tint error = 0;\n\tbool found = false;\n\tLIST_HEAD(dispose);\n\n\tctx = locks_get_lock_context(inode, request->fl_type);\n\tif (!ctx) {\n\t\tif (request->fl_type != F_UNLCK)\n\t\t\treturn -ENOMEM;\n\t\treturn (request->fl_flags & FL_EXISTS) ? -ENOENT : 0;\n\t}\n\n\tif (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tif (!new_fl)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpercpu_down_read_preempt_disable(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto find_conflict;\n\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (request->fl_file != fl->fl_file)\n\t\t\tcontinue;\n\t\tif (request->fl_type == fl->fl_type)\n\t\t\tgoto out;\n\t\tfound = true;\n\t\tlocks_delete_lock_ctx(fl, &dispose);\n\t\tbreak;\n\t}\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif ((request->fl_flags & FL_EXISTS) && !found)\n\t\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\nfind_conflict:\n\tlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\n\t\tif (!flock_locks_conflict(request, fl))\n\t\t\tcontinue;\n\t\terror = -EAGAIN;\n\t\tif (!(request->fl_flags & FL_SLEEP))\n\t\t\tgoto out;\n\t\terror = FILE_LOCK_DEFERRED;\n\t\tlocks_insert_block(fl, request);\n\t\tgoto out;\n\t}\n\tif (request->fl_flags & FL_ACCESS)\n\t\tgoto out;\n\tlocks_copy_lock(new_fl, request);\n\tlocks_insert_lock_ctx(new_fl, &ctx->flc_flock);\n\tnew_fl = NULL;\n\terror = 0;\n\nout:\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read_preempt_enable(&file_rwsem);\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tlocks_dispose_list(&dispose);\n\ttrace_flock_lock_inode(inode, request, error);\n\treturn error;\n}"
  },
  {
    "function_name": "posix_locks_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "887-908",
    "snippet": "static int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define MAX_DEADLK_ITERATIONS 10"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "caller_fl",
            "block_fl"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "597-603",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "what_owner_is_waiting_for",
          "args": [
            "block_fl"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "what_owner_is_waiting_for",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "875-884",
          "snippet": "static struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "caller_fl"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\n#define MAX_DEADLK_ITERATIONS 10\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic int posix_locks_deadlock(struct file_lock *caller_fl,\n\t\t\t\tstruct file_lock *block_fl)\n{\n\tint i = 0;\n\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\t/*\n\t * This deadlock detector can't reasonably detect deadlocks with\n\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.\n\t */\n\tif (IS_OFDLCK(caller_fl))\n\t\treturn 0;\n\n\twhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\n\t\tif (i++ > MAX_DEADLK_ITERATIONS)\n\t\t\treturn 0;\n\t\tif (posix_same_owner(caller_fl, block_fl))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "what_owner_is_waiting_for",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "875-884",
    "snippet": "static struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "fl",
            "block_fl"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "597-603",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "blocked_hash",
            "fl",
            "fl_link",
            "posix_owner_key(block_fl)"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_owner_key",
          "args": [
            "block_fl"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "posix_owner_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "639-645",
          "snippet": "static unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\n{\n\tstruct file_lock *fl;\n\n\thash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\n\t\tif (posix_same_owner(fl, block_fl))\n\t\t\treturn fl->fl_next;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "posix_test_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "812-836",
    "snippet": "void\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = locks_inode(filp);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_copy_conflock",
          "args": [
            "fl",
            "cfl"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_conflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "366-382",
          "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_locks_conflict",
          "args": [
            "fl",
            "cfl"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "posix_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "781-794",
          "snippet": "static int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfl",
            "&ctx->flc_posix",
            "fl_list"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ctx->flc_posix"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid\nposix_test_lock(struct file *filp, struct file_lock *fl)\n{\n\tstruct file_lock *cfl;\n\tstruct file_lock_context *ctx;\n\tstruct inode *inode = locks_inode(filp);\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix)) {\n\t\tfl->fl_type = F_UNLCK;\n\t\treturn;\n\t}\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\n\t\tif (posix_locks_conflict(fl, cfl)) {\n\t\t\tlocks_copy_conflock(fl, cfl);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfl->fl_type = F_UNLCK;\nout:\n\tspin_unlock(&ctx->flc_lock);\n\treturn;\n}"
  },
  {
    "function_name": "flock_locks_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "799-810",
    "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_conflict",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "799-810",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
  },
  {
    "function_name": "posix_locks_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "781-794",
    "snippet": "static int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_conflict",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "flock_locks_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "799-810",
          "snippet": "static int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* FLOCK locks referring to the same filp do not conflict with\n\t * each other.\n\t */\n\tif (caller_fl->fl_file == sys_fl->fl_file)\n\t\treturn (0);\n\tif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_overlap",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "locks_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "588-592",
          "snippet": "static inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_same_owner",
          "args": [
            "caller_fl",
            "sys_fl"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "posix_same_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "597-603",
          "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\t/* POSIX locks owned by the same process do not conflict with\n\t * each other.\n\t */\n\tif (posix_same_owner(caller_fl, sys_fl))\n\t\treturn (0);\n\n\t/* Check whether they overlap */\n\tif (!locks_overlap(caller_fl, sys_fl))\n\t\treturn 0;\n\n\treturn (locks_conflict(caller_fl, sys_fl));\n}"
  },
  {
    "function_name": "locks_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "769-776",
    "snippet": "static int locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\tif (sys_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\tif (caller_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\n{\n\tif (sys_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\tif (caller_fl->fl_type == F_WRLCK)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "locks_delete_lock_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "756-764",
    "snippet": "static void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&fl->fl_list",
            "dispose"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_unlink_lock_ctx",
          "args": [
            "fl"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "locks_unlink_lock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "748-754",
          "snippet": "static void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tlocks_wake_up_blocks(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tlocks_wake_up_blocks(fl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\n{\n\tlocks_unlink_lock_ctx(fl);\n\tif (dispose)\n\t\tlist_add(&fl->fl_list, dispose);\n\telse\n\t\tlocks_free_lock(fl);\n}"
  },
  {
    "function_name": "locks_unlink_lock_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "748-754",
    "snippet": "static void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tlocks_wake_up_blocks(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_wake_up_blocks",
          "args": [
            "fl"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_list"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_delete_global_locks",
          "args": [
            "fl"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_global_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "619-637",
          "snippet": "static void locks_delete_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll;\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\n\tfll = per_cpu_ptr(&file_lock_list, fl->fl_link_cpu);\n\tspin_lock(&fll->lock);\n\thlist_del_init(&fl->fl_link);\n\tspin_unlock(&fll->lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic void locks_delete_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll;\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\n\tfll = per_cpu_ptr(&file_lock_list, fl->fl_link_cpu);\n\tspin_lock(&fll->lock);\n\thlist_del_init(&fl->fl_link);\n\tspin_unlock(&fll->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_unlink_lock_ctx(struct file_lock *fl)\n{\n\tlocks_delete_global_locks(fl);\n\tlist_del_init(&fl->fl_list);\n\tlocks_wake_up_blocks(fl);\n}"
  },
  {
    "function_name": "locks_insert_lock_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "741-746",
    "snippet": "static void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_insert_global_locks",
          "args": [
            "fl"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_global_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "606-616",
          "snippet": "static void locks_insert_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll = this_cpu_ptr(&file_lock_list);\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\tspin_lock(&fll->lock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, &fll->hlist);\n\tspin_unlock(&fll->lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic void locks_insert_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll = this_cpu_ptr(&file_lock_list);\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\tspin_lock(&fll->lock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, &fll->hlist);\n\tspin_unlock(&fll->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fl->fl_list",
            "before"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\n{\n\tlist_add_tail(&fl->fl_list, before);\n\tlocks_insert_global_locks(fl);\n}"
  },
  {
    "function_name": "locks_wake_up_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "714-739",
    "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&waiter->fl_wait"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "waiter->fl_lmops->lm_notify",
          "args": [
            "waiter"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__locks_delete_block",
          "args": [
            "waiter"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "666-671",
          "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&blocker->fl_block",
            "structfile_lock",
            "fl_block"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&blocker->fl_block"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
  },
  {
    "function_name": "locks_insert_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "701-707",
    "snippet": "static void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__locks_insert_block",
          "args": [
            "blocker",
            "waiter"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_insert_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "690-698",
          "snippet": "static void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_insert_block(blocker, waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
  },
  {
    "function_name": "__locks_insert_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "690-698",
    "snippet": "static void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_insert_global_blocked",
          "args": [
            "waiter"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "locks_insert_global_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "647-652",
          "snippet": "static void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_OFDLCK",
          "args": [
            "blocker"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIX",
          "args": [
            "blocker"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&waiter->fl_block",
            "&blocker->fl_block"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&waiter->fl_block)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&waiter->fl_block"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_insert_block(struct file_lock *blocker,\n\t\t\t\t\tstruct file_lock *waiter)\n{\n\tBUG_ON(!list_empty(&waiter->fl_block));\n\twaiter->fl_next = blocker;\n\tlist_add_tail(&waiter->fl_block, &blocker->fl_block);\n\tif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\n\t\tlocks_insert_global_blocked(waiter);\n}"
  },
  {
    "function_name": "locks_delete_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "673-678",
    "snippet": "static void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__locks_delete_block",
          "args": [
            "waiter"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "__locks_delete_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "666-671",
          "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_block(struct file_lock *waiter)\n{\n\tspin_lock(&blocked_lock_lock);\n\t__locks_delete_block(waiter);\n\tspin_unlock(&blocked_lock_lock);\n}"
  },
  {
    "function_name": "__locks_delete_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "666-671",
    "snippet": "static void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&waiter->fl_block"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_delete_global_blocked",
          "args": [
            "waiter"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "locks_delete_global_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "654-659",
          "snippet": "static void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_del(&waiter->fl_link);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_del(&waiter->fl_link);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void __locks_delete_block(struct file_lock *waiter)\n{\n\tlocks_delete_global_blocked(waiter);\n\tlist_del_init(&waiter->fl_block);\n\twaiter->fl_next = NULL;\n}"
  },
  {
    "function_name": "locks_delete_global_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "654-659",
    "snippet": "static void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_del(&waiter->fl_link);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&waiter->fl_link"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfsd/nfs4state.c",
          "lines": "1004-1023",
          "snippet": "static bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_delete_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_del(&waiter->fl_link);\n}"
  },
  {
    "function_name": "locks_insert_global_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "647-652",
    "snippet": "static void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_lock_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "blocked_hash",
            "&waiter->fl_link",
            "posix_owner_key(waiter)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_owner_key",
          "args": [
            "waiter"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "posix_owner_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "639-645",
          "snippet": "static unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&blocked_lock_lock"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_insert_global_blocked(struct file_lock *waiter)\n{\n\tlockdep_assert_held(&blocked_lock_lock);\n\n\thash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\n}"
  },
  {
    "function_name": "posix_owner_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "639-645",
    "snippet": "static unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_owner_key",
          "args": [
            "fl"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic unsigned long\nposix_owner_key(struct file_lock *fl)\n{\n\tif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\n\t\treturn fl->fl_lmops->lm_owner_key(fl);\n\treturn (unsigned long)fl->fl_owner;\n}"
  },
  {
    "function_name": "locks_delete_global_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "619-637",
    "snippet": "static void locks_delete_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll;\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\n\tfll = per_cpu_ptr(&file_lock_list, fl->fl_link_cpu);\n\tspin_lock(&fll->lock);\n\thlist_del_init(&fl->fl_link);\n\tspin_unlock(&fll->lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fll->lock"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&fl->fl_link"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fll->lock"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&file_lock_list",
            "fl->fl_link_cpu"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&fl->fl_link"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_assert_held",
          "args": [
            "&file_rwsem"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic void locks_delete_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll;\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\t/*\n\t * Avoid taking lock if already unhashed. This is safe since this check\n\t * is done while holding the flc_lock, and new insertions into the list\n\t * also require that it be held.\n\t */\n\tif (hlist_unhashed(&fl->fl_link))\n\t\treturn;\n\n\tfll = per_cpu_ptr(&file_lock_list, fl->fl_link_cpu);\n\tspin_lock(&fll->lock);\n\thlist_del_init(&fl->fl_link);\n\tspin_unlock(&fll->lock);\n}"
  },
  {
    "function_name": "locks_insert_global_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "606-616",
    "snippet": "static void locks_insert_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll = this_cpu_ptr(&file_lock_list);\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\tspin_lock(&fll->lock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, &fll->hlist);\n\tspin_unlock(&fll->lock);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fll->lock"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&fl->fl_link",
            "&fll->hlist"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fll->lock"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_assert_held",
          "args": [
            "&file_rwsem"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&file_lock_list"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct file_lock_list_struct, file_lock_list);\nDEFINE_STATIC_PERCPU_RWSEM(file_rwsem);\n\nstatic void locks_insert_global_locks(struct file_lock *fl)\n{\n\tstruct file_lock_list_struct *fll = this_cpu_ptr(&file_lock_list);\n\n\tpercpu_rwsem_assert_held(&file_rwsem);\n\n\tspin_lock(&fll->lock);\n\tfl->fl_link_cpu = smp_processor_id();\n\thlist_add_head(&fl->fl_link, &fll->hlist);\n\tspin_unlock(&fll->lock);\n}"
  },
  {
    "function_name": "posix_same_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "597-603",
    "snippet": "static int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl1->fl_lmops->lm_compare_owner",
          "args": [
            "fl1",
            "fl2"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\n{\n\tif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\n\t\treturn fl2->fl_lmops == fl1->fl_lmops &&\n\t\t\tfl1->fl_lmops->lm_compare_owner(fl1, fl2);\n\treturn fl1->fl_owner == fl2->fl_owner;\n}"
  },
  {
    "function_name": "locks_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "588-592",
    "snippet": "static inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\n{\n\treturn ((fl1->fl_end >= fl2->fl_start) &&\n\t\t(fl2->fl_end >= fl1->fl_start));\n}"
  },
  {
    "function_name": "lease_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "570-584",
    "snippet": "static struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_init",
          "args": [
            "filp",
            "type",
            "fl"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "lease_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "552-567",
          "snippet": "static int lease_init(struct file *filp, long type, struct file_lock *fl)\n{\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};\n\nstatic int lease_init(struct file *filp, long type, struct file_lock *fl)\n{\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\n{\n\tstruct file_lock *fl = locks_alloc_lock();\n\tint error = -ENOMEM;\n\n\tif (fl == NULL)\n\t\treturn ERR_PTR(error);\n\n\terror = lease_init(filp, type, fl);\n\tif (error) {\n\t\tlocks_free_lock(fl);\n\t\treturn ERR_PTR(error);\n\t}\n\treturn fl;\n}"
  },
  {
    "function_name": "lease_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "552-567",
    "snippet": "static int lease_init(struct file *filp, long type, struct file_lock *fl)\n{\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_type",
          "args": [
            "fl",
            "type"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "assign_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "441-453",
          "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic const struct lock_manager_operations lease_manager_ops = {\n\t.lm_break = lease_break_callback,\n\t.lm_change = lease_modify,\n\t.lm_setup = lease_setup,\n};\n\nstatic int lease_init(struct file *filp, long type, struct file_lock *fl)\n{\n\tif (assign_type(fl, type) != 0)\n\t\treturn -EINVAL;\n\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_LEASE;\n\tfl->fl_start = 0;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = &lease_manager_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "lease_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "526-541",
    "snippet": "static void\nlease_setup(struct file_lock *fl, void **priv)\n{\n\tstruct file *filp = fl->fl_file;\n\tstruct fasync_struct *fa = *priv;\n\n\t/*\n\t * fasync_insert_entry() returns the old entry if any. If there was no\n\t * old entry, then it used \"priv\" and inserted it into the fasync list.\n\t * Clear the pointer to indicate that it shouldn't be freed.\n\t */\n\tif (!fasync_insert_entry(fa->fa_fd, filp, &fl->fl_fasync, fa))\n\t\t*priv = NULL;\n\n\t__f_setown(filp, task_pid(current), PIDTYPE_TGID, 0);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__f_setown",
          "args": [
            "filp",
            "task_pid(current)",
            "PIDTYPE_TGID",
            "0"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "__f_setown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "105-110",
          "snippet": "void __f_setown(struct file *filp, struct pid *pid, enum pid_type type,\n\t\tint force)\n{\n\tsecurity_file_set_fowner(filp);\n\tf_modown(filp, pid, type, force);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid __f_setown(struct file *filp, struct pid *pid, enum pid_type type,\n\t\tint force)\n{\n\tsecurity_file_set_fowner(filp);\n\tf_modown(filp, pid, type, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "current"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fasync_insert_entry",
          "args": [
            "fa->fa_fd",
            "filp",
            "&fl->fl_fasync",
            "fa"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "915-943",
          "snippet": "struct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)\n{\n        struct fasync_struct *fa, **fp;\n\n\tspin_lock(&filp->f_lock);\n\tspin_lock(&fasync_lock);\n\tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n\t\tif (fa->fa_file != filp)\n\t\t\tcontinue;\n\n\t\twrite_lock_irq(&fa->fa_lock);\n\t\tfa->fa_fd = fd;\n\t\twrite_unlock_irq(&fa->fa_lock);\n\t\tgoto out;\n\t}\n\n\trwlock_init(&new->fa_lock);\n\tnew->magic = FASYNC_MAGIC;\n\tnew->fa_file = filp;\n\tnew->fa_fd = fd;\n\tnew->fa_next = *fapp;\n\trcu_assign_pointer(*fapp, new);\n\tfilp->f_flags |= FASYNC;\n\nout:\n\tspin_unlock(&fasync_lock);\n\tspin_unlock(&filp->f_lock);\n\treturn fa;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(fasync_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_SPINLOCK(fasync_lock);\n\nstruct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)\n{\n        struct fasync_struct *fa, **fp;\n\n\tspin_lock(&filp->f_lock);\n\tspin_lock(&fasync_lock);\n\tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n\t\tif (fa->fa_file != filp)\n\t\t\tcontinue;\n\n\t\twrite_lock_irq(&fa->fa_lock);\n\t\tfa->fa_fd = fd;\n\t\twrite_unlock_irq(&fa->fa_lock);\n\t\tgoto out;\n\t}\n\n\trwlock_init(&new->fa_lock);\n\tnew->magic = FASYNC_MAGIC;\n\tnew->fa_file = filp;\n\tnew->fa_fd = fd;\n\tnew->fa_next = *fapp;\n\trcu_assign_pointer(*fapp, new);\n\tfilp->f_flags |= FASYNC;\n\nout:\n\tspin_unlock(&fasync_lock);\n\tspin_unlock(&filp->f_lock);\n\treturn fa;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlease_setup(struct file_lock *fl, void **priv)\n{\n\tstruct file *filp = fl->fl_file;\n\tstruct fasync_struct *fa = *priv;\n\n\t/*\n\t * fasync_insert_entry() returns the old entry if any. If there was no\n\t * old entry, then it used \"priv\" and inserted it into the fasync list.\n\t * Clear the pointer to indicate that it shouldn't be freed.\n\t */\n\tif (!fasync_insert_entry(fa->fa_fd, filp, &fl->fl_fasync, fa))\n\t\t*priv = NULL;\n\n\t__f_setown(filp, task_pid(current), PIDTYPE_TGID, 0);\n}"
  },
  {
    "function_name": "lease_break_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "519-524",
    "snippet": "static bool\nlease_break_callback(struct file_lock *fl)\n{\n\tkill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);\n\treturn false;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&fl->fl_fasync",
            "SIGIO",
            "POLL_MSG"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "1014-1024",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool\nlease_break_callback(struct file_lock *fl)\n{\n\tkill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);\n\treturn false;\n}"
  },
  {
    "function_name": "flock_to_posix_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "505-516",
    "snippet": "static int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flock64_to_posix_lock",
          "args": [
            "filp",
            "fl",
            "&ll"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "flock64_to_posix_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "455-500",
          "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t       struct flock *l)\n{\n\tstruct flock64 ll = {\n\t\t.l_type = l->l_type,\n\t\t.l_whence = l->l_whence,\n\t\t.l_start = l->l_start,\n\t\t.l_len = l->l_len,\n\t};\n\n\treturn flock64_to_posix_lock(filp, fl, &ll);\n}"
  },
  {
    "function_name": "flock64_to_posix_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "455-500",
    "snippet": "static int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assign_type",
          "args": [
            "fl",
            "l->l_type"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "assign_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "441-453",
          "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(filp)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\n\t\t\t\t struct flock64 *l)\n{\n\tswitch (l->l_whence) {\n\tcase SEEK_SET:\n\t\tfl->fl_start = 0;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tfl->fl_start = filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tfl->fl_start = i_size_read(file_inode(filp));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (l->l_start > OFFSET_MAX - fl->fl_start)\n\t\treturn -EOVERFLOW;\n\tfl->fl_start += l->l_start;\n\tif (fl->fl_start < 0)\n\t\treturn -EINVAL;\n\n\t/* POSIX-1996 leaves the case l->l_len < 0 undefined;\n\t   POSIX-2001 defines it. */\n\tif (l->l_len > 0) {\n\t\tif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\n\t\t\treturn -EOVERFLOW;\n\t\tfl->fl_end = fl->fl_start + l->l_len - 1;\n\n\t} else if (l->l_len < 0) {\n\t\tif (fl->fl_start + l->l_len < 0)\n\t\t\treturn -EINVAL;\n\t\tfl->fl_end = fl->fl_start - 1;\n\t\tfl->fl_start += l->l_len;\n\t} else\n\t\tfl->fl_end = OFFSET_MAX;\n\n\tfl->fl_owner = current->files;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = filp;\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_ops = NULL;\n\tfl->fl_lmops = NULL;\n\n\treturn assign_type(fl, l->l_type);\n}"
  },
  {
    "function_name": "assign_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "441-453",
    "snippet": "static int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int assign_type(struct file_lock *fl, long type)\n{\n\tswitch (type) {\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\tcase F_UNLCK:\n\t\tfl->fl_type = type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "flock_make_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "418-439",
    "snippet": "static struct file_lock *\nflock_make_lock(struct file *filp, unsigned int cmd)\n{\n\tstruct file_lock *fl;\n\tint type = flock_translate_cmd(cmd);\n\n\tif (type < 0)\n\t\treturn ERR_PTR(type);\n\t\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfl->fl_file = filp;\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_flags = FL_FLOCK;\n\tfl->fl_type = type;\n\tfl->fl_end = OFFSET_MAX;\n\t\n\treturn fl;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "locks_alloc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "301-309",
          "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "type"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_translate_cmd",
          "args": [
            "cmd"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "flock_translate_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "403-415",
          "snippet": "static inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct file_lock *\nflock_make_lock(struct file *filp, unsigned int cmd)\n{\n\tstruct file_lock *fl;\n\tint type = flock_translate_cmd(cmd);\n\n\tif (type < 0)\n\t\treturn ERR_PTR(type);\n\t\n\tfl = locks_alloc_lock();\n\tif (fl == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfl->fl_file = filp;\n\tfl->fl_owner = filp;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_flags = FL_FLOCK;\n\tfl->fl_type = type;\n\tfl->fl_end = OFFSET_MAX;\n\t\n\treturn fl;\n}"
  },
  {
    "function_name": "flock_translate_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "403-415",
    "snippet": "static inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic inline int flock_translate_cmd(int cmd) {\n\tif (cmd & LOCK_MAND)\n\t\treturn cmd & (LOCK_MAND | LOCK_RW);\n\tswitch (cmd) {\n\tcase LOCK_SH:\n\t\treturn F_RDLCK;\n\tcase LOCK_EX:\n\t\treturn F_WRLCK;\n\tcase LOCK_UN:\n\t\treturn F_UNLCK;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "locks_copy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "385-399",
    "snippet": "void locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_ops->fl_copy_lock",
          "args": [
            "new",
            "fl"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_copy_conflock",
          "args": [
            "new",
            "fl"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "locks_copy_conflock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "366-382",
          "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "new->fl_ops"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\n{\n\t/* \"new\" must be a freshly-initialized lock */\n\tWARN_ON_ONCE(new->fl_ops);\n\n\tlocks_copy_conflock(new, fl);\n\n\tnew->fl_file = fl->fl_file;\n\tnew->fl_ops = fl->fl_ops;\n\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_copy_lock)\n\t\t\tfl->fl_ops->fl_copy_lock(new, fl);\n\t}\n}"
  },
  {
    "function_name": "locks_copy_conflock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "366-382",
    "snippet": "void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_get_owner",
          "args": [
            "fl->fl_owner"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\n{\n\tnew->fl_owner = fl->fl_owner;\n\tnew->fl_pid = fl->fl_pid;\n\tnew->fl_file = NULL;\n\tnew->fl_flags = fl->fl_flags;\n\tnew->fl_type = fl->fl_type;\n\tnew->fl_start = fl->fl_start;\n\tnew->fl_end = fl->fl_end;\n\tnew->fl_lmops = fl->fl_lmops;\n\tnew->fl_ops = NULL;\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_get_owner)\n\t\t\tfl->fl_lmops->lm_get_owner(fl->fl_owner);\n\t}\n}"
  },
  {
    "function_name": "locks_init_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "355-359",
    "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_init_lock_heads",
          "args": [
            "fl"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock_heads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "292-298",
          "snippet": "static void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fl",
            "0",
            "sizeof(struct file_lock)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
  },
  {
    "function_name": "locks_dispose_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "343-353",
    "snippet": "static void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "331-340",
          "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filelock_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&fl->fl_list"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "dispose",
            "structfile_lock",
            "fl_list"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "dispose"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dispose_list(struct list_head *dispose)\n{\n\tstruct file_lock *fl;\n\n\twhile (!list_empty(dispose)) {\n\t\tfl = list_first_entry(dispose, struct file_lock, fl_list);\n\t\tlist_del_init(&fl->fl_list);\n\t\tlocks_free_lock(fl);\n\t}\n}"
  },
  {
    "function_name": "locks_free_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "331-340",
    "snippet": "void locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *filelock_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "filelock_cache",
            "fl"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_release_private",
          "args": [
            "fl"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "locks_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "312-327",
          "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner) {\n\t\t\tfl->fl_lmops->lm_put_owner(fl->fl_owner);\n\t\t\tfl->fl_owner = NULL;\n\t\t}\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner) {\n\t\t\tfl->fl_lmops->lm_put_owner(fl->fl_owner);\n\t\t\tfl->fl_owner = NULL;\n\t\t}\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_unhashed(&fl->fl_link)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&fl->fl_link"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&fl->fl_block)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fl->fl_block"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&fl->fl_list)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "waitqueue_active(&fl->fl_wait)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&fl->fl_wait"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nvoid locks_free_lock(struct file_lock *fl)\n{\n\tBUG_ON(waitqueue_active(&fl->fl_wait));\n\tBUG_ON(!list_empty(&fl->fl_list));\n\tBUG_ON(!list_empty(&fl->fl_block));\n\tBUG_ON(!hlist_unhashed(&fl->fl_link));\n\n\tlocks_release_private(fl);\n\tkmem_cache_free(filelock_cache, fl);\n}"
  },
  {
    "function_name": "locks_release_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "312-327",
    "snippet": "void locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner) {\n\t\t\tfl->fl_lmops->lm_put_owner(fl->fl_owner);\n\t\t\tfl->fl_owner = NULL;\n\t\t}\n\t\tfl->fl_lmops = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fl->fl_lmops->lm_put_owner",
          "args": [
            "fl->fl_owner"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fl->fl_ops->fl_release_private",
          "args": [
            "fl"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_release_private(struct file_lock *fl)\n{\n\tif (fl->fl_ops) {\n\t\tif (fl->fl_ops->fl_release_private)\n\t\t\tfl->fl_ops->fl_release_private(fl);\n\t\tfl->fl_ops = NULL;\n\t}\n\n\tif (fl->fl_lmops) {\n\t\tif (fl->fl_lmops->lm_put_owner) {\n\t\t\tfl->fl_lmops->lm_put_owner(fl->fl_owner);\n\t\t\tfl->fl_owner = NULL;\n\t\t}\n\t\tfl->fl_lmops = NULL;\n\t}\n}"
  },
  {
    "function_name": "locks_alloc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "301-309",
    "snippet": "struct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *filelock_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_init_lock_heads",
          "args": [
            "fl"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock_heads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "292-298",
          "snippet": "static void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "filelock_cache",
            "GFP_KERNEL"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *filelock_cache;\n\nstruct file_lock *locks_alloc_lock(void)\n{\n\tstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\n\n\tif (fl)\n\t\tlocks_init_lock_heads(fl);\n\n\treturn fl;\n}"
  },
  {
    "function_name": "locks_init_lock_heads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "292-298",
    "snippet": "static void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&fl->fl_wait"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fl->fl_block"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fl->fl_list"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&fl->fl_link"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void locks_init_lock_heads(struct file_lock *fl)\n{\n\tINIT_HLIST_NODE(&fl->fl_link);\n\tINIT_LIST_HEAD(&fl->fl_list);\n\tINIT_LIST_HEAD(&fl->fl_block);\n\tinit_waitqueue_head(&fl->fl_wait);\n}"
  },
  {
    "function_name": "locks_free_lock_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "281-290",
    "snippet": "void\nlocks_free_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(ctx)) {\n\t\tlocks_check_ctx_lists(inode);\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *flctx_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "flctx_cache",
            "ctx"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_check_ctx_lists",
          "args": [
            "inode"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "locks_check_ctx_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "248-263",
          "snippet": "static void\nlocks_check_ctx_lists(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(!list_empty(&ctx->flc_flock) ||\n\t\t     !list_empty(&ctx->flc_posix) ||\n\t\t     !list_empty(&ctx->flc_lease))) {\n\t\tpr_warn(\"Leaked locks on dev=0x%x:0x%x ino=0x%lx:\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tinode->i_ino);\n\t\tlocks_dump_ctx_list(&ctx->flc_flock, \"FLOCK\");\n\t\tlocks_dump_ctx_list(&ctx->flc_posix, \"POSIX\");\n\t\tlocks_dump_ctx_list(&ctx->flc_lease, \"LEASE\");\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_check_ctx_lists(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(!list_empty(&ctx->flc_flock) ||\n\t\t     !list_empty(&ctx->flc_posix) ||\n\t\t     !list_empty(&ctx->flc_lease))) {\n\t\tpr_warn(\"Leaked locks on dev=0x%x:0x%x ino=0x%lx:\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tinode->i_ino);\n\t\tlocks_dump_ctx_list(&ctx->flc_flock, \"FLOCK\");\n\t\tlocks_dump_ctx_list(&ctx->flc_posix, \"POSIX\");\n\t\tlocks_dump_ctx_list(&ctx->flc_lease, \"LEASE\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ctx"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nvoid\nlocks_free_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(ctx)) {\n\t\tlocks_check_ctx_lists(inode);\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}"
  },
  {
    "function_name": "locks_check_ctx_file_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "265-279",
    "snippet": "static void\nlocks_check_ctx_file_list(struct file *filp, struct list_head *list,\n\t\t\t\tchar *list_type)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = locks_inode(filp);\n\n\tlist_for_each_entry(fl, list, fl_list)\n\t\tif (fl->fl_file == filp)\n\t\t\tpr_warn(\"Leaked %s lock on dev=0x%x:0x%x ino=0x%lx \"\n\t\t\t\t\" fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\",\n\t\t\t\tlist_type, MAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino,\n\t\t\t\tfl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Leaked %s lock on dev=0x%x:0x%x ino=0x%lx \"\n\t\t\t\t\" fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\"",
            "list_type",
            "MAJOR(inode->i_sb->s_dev)",
            "MINOR(inode->i_sb->s_dev)",
            "inode->i_ino",
            "fl->fl_owner",
            "fl->fl_flags",
            "fl->fl_type",
            "fl->fl_pid"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "list",
            "fl_list"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_inode",
          "args": [
            "filp"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_check_ctx_file_list(struct file *filp, struct list_head *list,\n\t\t\t\tchar *list_type)\n{\n\tstruct file_lock *fl;\n\tstruct inode *inode = locks_inode(filp);\n\n\tlist_for_each_entry(fl, list, fl_list)\n\t\tif (fl->fl_file == filp)\n\t\t\tpr_warn(\"Leaked %s lock on dev=0x%x:0x%x ino=0x%lx \"\n\t\t\t\t\" fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\",\n\t\t\t\tlist_type, MAJOR(inode->i_sb->s_dev),\n\t\t\t\tMINOR(inode->i_sb->s_dev), inode->i_ino,\n\t\t\t\tfl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n}"
  },
  {
    "function_name": "locks_check_ctx_lists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "248-263",
    "snippet": "static void\nlocks_check_ctx_lists(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(!list_empty(&ctx->flc_flock) ||\n\t\t     !list_empty(&ctx->flc_posix) ||\n\t\t     !list_empty(&ctx->flc_lease))) {\n\t\tpr_warn(\"Leaked locks on dev=0x%x:0x%x ino=0x%lx:\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tinode->i_ino);\n\t\tlocks_dump_ctx_list(&ctx->flc_flock, \"FLOCK\");\n\t\tlocks_dump_ctx_list(&ctx->flc_posix, \"POSIX\");\n\t\tlocks_dump_ctx_list(&ctx->flc_lease, \"LEASE\");\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_dump_ctx_list",
          "args": [
            "&ctx->flc_lease",
            "\"LEASE\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "locks_dump_ctx_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "238-246",
          "snippet": "static void\nlocks_dump_ctx_list(struct list_head *list, char *list_type)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tpr_warn(\"%s: fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\", list_type, fl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dump_ctx_list(struct list_head *list, char *list_type)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tpr_warn(\"%s: fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\", list_type, fl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Leaked locks on dev=0x%x:0x%x ino=0x%lx:\\n\"",
            "MAJOR(inode->i_sb->s_dev)",
            "MINOR(inode->i_sb->s_dev)",
            "inode->i_ino"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "inode->i_sb->s_dev"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&ctx->flc_flock) ||\n\t\t     !list_empty(&ctx->flc_posix) ||\n\t\t     !list_empty(&ctx->flc_lease)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_check_ctx_lists(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(!list_empty(&ctx->flc_flock) ||\n\t\t     !list_empty(&ctx->flc_posix) ||\n\t\t     !list_empty(&ctx->flc_lease))) {\n\t\tpr_warn(\"Leaked locks on dev=0x%x:0x%x ino=0x%lx:\\n\",\n\t\t\tMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\n\t\t\tinode->i_ino);\n\t\tlocks_dump_ctx_list(&ctx->flc_flock, \"FLOCK\");\n\t\tlocks_dump_ctx_list(&ctx->flc_posix, \"POSIX\");\n\t\tlocks_dump_ctx_list(&ctx->flc_lease, \"LEASE\");\n\t}\n}"
  },
  {
    "function_name": "locks_dump_ctx_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "238-246",
    "snippet": "static void\nlocks_dump_ctx_list(struct list_head *list, char *list_type)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tpr_warn(\"%s: fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\", list_type, fl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\"",
            "list_type",
            "fl->fl_owner",
            "fl->fl_flags",
            "fl->fl_type",
            "fl->fl_pid"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "list",
            "fl_list"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic void\nlocks_dump_ctx_list(struct list_head *list, char *list_type)\n{\n\tstruct file_lock *fl;\n\n\tlist_for_each_entry(fl, list, fl_list) {\n\t\tpr_warn(\"%s: fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\\n\", list_type, fl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\n\t}\n}"
  },
  {
    "function_name": "locks_get_lock_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "206-236",
    "snippet": "static struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *flctx_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_locks_get_lock_context",
          "args": [
            "inode",
            "type",
            "ctx"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "flctx_cache",
            "ctx"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&inode->i_flctx",
            "NULL",
            "ctx"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctx->flc_lease"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctx->flc_posix"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctx->flc_flock"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctx->flc_lock"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "flctx_cache",
            "GFP_KERNEL"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ctx"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&inode->i_flctx"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nstatic struct file_lock_context *\nlocks_get_lock_context(struct inode *inode, int type)\n{\n\tstruct file_lock_context *ctx;\n\n\t/* paired with cmpxchg() below */\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (likely(ctx) || type == F_UNLCK)\n\t\tgoto out;\n\n\tctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out;\n\n\tspin_lock_init(&ctx->flc_lock);\n\tINIT_LIST_HEAD(&ctx->flc_flock);\n\tINIT_LIST_HEAD(&ctx->flc_posix);\n\tINIT_LIST_HEAD(&ctx->flc_lease);\n\n\t/*\n\t * Assign the pointer if it's not already assigned. If it is, then\n\t * free the context we just allocated.\n\t */\n\tif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t\tctx = smp_load_acquire(&inode->i_flctx);\n\t}\nout:\n\ttrace_locks_get_lock_context(inode, type, ctx);\n\treturn ctx;\n}"
  },
  {
    "function_name": "target_leasetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "147-154",
    "snippet": "static int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic int target_leasetype(struct file_lock *fl)\n{\n\tif (fl->fl_flags & FL_UNLOCK_PENDING)\n\t\treturn F_UNLCK;\n\tif (fl->fl_flags & FL_DOWNGRADE_PENDING)\n\t\treturn F_RDLCK;\n\treturn fl->fl_type;\n}"
  },
  {
    "function_name": "lease_breaking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "142-145",
    "snippet": "static bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic bool lease_breaking(struct file_lock *fl)\n{\n\treturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\n}"
  },
  {
    "function_name": "flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
    "lines": "1985-2031",
    "snippet": "SYSCALL_DEFINE2(flock, unsigned int, fd, unsigned int, cmd)\n{\n\tstruct fd f = fdget(fd);\n\tstruct file_lock *lock;\n\tint can_sleep, unlock;\n\tint error;\n\n\terror = -EBADF;\n\tif (!f.file)\n\t\tgoto out;\n\n\tcan_sleep = !(cmd & LOCK_NB);\n\tcmd &= ~LOCK_NB;\n\tunlock = (cmd == LOCK_UN);\n\n\tif (!unlock && !(cmd & LOCK_MAND) &&\n\t    !(f.file->f_mode & (FMODE_READ|FMODE_WRITE)))\n\t\tgoto out_putf;\n\n\tlock = flock_make_lock(f.file, cmd);\n\tif (IS_ERR(lock)) {\n\t\terror = PTR_ERR(lock);\n\t\tgoto out_putf;\n\t}\n\n\tif (can_sleep)\n\t\tlock->fl_flags |= FL_SLEEP;\n\n\terror = security_file_lock(f.file, lock->fl_type);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (f.file->f_op->flock)\n\t\terror = f.file->f_op->flock(f.file,\n\t\t\t\t\t  (can_sleep) ? F_SETLKW : F_SETLK,\n\t\t\t\t\t  lock);\n\telse\n\t\terror = locks_lock_file_wait(f.file, lock);\n\n out_free:\n\tlocks_free_lock(lock);\n\n out_putf:\n\tfdput(f);\n out:\n\treturn error;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/uaccess.h>",
      "#include <trace/events/filelock.h>",
      "#include <linux/percpu.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE2(flock, unsigned int, fd, unsigned int, cmd)\n{\n\tstruct fd f = fdget(fd);\n\tstruct file_lock *lock;\n\tint can_sleep, unlock;\n\tint error;\n\n\terror = -EBADF;\n\tif (!f.file)\n\t\tgoto out;\n\n\tcan_sleep = !(cmd & LOCK_NB);\n\tcmd &= ~LOCK_NB;\n\tunlock = (cmd == LOCK_UN);\n\n\tif (!unlock && !(cmd & LOCK_MAND) &&\n\t    !(f.file->f_mode & (FMODE_READ|FMODE_WRITE)))\n\t\tgoto out_putf;\n\n\tlock = flock_make_lock(f.file, cmd);\n\tif (IS_ERR(lock)) {\n\t\terror = PTR_ERR(lock);\n\t\tgoto out_putf;\n\t}\n\n\tif (can_sleep)\n\t\tlock->fl_flags |= FL_SLEEP;\n\n\terror = security_file_lock(f.file, lock->fl_type);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (f.file->f_op->flock)\n\t\terror = f.file->f_op->flock(f.file,\n\t\t\t\t\t  (can_sleep) ? F_SETLKW : F_SETLK,\n\t\t\t\t\t  lock);\n\telse\n\t\terror = locks_lock_file_wait(f.file, lock);\n\n out_free:\n\tlocks_free_lock(lock);\n\n out_putf:\n\tfdput(f);\n out:\n\treturn error;\n}"
  }
]