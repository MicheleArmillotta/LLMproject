[
  {
    "function_name": "vfs_dedupe_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "2077-2154",
    "snippet": "int vfs_dedupe_file_range(struct file *file, struct file_dedupe_range *same)\n{\n\tstruct file_dedupe_range_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tu16 count = same->dest_count;\n\tloff_t deduped;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tif (same->reserved1 || same->reserved2)\n\t\treturn -EINVAL;\n\n\toff = same->src_offset;\n\tlen = same->src_length;\n\n\tif (S_ISDIR(src->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(src->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!file->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file, off, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tif (off + len > i_size_read(src))\n\t\treturn -EINVAL;\n\n\t/* Arbitrary 1G limit on a single dedupe request, can be raised. */\n\tlen = min_t(u64, len, 1 << 30);\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = FILE_DEDUPE_RANGE_SAME;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct fd dst_fd = fdget(info->dest_fd);\n\t\tstruct file *dst_file = dst_fd.file;\n\n\t\tif (!dst_file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tgoto next_loop;\n\t\t}\n\n\t\tif (info->reserved) {\n\t\t\tinfo->status = -EINVAL;\n\t\t\tgoto next_fdput;\n\t\t}\n\n\t\tdeduped = vfs_dedupe_file_range_one(file, off, dst_file,\n\t\t\t\t\t\t    info->dest_offset, len,\n\t\t\t\t\t\t    REMAP_FILE_CAN_SHORTEN);\n\t\tif (deduped == -EBADE)\n\t\t\tinfo->status = FILE_DEDUPE_RANGE_DIFFERS;\n\t\telse if (deduped < 0)\n\t\t\tinfo->status = deduped;\n\t\telse\n\t\t\tinfo->bytes_deduped = len;\n\nnext_fdput:\n\t\tfdput(dst_fd);\nnext_loop:\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "dst_fd"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_dedupe_file_range_one",
          "args": [
            "file",
            "off",
            "dst_file",
            "info->dest_offset",
            "len",
            "REMAP_FILE_CAN_SHORTEN"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_dedupe_file_range_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "2030-2074",
          "snippet": "loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t struct file *dst_file, loff_t dst_pos,\n\t\t\t\t loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags & ~(REMAP_FILE_DEDUP |\n\t\t\t\t     REMAP_FILE_CAN_SHORTEN));\n\n\tret = mnt_want_write_file(dst_file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(dst_file, dst_pos, len, true);\n\tif (ret < 0)\n\t\tgoto out_drop_write;\n\n\tret = -EPERM;\n\tif (!allow_file_dedupe(dst_file))\n\t\tgoto out_drop_write;\n\n\tret = -EXDEV;\n\tif (src_file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto out_drop_write;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(file_inode(dst_file)->i_mode))\n\t\tgoto out_drop_write;\n\n\tret = -EINVAL;\n\tif (!dst_file->f_op->remap_file_range)\n\t\tgoto out_drop_write;\n\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = dst_file->f_op->remap_file_range(src_file, src_pos, dst_file,\n\t\t\tdst_pos, len, remap_flags | REMAP_FILE_DEDUP);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t struct file *dst_file, loff_t dst_pos,\n\t\t\t\t loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags & ~(REMAP_FILE_DEDUP |\n\t\t\t\t     REMAP_FILE_CAN_SHORTEN));\n\n\tret = mnt_want_write_file(dst_file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(dst_file, dst_pos, len, true);\n\tif (ret < 0)\n\t\tgoto out_drop_write;\n\n\tret = -EPERM;\n\tif (!allow_file_dedupe(dst_file))\n\t\tgoto out_drop_write;\n\n\tret = -EXDEV;\n\tif (src_file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto out_drop_write;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(file_inode(dst_file)->i_mode))\n\t\tgoto out_drop_write;\n\n\tret = -EINVAL;\n\tif (!dst_file->f_op->remap_file_range)\n\t\tgoto out_drop_write;\n\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = dst_file->f_op->remap_file_range(src_file, src_pos, dst_file,\n\t\t\tdst_pos, len, remap_flags | REMAP_FILE_DEDUP);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "info->dest_fd"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "len",
            "1 << 30"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "src"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remap_verify_area",
          "args": [
            "file",
            "off",
            "len",
            "false"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "remap_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1692-1714",
          "snippet": "static int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "src->i_mode"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "src->i_mode"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint vfs_dedupe_file_range(struct file *file, struct file_dedupe_range *same)\n{\n\tstruct file_dedupe_range_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tu16 count = same->dest_count;\n\tloff_t deduped;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tif (same->reserved1 || same->reserved2)\n\t\treturn -EINVAL;\n\n\toff = same->src_offset;\n\tlen = same->src_length;\n\n\tif (S_ISDIR(src->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(src->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!file->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file, off, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tif (off + len > i_size_read(src))\n\t\treturn -EINVAL;\n\n\t/* Arbitrary 1G limit on a single dedupe request, can be raised. */\n\tlen = min_t(u64, len, 1 << 30);\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = FILE_DEDUPE_RANGE_SAME;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct fd dst_fd = fdget(info->dest_fd);\n\t\tstruct file *dst_file = dst_fd.file;\n\n\t\tif (!dst_file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tgoto next_loop;\n\t\t}\n\n\t\tif (info->reserved) {\n\t\t\tinfo->status = -EINVAL;\n\t\t\tgoto next_fdput;\n\t\t}\n\n\t\tdeduped = vfs_dedupe_file_range_one(file, off, dst_file,\n\t\t\t\t\t\t    info->dest_offset, len,\n\t\t\t\t\t\t    REMAP_FILE_CAN_SHORTEN);\n\t\tif (deduped == -EBADE)\n\t\t\tinfo->status = FILE_DEDUPE_RANGE_DIFFERS;\n\t\telse if (deduped < 0)\n\t\t\tinfo->status = deduped;\n\t\telse\n\t\t\tinfo->bytes_deduped = len;\n\nnext_fdput:\n\t\tfdput(dst_fd);\nnext_loop:\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_dedupe_file_range_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "2030-2074",
    "snippet": "loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t struct file *dst_file, loff_t dst_pos,\n\t\t\t\t loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags & ~(REMAP_FILE_DEDUP |\n\t\t\t\t     REMAP_FILE_CAN_SHORTEN));\n\n\tret = mnt_want_write_file(dst_file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(dst_file, dst_pos, len, true);\n\tif (ret < 0)\n\t\tgoto out_drop_write;\n\n\tret = -EPERM;\n\tif (!allow_file_dedupe(dst_file))\n\t\tgoto out_drop_write;\n\n\tret = -EXDEV;\n\tif (src_file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto out_drop_write;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(file_inode(dst_file)->i_mode))\n\t\tgoto out_drop_write;\n\n\tret = -EINVAL;\n\tif (!dst_file->f_op->remap_file_range)\n\t\tgoto out_drop_write;\n\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = dst_file->f_op->remap_file_range(src_file, src_pos, dst_file,\n\t\t\tdst_pos, len, remap_flags | REMAP_FILE_DEDUP);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "dst_file"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dst_file->f_op->remap_file_range",
          "args": [
            "src_file",
            "src_pos",
            "dst_file",
            "dst_pos",
            "len",
            "remap_flags | REMAP_FILE_DEDUP"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "file_inode(dst_file)->i_mode"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "dst_file"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_file_dedupe",
          "args": [
            "dst_file"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "allow_file_dedupe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "2017-2028",
          "snippet": "static bool allow_file_dedupe(struct file *file)\n{\n\tif (capable(CAP_SYS_ADMIN))\n\t\treturn true;\n\tif (file->f_mode & FMODE_WRITE)\n\t\treturn true;\n\tif (uid_eq(current_fsuid(), file_inode(file)->i_uid))\n\t\treturn true;\n\tif (!inode_permission(file_inode(file), MAY_WRITE))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic bool allow_file_dedupe(struct file *file)\n{\n\tif (capable(CAP_SYS_ADMIN))\n\t\treturn true;\n\tif (file->f_mode & FMODE_WRITE)\n\t\treturn true;\n\tif (uid_eq(current_fsuid(), file_inode(file)->i_uid))\n\t\treturn true;\n\tif (!inode_permission(file_inode(file), MAY_WRITE))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remap_verify_area",
          "args": [
            "dst_file",
            "dst_pos",
            "len",
            "true"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "remap_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1692-1714",
          "snippet": "static int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "dst_file"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "remap_flags & ~(REMAP_FILE_DEDUP |\n\t\t\t\t     REMAP_FILE_CAN_SHORTEN)"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,\n\t\t\t\t struct file *dst_file, loff_t dst_pos,\n\t\t\t\t loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags & ~(REMAP_FILE_DEDUP |\n\t\t\t\t     REMAP_FILE_CAN_SHORTEN));\n\n\tret = mnt_want_write_file(dst_file);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(dst_file, dst_pos, len, true);\n\tif (ret < 0)\n\t\tgoto out_drop_write;\n\n\tret = -EPERM;\n\tif (!allow_file_dedupe(dst_file))\n\t\tgoto out_drop_write;\n\n\tret = -EXDEV;\n\tif (src_file->f_path.mnt != dst_file->f_path.mnt)\n\t\tgoto out_drop_write;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(file_inode(dst_file)->i_mode))\n\t\tgoto out_drop_write;\n\n\tret = -EINVAL;\n\tif (!dst_file->f_op->remap_file_range)\n\t\tgoto out_drop_write;\n\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = dst_file->f_op->remap_file_range(src_file, src_pos, dst_file,\n\t\t\tdst_pos, len, remap_flags | REMAP_FILE_DEDUP);\nout_drop_write:\n\tmnt_drop_write_file(dst_file);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "allow_file_dedupe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "2017-2028",
    "snippet": "static bool allow_file_dedupe(struct file *file)\n{\n\tif (capable(CAP_SYS_ADMIN))\n\t\treturn true;\n\tif (file->f_mode & FMODE_WRITE)\n\t\treturn true;\n\tif (uid_eq(current_fsuid(), file_inode(file)->i_uid))\n\t\treturn true;\n\tif (!inode_permission(file_inode(file), MAY_WRITE))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "file_inode(file)",
            "MAY_WRITE"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "file_inode(file)->i_uid"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic bool allow_file_dedupe(struct file *file)\n{\n\tif (capable(CAP_SYS_ADMIN))\n\t\treturn true;\n\tif (file->f_mode & FMODE_WRITE)\n\t\treturn true;\n\tif (uid_eq(current_fsuid(), file_inode(file)->i_uid))\n\t\treturn true;\n\tif (!inode_permission(file_inode(file), MAY_WRITE))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "vfs_clone_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "2001-2013",
    "snippet": "loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tfile_start_write(file_out);\n\tret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len,\n\t\t\t\t  remap_flags);\n\tfile_end_write(file_out);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file_out"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_clone_file_range",
          "args": [
            "file_in",
            "pos_in",
            "file_out",
            "pos_out",
            "len",
            "remap_flags"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "do_clone_file_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1951-1998",
          "snippet": "loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t   loff_t len, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags);\n\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * FICLONE/FICLONERANGE ioctls enforce that src and dest files are on\n\t * the same mount. Practically, they only need to be on the same file\n\t * system.\n\t */\n\tif (inode_in->i_sb != inode_out->i_sb)\n\t\treturn -EXDEV;\n\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND))\n\t\treturn -EBADF;\n\n\tif (!file_in->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len, remap_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsnotify_access(file_in);\n\tfsnotify_modify(file_out);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t   loff_t len, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags);\n\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * FICLONE/FICLONERANGE ioctls enforce that src and dest files are on\n\t * the same mount. Practically, they only need to be on the same file\n\t * system.\n\t */\n\tif (inode_in->i_sb != inode_out->i_sb)\n\t\treturn -EXDEV;\n\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND))\n\t\treturn -EBADF;\n\n\tif (!file_in->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len, remap_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsnotify_access(file_in);\n\tfsnotify_modify(file_out);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file_out"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    loff_t len, unsigned int remap_flags)\n{\n\tloff_t ret;\n\n\tfile_start_write(file_out);\n\tret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len,\n\t\t\t\t  remap_flags);\n\tfile_end_write(file_out);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_clone_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1951-1998",
    "snippet": "loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t   loff_t len, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags);\n\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * FICLONE/FICLONERANGE ioctls enforce that src and dest files are on\n\t * the same mount. Practically, they only need to be on the same file\n\t * system.\n\t */\n\tif (inode_in->i_sb != inode_out->i_sb)\n\t\treturn -EXDEV;\n\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND))\n\t\treturn -EBADF;\n\n\tif (!file_in->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len, remap_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsnotify_access(file_in);\n\tfsnotify_modify(file_out);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file_out"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file_in"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_in->f_op->remap_file_range",
          "args": [
            "file_in",
            "pos_in",
            "file_out",
            "pos_out",
            "len",
            "remap_flags"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remap_verify_area",
          "args": [
            "file_out",
            "pos_out",
            "len",
            "true"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "remap_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1692-1714",
          "snippet": "static int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode_out->i_mode"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode_in->i_mode"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode_out->i_mode"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode_in->i_mode"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "remap_flags"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file_out"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t do_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t   loff_t len, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tloff_t ret;\n\n\tWARN_ON_ONCE(remap_flags);\n\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\t/*\n\t * FICLONE/FICLONERANGE ioctls enforce that src and dest files are on\n\t * the same mount. Practically, they only need to be on the same file\n\t * system.\n\t */\n\tif (inode_in->i_sb != inode_out->i_sb)\n\t\treturn -EXDEV;\n\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND))\n\t\treturn -EBADF;\n\n\tif (!file_in->f_op->remap_file_range)\n\t\treturn -EOPNOTSUPP;\n\n\tret = remap_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = remap_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len, remap_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfsnotify_access(file_in);\n\tfsnotify_modify(file_out);\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_remap_file_range_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1853-1948",
    "snippet": "int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t  struct file *file_out, loff_t pos_out,\n\t\t\t\t  loff_t *len, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tbool same_inode = (inode_in == inode_out);\n\tint ret;\n\n\t/* Don't touch certain kinds of inodes */\n\tif (IS_IMMUTABLE(inode_out))\n\t\treturn -EPERM;\n\n\tif (IS_SWAPFILE(inode_in) || IS_SWAPFILE(inode_out))\n\t\treturn -ETXTBSY;\n\n\t/* Don't reflink dirs, pipes, sockets... */\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\t/* Zero length dedupe exits immediately; reflink goes to EOF. */\n\tif (*len == 0) {\n\t\tloff_t isize = i_size_read(inode_in);\n\n\t\tif ((remap_flags & REMAP_FILE_DEDUP) || pos_in == isize)\n\t\t\treturn 0;\n\t\tif (pos_in > isize)\n\t\t\treturn -EINVAL;\n\t\t*len = isize - pos_in;\n\t\tif (*len == 0)\n\t\t\treturn 0;\n\t}\n\n\t/* Check that we don't violate system file offset limits. */\n\tret = generic_remap_checks(file_in, pos_in, file_out, pos_out, len,\n\t\t\tremap_flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Wait for the completion of any pending IOs on both files */\n\tinode_dio_wait(inode_in);\n\tif (!same_inode)\n\t\tinode_dio_wait(inode_out);\n\n\tret = filemap_write_and_wait_range(inode_in->i_mapping,\n\t\t\tpos_in, pos_in + *len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_write_and_wait_range(inode_out->i_mapping,\n\t\t\tpos_out, pos_out + *len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Check that the extents are the same.\n\t */\n\tif (remap_flags & REMAP_FILE_DEDUP) {\n\t\tbool\t\tis_same = false;\n\n\t\tret = vfs_dedupe_file_range_compare(inode_in, pos_in,\n\t\t\t\tinode_out, pos_out, *len, &is_same);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!is_same)\n\t\t\treturn -EBADE;\n\t}\n\n\tret = generic_remap_check_len(inode_in, inode_out, pos_out, len,\n\t\t\tremap_flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If can't alter the file contents, we're done. */\n\tif (!(remap_flags & REMAP_FILE_DEDUP)) {\n\t\t/* Update the timestamps, since we can alter file contents. */\n\t\tif (!(file_out->f_mode & FMODE_NOCMTIME)) {\n\t\t\tret = file_update_time(file_out);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Clear the security bits if the process is not being run by\n\t\t * root.  This keeps people from modifying setuid and setgid\n\t\t * binaries.\n\t\t */\n\t\tret = file_remove_privs(file_out);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_remove_privs",
          "args": [
            "file_out"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "file_remove_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1816-1836",
          "snippet": "int file_remove_privs(struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = file_inode(file);\n\tint kill;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkill = dentry_needs_remove_privs(dentry);\n\tif (kill < 0)\n\t\treturn kill;\n\tif (kill)\n\t\terror = __remove_privs(dentry, kill);\n\tif (!error)\n\t\tinode_has_no_xattr(inode);\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_privs(struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = file_inode(file);\n\tint kill;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkill = dentry_needs_remove_privs(dentry);\n\tif (kill < 0)\n\t\treturn kill;\n\tif (kill)\n\t\terror = __remove_privs(dentry, kill);\n\tif (!error)\n\t\tinode_has_no_xattr(inode);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file_out"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1852-1884",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_remap_check_len",
          "args": [
            "inode_in",
            "inode_out",
            "pos_out",
            "len",
            "remap_flags"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "generic_remap_check_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1727-1752",
          "snippet": "static int generic_remap_check_len(struct inode *inode_in,\n\t\t\t\t   struct inode *inode_out,\n\t\t\t\t   loff_t pos_out,\n\t\t\t\t   loff_t *len,\n\t\t\t\t   unsigned int remap_flags)\n{\n\tu64 blkmask = i_blocksize(inode_in) - 1;\n\tloff_t new_len = *len;\n\n\tif ((*len & blkmask) == 0)\n\t\treturn 0;\n\n\tif ((remap_flags & REMAP_FILE_DEDUP) ||\n\t    pos_out + *len < i_size_read(inode_out))\n\t\tnew_len &= ~blkmask;\n\n\tif (new_len == *len)\n\t\treturn 0;\n\n\tif (remap_flags & REMAP_FILE_CAN_SHORTEN) {\n\t\t*len = new_len;\n\t\treturn 0;\n\t}\n\n\treturn (remap_flags & REMAP_FILE_DEDUP) ? -EBADE : -EINVAL;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int generic_remap_check_len(struct inode *inode_in,\n\t\t\t\t   struct inode *inode_out,\n\t\t\t\t   loff_t pos_out,\n\t\t\t\t   loff_t *len,\n\t\t\t\t   unsigned int remap_flags)\n{\n\tu64 blkmask = i_blocksize(inode_in) - 1;\n\tloff_t new_len = *len;\n\n\tif ((*len & blkmask) == 0)\n\t\treturn 0;\n\n\tif ((remap_flags & REMAP_FILE_DEDUP) ||\n\t    pos_out + *len < i_size_read(inode_out))\n\t\tnew_len &= ~blkmask;\n\n\tif (new_len == *len)\n\t\treturn 0;\n\n\tif (remap_flags & REMAP_FILE_CAN_SHORTEN) {\n\t\t*len = new_len;\n\t\treturn 0;\n\t}\n\n\treturn (remap_flags & REMAP_FILE_DEDUP) ? -EBADE : -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_dedupe_file_range_compare",
          "args": [
            "inode_in",
            "pos_in",
            "inode_out",
            "pos_out",
            "*len",
            "&is_same"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_dedupe_file_range_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1777-1843",
          "snippet": "static int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,\n\t\t\t\t\t struct inode *dest, loff_t destoff,\n\t\t\t\t\t loff_t len, bool *is_same)\n{\n\tloff_t src_poff;\n\tloff_t dest_poff;\n\tvoid *src_addr;\n\tvoid *dest_addr;\n\tstruct page *src_page;\n\tstruct page *dest_page;\n\tloff_t cmp_len;\n\tbool same;\n\tint error;\n\n\terror = -EINVAL;\n\tsame = true;\n\twhile (len) {\n\t\tsrc_poff = srcoff & (PAGE_SIZE - 1);\n\t\tdest_poff = destoff & (PAGE_SIZE - 1);\n\t\tcmp_len = min(PAGE_SIZE - src_poff,\n\t\t\t      PAGE_SIZE - dest_poff);\n\t\tcmp_len = min(cmp_len, len);\n\t\tif (cmp_len <= 0)\n\t\t\tgoto out_error;\n\n\t\tsrc_page = vfs_dedupe_get_page(src, srcoff);\n\t\tif (IS_ERR(src_page)) {\n\t\t\terror = PTR_ERR(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tdest_page = vfs_dedupe_get_page(dest, destoff);\n\t\tif (IS_ERR(dest_page)) {\n\t\t\terror = PTR_ERR(dest_page);\n\t\t\tunlock_page(src_page);\n\t\t\tput_page(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tsrc_addr = kmap_atomic(src_page);\n\t\tdest_addr = kmap_atomic(dest_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dest_page);\n\n\t\tif (memcmp(src_addr + src_poff, dest_addr + dest_poff, cmp_len))\n\t\t\tsame = false;\n\n\t\tkunmap_atomic(dest_addr);\n\t\tkunmap_atomic(src_addr);\n\t\tunlock_page(dest_page);\n\t\tunlock_page(src_page);\n\t\tput_page(dest_page);\n\t\tput_page(src_page);\n\n\t\tif (!same)\n\t\t\tbreak;\n\n\t\tsrcoff += cmp_len;\n\t\tdestoff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\t*is_same = same;\n\treturn 0;\n\nout_error:\n\treturn error;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,\n\t\t\t\t\t struct inode *dest, loff_t destoff,\n\t\t\t\t\t loff_t len, bool *is_same)\n{\n\tloff_t src_poff;\n\tloff_t dest_poff;\n\tvoid *src_addr;\n\tvoid *dest_addr;\n\tstruct page *src_page;\n\tstruct page *dest_page;\n\tloff_t cmp_len;\n\tbool same;\n\tint error;\n\n\terror = -EINVAL;\n\tsame = true;\n\twhile (len) {\n\t\tsrc_poff = srcoff & (PAGE_SIZE - 1);\n\t\tdest_poff = destoff & (PAGE_SIZE - 1);\n\t\tcmp_len = min(PAGE_SIZE - src_poff,\n\t\t\t      PAGE_SIZE - dest_poff);\n\t\tcmp_len = min(cmp_len, len);\n\t\tif (cmp_len <= 0)\n\t\t\tgoto out_error;\n\n\t\tsrc_page = vfs_dedupe_get_page(src, srcoff);\n\t\tif (IS_ERR(src_page)) {\n\t\t\terror = PTR_ERR(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tdest_page = vfs_dedupe_get_page(dest, destoff);\n\t\tif (IS_ERR(dest_page)) {\n\t\t\terror = PTR_ERR(dest_page);\n\t\t\tunlock_page(src_page);\n\t\t\tput_page(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tsrc_addr = kmap_atomic(src_page);\n\t\tdest_addr = kmap_atomic(dest_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dest_page);\n\n\t\tif (memcmp(src_addr + src_poff, dest_addr + dest_poff, cmp_len))\n\t\t\tsame = false;\n\n\t\tkunmap_atomic(dest_addr);\n\t\tkunmap_atomic(src_addr);\n\t\tunlock_page(dest_page);\n\t\tunlock_page(src_page);\n\t\tput_page(dest_page);\n\t\tput_page(src_page);\n\n\t\tif (!same)\n\t\t\tbreak;\n\n\t\tsrcoff += cmp_len;\n\t\tdestoff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\t*is_same = same;\n\treturn 0;\n\nout_error:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode_out->i_mapping",
            "pos_out",
            "pos_out + *len - 1"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_filemap_write_and_wait_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/write.c",
          "lines": "1962-1971",
          "snippet": "int nfs_filemap_write_and_wait_range(struct address_space *mapping,\n\t\tloff_t lstart, loff_t lend)\n{\n\tint ret;\n\n\tret = filemap_write_and_wait_range(mapping, lstart, lend);\n\tif (ret == 0)\n\t\tret = pnfs_sync_inode(mapping->host, true);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/iversion.h>",
            "#include <linux/wait.h>",
            "#include <linux/freezer.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <linux/uaccess.h>\n#include <linux/iversion.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint nfs_filemap_write_and_wait_range(struct address_space *mapping,\n\t\tloff_t lstart, loff_t lend)\n{\n\tint ret;\n\n\tret = filemap_write_and_wait_range(mapping, lstart, lend);\n\tif (ret == 0)\n\t\tret = pnfs_sync_inode(mapping->host, true);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode_out"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2073-2077",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_remap_checks",
          "args": [
            "file_in",
            "pos_in",
            "file_out",
            "pos_out",
            "len",
            "remap_flags"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode_in"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode_out->i_mode"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode_in->i_mode"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode_out->i_mode"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode_in->i_mode"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode_out"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode_in"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode_out"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file_out"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,\n\t\t\t\t  struct file *file_out, loff_t pos_out,\n\t\t\t\t  loff_t *len, unsigned int remap_flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tbool same_inode = (inode_in == inode_out);\n\tint ret;\n\n\t/* Don't touch certain kinds of inodes */\n\tif (IS_IMMUTABLE(inode_out))\n\t\treturn -EPERM;\n\n\tif (IS_SWAPFILE(inode_in) || IS_SWAPFILE(inode_out))\n\t\treturn -ETXTBSY;\n\n\t/* Don't reflink dirs, pipes, sockets... */\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\t/* Zero length dedupe exits immediately; reflink goes to EOF. */\n\tif (*len == 0) {\n\t\tloff_t isize = i_size_read(inode_in);\n\n\t\tif ((remap_flags & REMAP_FILE_DEDUP) || pos_in == isize)\n\t\t\treturn 0;\n\t\tif (pos_in > isize)\n\t\t\treturn -EINVAL;\n\t\t*len = isize - pos_in;\n\t\tif (*len == 0)\n\t\t\treturn 0;\n\t}\n\n\t/* Check that we don't violate system file offset limits. */\n\tret = generic_remap_checks(file_in, pos_in, file_out, pos_out, len,\n\t\t\tremap_flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Wait for the completion of any pending IOs on both files */\n\tinode_dio_wait(inode_in);\n\tif (!same_inode)\n\t\tinode_dio_wait(inode_out);\n\n\tret = filemap_write_and_wait_range(inode_in->i_mapping,\n\t\t\tpos_in, pos_in + *len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_write_and_wait_range(inode_out->i_mapping,\n\t\t\tpos_out, pos_out + *len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Check that the extents are the same.\n\t */\n\tif (remap_flags & REMAP_FILE_DEDUP) {\n\t\tbool\t\tis_same = false;\n\n\t\tret = vfs_dedupe_file_range_compare(inode_in, pos_in,\n\t\t\t\tinode_out, pos_out, *len, &is_same);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!is_same)\n\t\t\treturn -EBADE;\n\t}\n\n\tret = generic_remap_check_len(inode_in, inode_out, pos_out, len,\n\t\t\tremap_flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If can't alter the file contents, we're done. */\n\tif (!(remap_flags & REMAP_FILE_DEDUP)) {\n\t\t/* Update the timestamps, since we can alter file contents. */\n\t\tif (!(file_out->f_mode & FMODE_NOCMTIME)) {\n\t\t\tret = file_update_time(file_out);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Clear the security bits if the process is not being run by\n\t\t * root.  This keeps people from modifying setuid and setgid\n\t\t * binaries.\n\t\t */\n\t\tret = file_remove_privs(file_out);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vfs_dedupe_file_range_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1777-1843",
    "snippet": "static int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,\n\t\t\t\t\t struct inode *dest, loff_t destoff,\n\t\t\t\t\t loff_t len, bool *is_same)\n{\n\tloff_t src_poff;\n\tloff_t dest_poff;\n\tvoid *src_addr;\n\tvoid *dest_addr;\n\tstruct page *src_page;\n\tstruct page *dest_page;\n\tloff_t cmp_len;\n\tbool same;\n\tint error;\n\n\terror = -EINVAL;\n\tsame = true;\n\twhile (len) {\n\t\tsrc_poff = srcoff & (PAGE_SIZE - 1);\n\t\tdest_poff = destoff & (PAGE_SIZE - 1);\n\t\tcmp_len = min(PAGE_SIZE - src_poff,\n\t\t\t      PAGE_SIZE - dest_poff);\n\t\tcmp_len = min(cmp_len, len);\n\t\tif (cmp_len <= 0)\n\t\t\tgoto out_error;\n\n\t\tsrc_page = vfs_dedupe_get_page(src, srcoff);\n\t\tif (IS_ERR(src_page)) {\n\t\t\terror = PTR_ERR(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tdest_page = vfs_dedupe_get_page(dest, destoff);\n\t\tif (IS_ERR(dest_page)) {\n\t\t\terror = PTR_ERR(dest_page);\n\t\t\tunlock_page(src_page);\n\t\t\tput_page(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tsrc_addr = kmap_atomic(src_page);\n\t\tdest_addr = kmap_atomic(dest_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dest_page);\n\n\t\tif (memcmp(src_addr + src_poff, dest_addr + dest_poff, cmp_len))\n\t\t\tsame = false;\n\n\t\tkunmap_atomic(dest_addr);\n\t\tkunmap_atomic(src_addr);\n\t\tunlock_page(dest_page);\n\t\tunlock_page(src_page);\n\t\tput_page(dest_page);\n\t\tput_page(src_page);\n\n\t\tif (!same)\n\t\t\tbreak;\n\n\t\tsrcoff += cmp_len;\n\t\tdestoff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\t*is_same = same;\n\treturn 0;\n\nout_error:\n\treturn error;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "src_page"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "src_page"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "src_addr"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dest_addr"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "src_addr + src_poff",
            "dest_addr + dest_poff",
            "cmp_len"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "dest_page"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dest_page"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "src_page"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dest_page"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dest_page"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_dedupe_get_page",
          "args": [
            "dest",
            "destoff"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_dedupe_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1758-1771",
          "snippet": "static struct page *vfs_dedupe_get_page(struct inode *inode, loff_t offset)\n{\n\tstruct page *page;\n\n\tpage = read_mapping_page(inode->i_mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tlock_page(page);\n\treturn page;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic struct page *vfs_dedupe_get_page(struct inode *inode, loff_t offset)\n{\n\tstruct page *page;\n\n\tpage = read_mapping_page(inode->i_mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tlock_page(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "src_page"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "src_page"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cmp_len",
            "len"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,\n\t\t\t\t\t struct inode *dest, loff_t destoff,\n\t\t\t\t\t loff_t len, bool *is_same)\n{\n\tloff_t src_poff;\n\tloff_t dest_poff;\n\tvoid *src_addr;\n\tvoid *dest_addr;\n\tstruct page *src_page;\n\tstruct page *dest_page;\n\tloff_t cmp_len;\n\tbool same;\n\tint error;\n\n\terror = -EINVAL;\n\tsame = true;\n\twhile (len) {\n\t\tsrc_poff = srcoff & (PAGE_SIZE - 1);\n\t\tdest_poff = destoff & (PAGE_SIZE - 1);\n\t\tcmp_len = min(PAGE_SIZE - src_poff,\n\t\t\t      PAGE_SIZE - dest_poff);\n\t\tcmp_len = min(cmp_len, len);\n\t\tif (cmp_len <= 0)\n\t\t\tgoto out_error;\n\n\t\tsrc_page = vfs_dedupe_get_page(src, srcoff);\n\t\tif (IS_ERR(src_page)) {\n\t\t\terror = PTR_ERR(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tdest_page = vfs_dedupe_get_page(dest, destoff);\n\t\tif (IS_ERR(dest_page)) {\n\t\t\terror = PTR_ERR(dest_page);\n\t\t\tunlock_page(src_page);\n\t\t\tput_page(src_page);\n\t\t\tgoto out_error;\n\t\t}\n\t\tsrc_addr = kmap_atomic(src_page);\n\t\tdest_addr = kmap_atomic(dest_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dest_page);\n\n\t\tif (memcmp(src_addr + src_poff, dest_addr + dest_poff, cmp_len))\n\t\t\tsame = false;\n\n\t\tkunmap_atomic(dest_addr);\n\t\tkunmap_atomic(src_addr);\n\t\tunlock_page(dest_page);\n\t\tunlock_page(src_page);\n\t\tput_page(dest_page);\n\t\tput_page(src_page);\n\n\t\tif (!same)\n\t\t\tbreak;\n\n\t\tsrcoff += cmp_len;\n\t\tdestoff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\t*is_same = same;\n\treturn 0;\n\nout_error:\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_dedupe_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1758-1771",
    "snippet": "static struct page *vfs_dedupe_get_page(struct inode *inode, loff_t offset)\n{\n\tstruct page *page;\n\n\tpage = read_mapping_page(inode->i_mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tlock_page(page);\n\treturn page;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "inode->i_mapping",
            "offset >> PAGE_SHIFT",
            "NULL"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic struct page *vfs_dedupe_get_page(struct inode *inode, loff_t offset)\n{\n\tstruct page *page;\n\n\tpage = read_mapping_page(inode->i_mapping, offset >> PAGE_SHIFT, NULL);\n\tif (IS_ERR(page))\n\t\treturn page;\n\tif (!PageUptodate(page)) {\n\t\tput_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tlock_page(page);\n\treturn page;\n}"
  },
  {
    "function_name": "generic_remap_check_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1727-1752",
    "snippet": "static int generic_remap_check_len(struct inode *inode_in,\n\t\t\t\t   struct inode *inode_out,\n\t\t\t\t   loff_t pos_out,\n\t\t\t\t   loff_t *len,\n\t\t\t\t   unsigned int remap_flags)\n{\n\tu64 blkmask = i_blocksize(inode_in) - 1;\n\tloff_t new_len = *len;\n\n\tif ((*len & blkmask) == 0)\n\t\treturn 0;\n\n\tif ((remap_flags & REMAP_FILE_DEDUP) ||\n\t    pos_out + *len < i_size_read(inode_out))\n\t\tnew_len &= ~blkmask;\n\n\tif (new_len == *len)\n\t\treturn 0;\n\n\tif (remap_flags & REMAP_FILE_CAN_SHORTEN) {\n\t\t*len = new_len;\n\t\treturn 0;\n\t}\n\n\treturn (remap_flags & REMAP_FILE_DEDUP) ? -EBADE : -EINVAL;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode_out"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_blocksize",
          "args": [
            "inode_in"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int generic_remap_check_len(struct inode *inode_in,\n\t\t\t\t   struct inode *inode_out,\n\t\t\t\t   loff_t pos_out,\n\t\t\t\t   loff_t *len,\n\t\t\t\t   unsigned int remap_flags)\n{\n\tu64 blkmask = i_blocksize(inode_in) - 1;\n\tloff_t new_len = *len;\n\n\tif ((*len & blkmask) == 0)\n\t\treturn 0;\n\n\tif ((remap_flags & REMAP_FILE_DEDUP) ||\n\t    pos_out + *len < i_size_read(inode_out))\n\t\tnew_len &= ~blkmask;\n\n\tif (new_len == *len)\n\t\treturn 0;\n\n\tif (remap_flags & REMAP_FILE_CAN_SHORTEN) {\n\t\t*len = new_len;\n\t\treturn 0;\n\t}\n\n\treturn (remap_flags & REMAP_FILE_DEDUP) ? -EBADE : -EINVAL;\n}"
  },
  {
    "function_name": "remap_verify_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1692-1714",
    "snippet": "static int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_file_permission",
          "args": [
            "file",
            "write ? MAY_WRITE : MAY_READ"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_mandatory_area",
          "args": [
            "inode",
            "file",
            "pos",
            "end",
            "write ? F_WRLCK : F_RDLCK"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1295-1342",
          "snippet": "int locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,\n\t\t\t loff_t end, unsigned char type)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = type;\n\tfl.fl_start = start;\n\tfl.fl_end = end;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,\n\t\t\t loff_t end, unsigned char type)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = type;\n\tfl.fl_start = start;\n\tfl.fl_end = end;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_flctx && mandatory_lock(inode)"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1258-1283",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(loff_t) (pos + len) < 0"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pos + len"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pos < 0 || len < 0"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic int remap_verify_area(struct file *file, loff_t pos, loff_t len,\n\t\t\t     bool write)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(pos < 0 || len < 0))\n\t\treturn -EINVAL;\n\n\t if (unlikely((loff_t) (pos + len) < 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tloff_t end = len ? pos + len - 1 : OFFSET_MAX;\n\t\tint retval;\n\n\t\tretval = locks_mandatory_area(inode, file, pos, end,\n\t\t\t\twrite ? F_WRLCK : F_RDLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\treturn security_file_permission(file, write ? MAY_WRITE : MAY_READ);\n}"
  },
  {
    "function_name": "vfs_copy_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1548-1627",
    "snippet": "ssize_t vfs_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    size_t len, unsigned int flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tssize_t ret;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(READ, file_in, &pos_in, len);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = rw_verify_area(WRITE, file_out, &pos_out, len);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND))\n\t\treturn -EBADF;\n\n\t/* this could be relaxed once a method supports cross-fs copies */\n\tif (inode_in->i_sb != inode_out->i_sb)\n\t\treturn -EXDEV;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tfile_start_write(file_out);\n\n\t/*\n\t * Try cloning first, this is supported by more file systems, and\n\t * more efficient if both clone and copy are supported (e.g. NFS).\n\t */\n\tif (file_in->f_op->remap_file_range) {\n\t\tloff_t cloned;\n\n\t\tcloned = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\t\tfile_out, pos_out,\n\t\t\t\tmin_t(loff_t, MAX_RW_COUNT, len),\n\t\t\t\tREMAP_FILE_CAN_SHORTEN);\n\t\tif (cloned > 0) {\n\t\t\tret = cloned;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (file_out->f_op->copy_file_range) {\n\t\tret = file_out->f_op->copy_file_range(file_in, pos_in, file_out,\n\t\t\t\t\t\t      pos_out, len, flags);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\tgoto done;\n\t}\n\n\tret = do_splice_direct(file_in, &pos_in, file_out, &pos_out,\n\t\t\tlen > MAX_RW_COUNT ? MAX_RW_COUNT : len, 0);\n\ndone:\n\tif (ret > 0) {\n\t\tfsnotify_access(file_in);\n\t\tadd_rchar(current, ret);\n\t\tfsnotify_modify(file_out);\n\t\tadd_wchar(current, ret);\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\n\tfile_end_write(file_out);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file_out"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file_out"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file_in"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_direct",
          "args": [
            "file_in",
            "&pos_in",
            "file_out",
            "&pos_out",
            "len > MAX_RW_COUNT ? MAX_RW_COUNT : len",
            "0"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1038-1066",
          "snippet": "long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_out->f_op->copy_file_range",
          "args": [
            "file_in",
            "pos_in",
            "file_out",
            "pos_out",
            "len",
            "flags"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_in->f_op->remap_file_range",
          "args": [
            "file_in",
            "pos_in",
            "file_out",
            "pos_out",
            "min_t(loff_t, MAX_RW_COUNT, len)",
            "REMAP_FILE_CAN_SHORTEN"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "MAX_RW_COUNT",
            "len"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file_out"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "file_out",
            "&pos_out",
            "len"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode_out->i_mode"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode_in->i_mode"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode_out->i_mode"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode_in->i_mode"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file_out"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_copy_file_range(struct file *file_in, loff_t pos_in,\n\t\t\t    struct file *file_out, loff_t pos_out,\n\t\t\t    size_t len, unsigned int flags)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tssize_t ret;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(READ, file_in, &pos_in, len);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = rw_verify_area(WRITE, file_out, &pos_out, len);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND))\n\t\treturn -EBADF;\n\n\t/* this could be relaxed once a method supports cross-fs copies */\n\tif (inode_in->i_sb != inode_out->i_sb)\n\t\treturn -EXDEV;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tfile_start_write(file_out);\n\n\t/*\n\t * Try cloning first, this is supported by more file systems, and\n\t * more efficient if both clone and copy are supported (e.g. NFS).\n\t */\n\tif (file_in->f_op->remap_file_range) {\n\t\tloff_t cloned;\n\n\t\tcloned = file_in->f_op->remap_file_range(file_in, pos_in,\n\t\t\t\tfile_out, pos_out,\n\t\t\t\tmin_t(loff_t, MAX_RW_COUNT, len),\n\t\t\t\tREMAP_FILE_CAN_SHORTEN);\n\t\tif (cloned > 0) {\n\t\t\tret = cloned;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (file_out->f_op->copy_file_range) {\n\t\tret = file_out->f_op->copy_file_range(file_in, pos_in, file_out,\n\t\t\t\t\t\t      pos_out, len, flags);\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\tgoto done;\n\t}\n\n\tret = do_splice_direct(file_in, &pos_in, file_out, &pos_out,\n\t\t\tlen > MAX_RW_COUNT ? MAX_RW_COUNT : len, 0);\n\ndone:\n\tif (ret > 0) {\n\t\tfsnotify_access(file_in);\n\t\tadd_rchar(current, ret);\n\t\tfsnotify_modify(file_out);\n\t\tadd_wchar(current, ret);\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\n\tfile_end_write(file_out);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sendfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1368-1465",
    "snippet": "static ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,\n\t\t  \t   size_t count, loff_t max)\n{\n\tstruct fd in, out;\n\tstruct inode *in_inode, *out_inode;\n\tloff_t pos;\n\tloff_t out_pos;\n\tssize_t retval;\n\tint fl;\n\n\t/*\n\t * Get input file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tin = fdget(in_fd);\n\tif (!in.file)\n\t\tgoto out;\n\tif (!(in.file->f_mode & FMODE_READ))\n\t\tgoto fput_in;\n\tretval = -ESPIPE;\n\tif (!ppos) {\n\t\tpos = in.file->f_pos;\n\t} else {\n\t\tpos = *ppos;\n\t\tif (!(in.file->f_mode & FMODE_PREAD))\n\t\t\tgoto fput_in;\n\t}\n\tretval = rw_verify_area(READ, in.file, &pos, count);\n\tif (retval < 0)\n\t\tgoto fput_in;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\n\t/*\n\t * Get output file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tout = fdget(out_fd);\n\tif (!out.file)\n\t\tgoto fput_in;\n\tif (!(out.file->f_mode & FMODE_WRITE))\n\t\tgoto fput_out;\n\tin_inode = file_inode(in.file);\n\tout_inode = file_inode(out.file);\n\tout_pos = out.file->f_pos;\n\tretval = rw_verify_area(WRITE, out.file, &out_pos, count);\n\tif (retval < 0)\n\t\tgoto fput_out;\n\n\tif (!max)\n\t\tmax = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);\n\n\tif (unlikely(pos + count > max)) {\n\t\tretval = -EOVERFLOW;\n\t\tif (pos >= max)\n\t\t\tgoto fput_out;\n\t\tcount = max - pos;\n\t}\n\n\tfl = 0;\n#if 0\n\t/*\n\t * We need to debate whether we can enable this or not. The\n\t * man page documents EAGAIN return for the output at least,\n\t * and the application is arguably buggy if it doesn't expect\n\t * EAGAIN on a non-blocking file descriptor.\n\t */\n\tif (in.file->f_flags & O_NONBLOCK)\n\t\tfl = SPLICE_F_NONBLOCK;\n#endif\n\tfile_start_write(out.file);\n\tretval = do_splice_direct(in.file, &pos, out.file, &out_pos, count, fl);\n\tfile_end_write(out.file);\n\n\tif (retval > 0) {\n\t\tadd_rchar(current, retval);\n\t\tadd_wchar(current, retval);\n\t\tfsnotify_access(in.file);\n\t\tfsnotify_modify(out.file);\n\t\tout.file->f_pos = out_pos;\n\t\tif (ppos)\n\t\t\t*ppos = pos;\n\t\telse\n\t\t\tin.file->f_pos = pos;\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\tif (pos > max)\n\t\tretval = -EOVERFLOW;\n\nfput_out:\n\tfdput(out);\nfput_in:\n\tfdput(in);\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "in"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "out"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "out.file"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "in.file"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "retval"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "retval"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "out.file"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_direct",
          "args": [
            "in.file",
            "&pos",
            "out.file",
            "&out_pos",
            "count",
            "fl"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1038-1066",
          "snippet": "long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "out.file"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pos + count > max"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "in_inode->i_sb->s_maxbytes",
            "out_inode->i_sb->s_maxbytes"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "out.file",
            "&out_pos",
            "count"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "out.file"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "out_fd"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,\n\t\t  \t   size_t count, loff_t max)\n{\n\tstruct fd in, out;\n\tstruct inode *in_inode, *out_inode;\n\tloff_t pos;\n\tloff_t out_pos;\n\tssize_t retval;\n\tint fl;\n\n\t/*\n\t * Get input file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tin = fdget(in_fd);\n\tif (!in.file)\n\t\tgoto out;\n\tif (!(in.file->f_mode & FMODE_READ))\n\t\tgoto fput_in;\n\tretval = -ESPIPE;\n\tif (!ppos) {\n\t\tpos = in.file->f_pos;\n\t} else {\n\t\tpos = *ppos;\n\t\tif (!(in.file->f_mode & FMODE_PREAD))\n\t\t\tgoto fput_in;\n\t}\n\tretval = rw_verify_area(READ, in.file, &pos, count);\n\tif (retval < 0)\n\t\tgoto fput_in;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\n\t/*\n\t * Get output file, and verify that it is ok..\n\t */\n\tretval = -EBADF;\n\tout = fdget(out_fd);\n\tif (!out.file)\n\t\tgoto fput_in;\n\tif (!(out.file->f_mode & FMODE_WRITE))\n\t\tgoto fput_out;\n\tin_inode = file_inode(in.file);\n\tout_inode = file_inode(out.file);\n\tout_pos = out.file->f_pos;\n\tretval = rw_verify_area(WRITE, out.file, &out_pos, count);\n\tif (retval < 0)\n\t\tgoto fput_out;\n\n\tif (!max)\n\t\tmax = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);\n\n\tif (unlikely(pos + count > max)) {\n\t\tretval = -EOVERFLOW;\n\t\tif (pos >= max)\n\t\t\tgoto fput_out;\n\t\tcount = max - pos;\n\t}\n\n\tfl = 0;\n#if 0\n\t/*\n\t * We need to debate whether we can enable this or not. The\n\t * man page documents EAGAIN return for the output at least,\n\t * and the application is arguably buggy if it doesn't expect\n\t * EAGAIN on a non-blocking file descriptor.\n\t */\n\tif (in.file->f_flags & O_NONBLOCK)\n\t\tfl = SPLICE_F_NONBLOCK;\n#endif\n\tfile_start_write(out.file);\n\tretval = do_splice_direct(in.file, &pos, out.file, &out_pos, count, fl);\n\tfile_end_write(out.file);\n\n\tif (retval > 0) {\n\t\tadd_rchar(current, retval);\n\t\tadd_wchar(current, retval);\n\t\tfsnotify_access(in.file);\n\t\tfsnotify_modify(out.file);\n\t\tout.file->f_pos = out_pos;\n\t\tif (ppos)\n\t\t\t*ppos = pos;\n\t\telse\n\t\t\tin.file->f_pos = pos;\n\t}\n\n\tinc_syscr(current);\n\tinc_syscw(current);\n\tif (pos > max)\n\t\tretval = -EOVERFLOW;\n\nfput_out:\n\tfdput(out);\nfput_in:\n\tfdput(in);\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "do_compat_pwritev64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1308-1325",
    "snippet": "static long do_compat_pwritev64(unsigned long fd,\n\t\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t\t   unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PWRITE)\n\t\tret = compat_writev(f.file, vec, vlen, &pos, flags);\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_writev",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "compat_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1261-1281",
          "snippet": "static size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(WRITE, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(WRITE, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic long do_compat_pwritev64(unsigned long fd,\n\t\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t\t   unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PWRITE)\n\t\tret = compat_writev(f.file, vec, vlen, &pos, flags);\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_compat_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1283-1299",
    "snippet": "static size_t do_compat_writev(compat_ulong_t fd,\n\t\t\t\t  const struct compat_iovec __user* vec,\n\t\t\t\t  compat_ulong_t vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret;\n\tloff_t pos;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tpos = f.file->f_pos;\n\tret = compat_writev(f.file, vec, vlen, &pos, flags);\n\tif (ret >= 0)\n\t\tf.file->f_pos = pos;\n\tfdput_pos(f);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_writev",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "compat_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1261-1281",
          "snippet": "static size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(WRITE, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(WRITE, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t do_compat_writev(compat_ulong_t fd,\n\t\t\t\t  const struct compat_iovec __user* vec,\n\t\t\t\t  compat_ulong_t vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret;\n\tloff_t pos;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tpos = f.file->f_pos;\n\tret = compat_writev(f.file, vec, vlen, &pos, flags);\n\tif (ret >= 0)\n\t\tf.file->f_pos = pos;\n\tfdput_pos(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1261-1281",
    "snippet": "static size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(WRITE, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_iter_write",
          "args": [
            "file",
            "&iter",
            "pos",
            "flags"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "940-965",
          "snippet": "static ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_import_iovec",
          "args": [
            "WRITE",
            "vec",
            "vlen",
            "UIO_FASTIOV",
            "&iov",
            "&iter"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_writev(struct file *file,\n\t\t\t    const struct compat_iovec __user *vec,\n\t\t\t    unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(WRITE, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_compat_preadv64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1202-1219",
    "snippet": "static long do_compat_preadv64(unsigned long fd,\n\t\t\t\t  const struct compat_iovec __user *vec,\n\t\t\t\t  unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PREAD)\n\t\tret = compat_readv(f.file, vec, vlen, &pos, flags);\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_readv",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "compat_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1156-1174",
          "snippet": "static size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(READ, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(READ, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic long do_compat_preadv64(unsigned long fd,\n\t\t\t\t  const struct compat_iovec __user *vec,\n\t\t\t\t  unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -ESPIPE;\n\tif (f.file->f_mode & FMODE_PREAD)\n\t\tret = compat_readv(f.file, vec, vlen, &pos, flags);\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_compat_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1176-1193",
    "snippet": "static size_t do_compat_readv(compat_ulong_t fd,\n\t\t\t\t const struct compat_iovec __user *vec,\n\t\t\t\t compat_ulong_t vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret;\n\tloff_t pos;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tpos = f.file->f_pos;\n\tret = compat_readv(f.file, vec, vlen, &pos, flags);\n\tif (ret >= 0)\n\t\tf.file->f_pos = pos;\n\tfdput_pos(f);\n\treturn ret;\n\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_readv",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "compat_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "1156-1174",
          "snippet": "static size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(READ, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(READ, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t do_compat_readv(compat_ulong_t fd,\n\t\t\t\t const struct compat_iovec __user *vec,\n\t\t\t\t compat_ulong_t vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret;\n\tloff_t pos;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tpos = f.file->f_pos;\n\tret = compat_readv(f.file, vec, vlen, &pos, flags);\n\tif (ret >= 0)\n\t\tf.file->f_pos = pos;\n\tfdput_pos(f);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "compat_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1156-1174",
    "snippet": "static size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(READ, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_iter_read",
          "args": [
            "file",
            "&iter",
            "pos",
            "flags"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "903-929",
          "snippet": "static ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_import_iovec",
          "args": [
            "READ",
            "vec",
            "vlen",
            "UIO_FASTIOV",
            "&iov",
            "&iter"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic size_t compat_readv(struct file *file,\n\t\t\t   const struct compat_iovec __user *vec,\n\t\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = compat_import_iovec(READ, vec, vlen, UIO_FASTIOV, &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_pwritev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1080-1101",
    "snippet": "static ssize_t do_pwritev(unsigned long fd, const struct iovec __user *vec,\n\t\t\t  unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PWRITE)\n\t\t\tret = vfs_writev(f.file, vec, vlen, &pos, flags);\n\t\tfdput(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_writev",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "993-1009",
          "snippet": "static ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_pwritev(unsigned long fd, const struct iovec __user *vec,\n\t\t\t  unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PWRITE)\n\t\t\tret = vfs_writev(f.file, vec, vlen, &pos, flags);\n\t\tfdput(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_preadv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1057-1078",
    "snippet": "static ssize_t do_preadv(unsigned long fd, const struct iovec __user *vec,\n\t\t\t unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PREAD)\n\t\t\tret = vfs_readv(f.file, vec, vlen, &pos, flags);\n\t\tfdput(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_readv",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "976-991",
          "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_preadv(unsigned long fd, const struct iovec __user *vec,\n\t\t\t unsigned long vlen, loff_t pos, rwf_t flags)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PREAD)\n\t\t\tret = vfs_readv(f.file, vec, vlen, &pos, flags);\n\t\tfdput(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "pos_from_hilo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1051-1055",
    "snippet": "static inline loff_t pos_from_hilo(unsigned long high, unsigned long low)\n{\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\n\treturn (((loff_t)high << HALF_LONG_BITS) << HALF_LONG_BITS) | low;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define HALF_LONG_BITS (BITS_PER_LONG / 2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\n\nstatic inline loff_t pos_from_hilo(unsigned long high, unsigned long low)\n{\n#define HALF_LONG_BITS (BITS_PER_LONG / 2)\n\treturn (((loff_t)high << HALF_LONG_BITS) << HALF_LONG_BITS) | low;\n}"
  },
  {
    "function_name": "do_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1031-1049",
    "snippet": "static ssize_t do_writev(unsigned long fd, const struct iovec __user *vec,\n\t\t\t unsigned long vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_writev(f.file, vec, vlen, &pos, flags);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_pos_write",
          "args": [
            "f.file",
            "pos"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "566-569",
          "snippet": "static inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_writev",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "993-1009",
          "snippet": "static ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_pos_read",
          "args": [
            "f.file"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "561-564",
          "snippet": "static inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_writev(unsigned long fd, const struct iovec __user *vec,\n\t\t\t unsigned long vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_writev(f.file, vec, vlen, &pos, flags);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_wchar(current, ret);\n\tinc_syscw(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1011-1029",
    "snippet": "static ssize_t do_readv(unsigned long fd, const struct iovec __user *vec,\n\t\t\tunsigned long vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_readv(f.file, vec, vlen, &pos, flags);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_pos_write",
          "args": [
            "f.file",
            "pos"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "566-569",
          "snippet": "static inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_readv",
          "args": [
            "f.file",
            "vec",
            "vlen",
            "&pos",
            "flags"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "976-991",
          "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_pos_read",
          "args": [
            "f.file"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "561-564",
          "snippet": "static inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_readv(unsigned long fd, const struct iovec __user *vec,\n\t\t\tunsigned long vlen, rwf_t flags)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_readv(f.file, vec, vlen, &pos, flags);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\n\tif (ret > 0)\n\t\tadd_rchar(current, ret);\n\tinc_syscr(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "993-1009",
    "snippet": "static ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_iter_write",
          "args": [
            "file",
            "&iter",
            "pos",
            "flags"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "940-965",
          "snippet": "static ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "import_iovec",
          "args": [
            "WRITE",
            "vec",
            "vlen",
            "ARRAY_SIZE(iovstack)",
            "&iov",
            "&iter"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iovstack"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tfile_start_write(file);\n\t\tret = do_iter_write(file, &iter, pos, flags);\n\t\tfile_end_write(file);\n\t\tkfree(iov);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "976-991",
    "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_iter_read",
          "args": [
            "file",
            "&iter",
            "pos",
            "flags"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "903-929",
          "snippet": "static ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "import_iovec",
          "args": [
            "READ",
            "vec",
            "vlen",
            "ARRAY_SIZE(iovstack)",
            "&iov",
            "&iter"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iovstack"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_iter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "967-973",
    "snippet": "ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_write(file, iter, ppos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_iter_write",
          "args": [
            "file",
            "iter",
            "ppos",
            "flags"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "940-965",
          "snippet": "static ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_write(file, iter, ppos, flags);\n}"
  },
  {
    "function_name": "do_iter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "940-965",
    "snippet": "static ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_loop_readv_writev",
          "args": [
            "file",
            "iter",
            "pos",
            "WRITE",
            "flags"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "do_loop_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "687-719",
          "snippet": "static ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tssize_t ret = 0;\n\n\tif (flags & ~RWF_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec = iov_iter_iovec(iter);\n\t\tssize_t nr;\n\n\t\tif (type == READ) {\n\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tssize_t ret = 0;\n\n\tif (flags & ~RWF_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec = iov_iter_iovec(iter);\n\t\tssize_t nr;\n\n\t\tif (type == READ) {\n\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_iter_readv_writev",
          "args": [
            "file",
            "iter",
            "pos",
            "WRITE",
            "flags"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "665-684",
          "snippet": "static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tret = kiocb_set_rw_flags(&kiocb, flags);\n\tif (ret)\n\t\treturn ret;\n\tkiocb.ki_pos = *ppos;\n\n\tif (type == READ)\n\t\tret = call_read_iter(filp, &kiocb, iter);\n\telse\n\t\tret = call_write_iter(filp, &kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tret = kiocb_set_rw_flags(&kiocb, flags);\n\tif (ret)\n\t\treturn ret;\n\tkiocb.ki_pos = *ppos;\n\n\tif (type == READ)\n\t\tret = call_read_iter(filp, &kiocb, iter);\n\telse\n\t\tret = call_write_iter(filp, &kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "file",
            "pos",
            "tot_len"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\treturn 0;\n\tret = rw_verify_area(WRITE, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, WRITE, flags);\n\tif (ret > 0)\n\t\tfsnotify_modify(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_iter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "931-937",
    "snippet": "ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->read_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_read(file, iter, ppos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_iter_read",
          "args": [
            "file",
            "iter",
            "ppos",
            "flags"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "903-929",
          "snippet": "static ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->read_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_read(file, iter, ppos, flags);\n}"
  },
  {
    "function_name": "do_iter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "903-929",
    "snippet": "static ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_loop_readv_writev",
          "args": [
            "file",
            "iter",
            "pos",
            "READ",
            "flags"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "do_loop_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "687-719",
          "snippet": "static ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tssize_t ret = 0;\n\n\tif (flags & ~RWF_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec = iov_iter_iovec(iter);\n\t\tssize_t nr;\n\n\t\tif (type == READ) {\n\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tssize_t ret = 0;\n\n\tif (flags & ~RWF_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec = iov_iter_iovec(iter);\n\t\tssize_t nr;\n\n\t\tif (type == READ) {\n\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_iter_readv_writev",
          "args": [
            "file",
            "iter",
            "pos",
            "READ",
            "flags"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "do_iter_readv_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "665-684",
          "snippet": "static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tret = kiocb_set_rw_flags(&kiocb, flags);\n\tif (ret)\n\t\treturn ret;\n\tkiocb.ki_pos = *ppos;\n\n\tif (type == READ)\n\t\tret = call_read_iter(filp, &kiocb, iter);\n\telse\n\t\tret = call_write_iter(filp, &kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tret = kiocb_set_rw_flags(&kiocb, flags);\n\tif (ret)\n\t\treturn ret;\n\tkiocb.ki_pos = *ppos;\n\n\tif (type == READ)\n\t\tret = call_read_iter(filp, &kiocb, iter);\n\telse\n\t\tret = call_write_iter(filp, &kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "READ",
            "file",
            "pos",
            "tot_len"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_read(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\tsize_t tot_len;\n\tssize_t ret = 0;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\ttot_len = iov_iter_count(iter);\n\tif (!tot_len)\n\t\tgoto out;\n\tret = rw_verify_area(READ, file, pos, tot_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_op->read_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, READ, flags);\n\telse\n\t\tret = do_loop_readv_writev(file, iter, pos, READ, flags);\nout:\n\tif (ret >= 0)\n\t\tfsnotify_access(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_rw_copy_check_uvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "829-900",
    "snippet": "ssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc_array(nr_segs, sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "buf"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "vrfy_dir(type)",
            "compat_ptr(buf)",
            "len"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "buf"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vrfy_dir",
          "args": [
            "type"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "buf",
            "&uvector->iov_base"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "len",
            "&uvector->iov_len"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "uvector",
            "nr_segs*sizeof(*uvector)"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_segs",
            "sizeof(struct iovec)",
            "GFP_KERNEL"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc_array(nr_segs, sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "rw_copy_check_uvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "753-826",
    "snippet": "ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\n\tunsigned long seg;\n\tssize_t ret;\n\tstruct iovec *iov = fast_pointer;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First get the \"struct iovec\" from user memory and\n\t * verify all the pointers\n\t */\n\tif (nr_segs > UIO_MAXIOV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (nr_segs > fast_segs) {\n\t\tiov = kmalloc_array(nr_segs, sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * According to the Single Unix Specification we should return EINVAL\n\t * if an element length is < 0 when cast to ssize_t or if the\n\t * total length would overflow the ssize_t return value of the\n\t * system call.\n\t *\n\t * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the\n\t * overflow case.\n\t */\n\tret = 0;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tvoid __user *buf = iov[seg].iov_base;\n\t\tssize_t len = (ssize_t)iov[seg].iov_len;\n\n\t\t/* see if we we're about to use an invalid len or if\n\t\t * it's about to overflow ssize_t */\n\t\tif (len < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (type >= 0\n\t\t    && unlikely(!access_ok(vrfy_dir(type), buf, len))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - ret) {\n\t\t\tlen = MAX_RW_COUNT - ret;\n\t\t\tiov[seg].iov_len = len;\n\t\t}\n\t\tret += len;\n\t}\nout:\n\t*ret_pointer = iov;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(vrfy_dir(type), buf, len)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "vrfy_dir(type)",
            "buf",
            "len"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vrfy_dir",
          "args": [
            "type"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "iov",
            "uvector",
            "nr_segs*sizeof(*uvector)"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_segs",
            "sizeof(struct iovec)",
            "GFP_KERNEL"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\n\tunsigned long seg;\n\tssize_t ret;\n\tstruct iovec *iov = fast_pointer;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First get the \"struct iovec\" from user memory and\n\t * verify all the pointers\n\t */\n\tif (nr_segs > UIO_MAXIOV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (nr_segs > fast_segs) {\n\t\tiov = kmalloc_array(nr_segs, sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * According to the Single Unix Specification we should return EINVAL\n\t * if an element length is < 0 when cast to ssize_t or if the\n\t * total length would overflow the ssize_t return value of the\n\t * system call.\n\t *\n\t * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the\n\t * overflow case.\n\t */\n\tret = 0;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tvoid __user *buf = iov[seg].iov_base;\n\t\tssize_t len = (ssize_t)iov[seg].iov_len;\n\n\t\t/* see if we we're about to use an invalid len or if\n\t\t * it's about to overflow ssize_t */\n\t\tif (len < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (type >= 0\n\t\t    && unlikely(!access_ok(vrfy_dir(type), buf, len))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - ret) {\n\t\t\tlen = MAX_RW_COUNT - ret;\n\t\t\tiov[seg].iov_len = len;\n\t\t}\n\t\tret += len;\n\t}\nout:\n\t*ret_pointer = iov;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_loop_readv_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "687-719",
    "snippet": "static ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tssize_t ret = 0;\n\n\tif (flags & ~RWF_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec = iov_iter_iovec(iter);\n\t\tssize_t nr;\n\n\t\tif (type == READ) {\n\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "iter",
            "nr"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp->f_op->write",
          "args": [
            "filp",
            "iovec.iov_base",
            "iovec.iov_len",
            "ppos"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp->f_op->read",
          "args": [
            "filp",
            "iovec.iov_base",
            "iovec.iov_len",
            "ppos"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_iovec",
          "args": [
            "iter"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tssize_t ret = 0;\n\n\tif (flags & ~RWF_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec = iov_iter_iovec(iter);\n\t\tssize_t nr;\n\n\t\tif (type == READ) {\n\t\t\tnr = filp->f_op->read(filp, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, ppos);\n\t\t} else {\n\t\t\tnr = filp->f_op->write(filp, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, ppos);\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_iter_readv_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "665-684",
    "snippet": "static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tret = kiocb_set_rw_flags(&kiocb, flags);\n\tif (ret)\n\t\treturn ret;\n\tkiocb.ki_pos = *ppos;\n\n\tif (type == READ)\n\t\tret = call_read_iter(filp, &kiocb, iter);\n\telse\n\t\tret = call_write_iter(filp, &kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EIOCBQUEUED"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_write_iter",
          "args": [
            "filp",
            "&kiocb",
            "iter"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_read_iter",
          "args": [
            "filp",
            "&kiocb",
            "iter"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kiocb_set_rw_flags",
          "args": [
            "&kiocb",
            "flags"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, int type, rwf_t flags)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tret = kiocb_set_rw_flags(&kiocb, flags);\n\tif (ret)\n\t\treturn ret;\n\tkiocb.ki_pos = *ppos;\n\n\tif (type == READ)\n\t\tret = call_read_iter(filp, &kiocb, iter);\n\telse\n\t\tret = call_write_iter(filp, &kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "ksys_pwrite64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "639-657",
    "snippet": "ssize_t ksys_pwrite64(unsigned int fd, const char __user *buf,\n\t\t      size_t count, loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PWRITE)  \n\t\t\tret = vfs_write(f.file, buf, count, &pos);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_write",
          "args": [
            "f.file",
            "buf",
            "count",
            "&pos"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "533-559",
          "snippet": "ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t ksys_pwrite64(unsigned int fd, const char __user *buf,\n\t\t      size_t count, loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PWRITE)  \n\t\t\tret = vfs_write(f.file, buf, count, &pos);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ksys_pread64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "613-631",
    "snippet": "ssize_t ksys_pread64(unsigned int fd, char __user *buf, size_t count,\n\t\t     loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PREAD)\n\t\t\tret = vfs_read(f.file, buf, count, &pos);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_read",
          "args": [
            "f.file",
            "buf",
            "count",
            "&pos"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "437-461",
          "snippet": "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t ksys_pread64(unsigned int fd, char __user *buf, size_t count,\n\t\t     loff_t pos)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PREAD)\n\t\t\tret = vfs_read(f.file, buf, count, &pos);\n\t\tfdput(f);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ksys_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "591-605",
    "snippet": "ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_write(f.file, buf, count, &pos);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_pos_write",
          "args": [
            "f.file",
            "pos"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "566-569",
          "snippet": "static inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_write",
          "args": [
            "f.file",
            "buf",
            "count",
            "&pos"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "533-559",
          "snippet": "ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_pos_read",
          "args": [
            "f.file"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "561-564",
          "snippet": "static inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_write(f.file, buf, count, &pos);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ksys_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "571-584",
    "snippet": "ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_read(f.file, buf, count, &pos);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_pos_write",
          "args": [
            "f.file",
            "pos"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "566-569",
          "snippet": "static inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_read",
          "args": [
            "f.file",
            "buf",
            "count",
            "&pos"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "437-461",
          "snippet": "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_pos_read",
          "args": [
            "f.file"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "file_pos_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "561-564",
          "snippet": "static inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos = file_pos_read(f.file);\n\t\tret = vfs_read(f.file, buf, count, &pos);\n\t\tif (ret >= 0)\n\t\t\tfile_pos_write(f.file, pos);\n\t\tfdput_pos(f);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "file_pos_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "566-569",
    "snippet": "static inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void file_pos_write(struct file *file, loff_t pos)\n{\n\tfile->f_pos = pos;\n}"
  },
  {
    "function_name": "file_pos_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "561-564",
    "snippet": "static inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline loff_t file_pos_read(struct file *file)\n{\n\treturn file->f_pos;\n}"
  },
  {
    "function_name": "vfs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "533-559",
    "snippet": "ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_write",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "481-490",
          "snippet": "ssize_t __vfs_write(struct file *file, const char __user *p, size_t count,\n\t\t    loff_t *pos)\n{\n\tif (file->f_op->write)\n\t\treturn file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->write_iter)\n\t\treturn new_sync_write(file, p, count, pos);\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __vfs_write(struct file *file, const char __user *p, size_t count,\n\t\t    loff_t *pos)\n{\n\tif (file->f_op->write)\n\t\treturn file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->write_iter)\n\t\treturn new_sync_write(file, p, count, pos);\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "file"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "file",
            "pos",
            "count"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_READ, buf, count)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "buf",
            "count"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kernel_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "517-530",
    "snippet": "ssize_t kernel_write(struct file *file, const void *buf, size_t count,\n\t\t\t    loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_write(file, (__force const char __user *)buf, count, pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_write",
          "args": [
            "file",
            "(__force const char __user *)buf",
            "count",
            "pos"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "533-559",
          "snippet": "ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(WRITE, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tfile_start_write(file);\n\t\tret = __vfs_write(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_modify(file);\n\t\t\tadd_wchar(current, ret);\n\t\t}\n\t\tinc_syscw(current);\n\t\tfile_end_write(file);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t kernel_write(struct file *file, const void *buf, size_t count,\n\t\t\t    loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_write(file, (__force const char __user *)buf, count, pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
  },
  {
    "function_name": "__kernel_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "492-514",
    "snippet": "ssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tret = __vfs_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscw",
          "args": [
            "current"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_modify",
          "args": [
            "file"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vfs_write",
          "args": [
            "file",
            "p",
            "count",
            "pos"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "481-490",
          "snippet": "ssize_t __vfs_write(struct file *file, const char __user *p, size_t count,\n\t\t    loff_t *pos)\n{\n\tif (file->f_op->write)\n\t\treturn file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->write_iter)\n\t\treturn new_sync_write(file, p, count, pos);\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __vfs_write(struct file *file, const char __user *p, size_t count,\n\t\t    loff_t *pos)\n{\n\tif (file->f_op->write)\n\t\treturn file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->write_iter)\n\t\treturn new_sync_write(file, p, count, pos);\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tret = __vfs_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}"
  },
  {
    "function_name": "__vfs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "481-490",
    "snippet": "ssize_t __vfs_write(struct file *file, const char __user *p, size_t count,\n\t\t    loff_t *pos)\n{\n\tif (file->f_op->write)\n\t\treturn file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->write_iter)\n\t\treturn new_sync_write(file, p, count, pos);\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_sync_write",
          "args": [
            "file",
            "p",
            "count",
            "pos"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "463-479",
          "snippet": "static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = call_write_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = call_write_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->write",
          "args": [
            "file",
            "p",
            "count",
            "pos"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __vfs_write(struct file *file, const char __user *p, size_t count,\n\t\t    loff_t *pos)\n{\n\tif (file->f_op->write)\n\t\treturn file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->write_iter)\n\t\treturn new_sync_write(file, p, count, pos);\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "new_sync_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "463-479",
    "snippet": "static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = call_write_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EIOCBQUEUED"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_write_iter",
          "args": [
            "filp",
            "&kiocb",
            "&iter"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&iter",
            "WRITE",
            "&iov",
            "1",
            "len"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\n\tret = call_write_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "437-461",
    "snippet": "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_syscr",
          "args": [
            "current"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rchar",
          "args": [
            "current",
            "ret"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_access",
          "args": [
            "file"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_read",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "412-421",
          "snippet": "ssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tif (file->f_op->read)\n\t\treturn file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\treturn new_sync_read(file, buf, count, pos);\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tif (file->f_op->read)\n\t\treturn file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\treturn new_sync_read(file, buf, count, pos);\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "READ",
            "file",
            "pos",
            "count"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_WRITE, buf, count)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "buf",
            "count"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kernel_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "423-434",
    "snippet": "ssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tssize_t result;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tresult = vfs_read(file, (void __user *)buf, count, pos);\n\tset_fs(old_fs);\n\treturn result;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_read",
          "args": [
            "file",
            "(void __user *)buf",
            "count",
            "pos"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "437-461",
          "snippet": "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_WRITE, buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (!ret) {\n\t\tif (count > MAX_RW_COUNT)\n\t\t\tcount =  MAX_RW_COUNT;\n\t\tret = __vfs_read(file, buf, count, pos);\n\t\tif (ret > 0) {\n\t\t\tfsnotify_access(file);\n\t\t\tadd_rchar(current, ret);\n\t\t}\n\t\tinc_syscr(current);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tssize_t result;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tresult = vfs_read(file, (void __user *)buf, count, pos);\n\tset_fs(old_fs);\n\treturn result;\n}"
  },
  {
    "function_name": "__vfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "412-421",
    "snippet": "ssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tif (file->f_op->read)\n\t\treturn file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\treturn new_sync_read(file, buf, count, pos);\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_sync_read",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "new_sync_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "395-410",
          "snippet": "static ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = call_read_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = call_read_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->read",
          "args": [
            "file",
            "buf",
            "count",
            "pos"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __vfs_read(struct file *file, char __user *buf, size_t count,\n\t\t   loff_t *pos)\n{\n\tif (file->f_op->read)\n\t\treturn file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\treturn new_sync_read(file, buf, count, pos);\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "new_sync_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "395-410",
    "snippet": "static ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = call_read_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EIOCBQUEUED"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_read_iter",
          "args": [
            "filp",
            "&kiocb",
            "&iter"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&iter",
            "READ",
            "&iov",
            "1",
            "len"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "filp"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = call_read_iter(filp, &kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
  },
  {
    "function_name": "rw_verify_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "365-393",
    "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_file_permission",
          "args": [
            "file",
            "read_write == READ ? MAY_READ : MAY_WRITE"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_mandatory_area",
          "args": [
            "inode",
            "file",
            "pos",
            "pos + count - 1",
            "read_write == READ ? F_RDLCK : F_WRLCK"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1295-1342",
          "snippet": "int locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,\n\t\t\t loff_t end, unsigned char type)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = type;\n\tfl.fl_start = start;\n\tfl.fl_end = end;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,\n\t\t\t loff_t end, unsigned char type)\n{\n\tstruct file_lock fl;\n\tint error;\n\tbool sleep = false;\n\n\tlocks_init_lock(&fl);\n\tfl.fl_pid = current->tgid;\n\tfl.fl_file = filp;\n\tfl.fl_flags = FL_POSIX | FL_ACCESS;\n\tif (filp && !(filp->f_flags & O_NONBLOCK))\n\t\tsleep = true;\n\tfl.fl_type = type;\n\tfl.fl_start = start;\n\tfl.fl_end = end;\n\n\tfor (;;) {\n\t\tif (filp) {\n\t\t\tfl.fl_owner = filp;\n\t\t\tfl.fl_flags &= ~FL_SLEEP;\n\t\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sleep)\n\t\t\tfl.fl_flags |= FL_SLEEP;\n\t\tfl.fl_owner = current->files;\n\t\terror = posix_lock_inode(inode, &fl, NULL);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * If we've been sleeping someone might have\n\t\t\t * changed the permissions behind our back.\n\t\t\t */\n\t\t\tif (__mandatory_lock(inode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlocks_delete_block(&fl);\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_flctx && mandatory_lock(inode)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "locks_mandatory_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "1258-1283",
          "snippet": "int locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint locks_mandatory_locked(struct file *file)\n{\n\tint ret;\n\tstruct inode *inode = locks_inode(file);\n\tstruct file_lock_context *ctx;\n\tstruct file_lock *fl;\n\n\tctx = smp_load_acquire(&inode->i_flctx);\n\tif (!ctx || list_empty_careful(&ctx->flc_posix))\n\t\treturn 0;\n\n\t/*\n\t * Search the lock list for this inode for any POSIX locks.\n\t */\n\tspin_lock(&ctx->flc_lock);\n\tret = 0;\n\tlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\n\t\tif (fl->fl_owner != current->files &&\n\t\t    fl->fl_owner != file) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unsigned_offsets",
          "args": [
            "file"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "37-40",
          "snippet": "static inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(loff_t) (pos + count) < 0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pos + count"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pos < 0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ssize_t) count < 0"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
  },
  {
    "function_name": "ksys_lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "304-320",
    "snippet": "off_t ksys_lseek(unsigned int fd, off_t offset, unsigned int whence)\n{\n\toff_t retval;\n\tstruct fd f = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tretval = -EINVAL;\n\tif (whence <= SEEK_MAX) {\n\t\tloff_t res = vfs_llseek(f.file, offset, whence);\n\t\tretval = res;\n\t\tif (res != (loff_t)retval)\n\t\t\tretval = -EOVERFLOW;\t/* LFS: should only happen on 32 bit platforms */\n\t}\n\tfdput_pos(f);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput_pos",
          "args": [
            "f"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_llseek",
          "args": [
            "f.file",
            "offset",
            "whence"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "291-301",
          "snippet": "loff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget_pos",
          "args": [
            "fd"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\noff_t ksys_lseek(unsigned int fd, off_t offset, unsigned int whence)\n{\n\toff_t retval;\n\tstruct fd f = fdget_pos(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tretval = -EINVAL;\n\tif (whence <= SEEK_MAX) {\n\t\tloff_t res = vfs_llseek(f.file, offset, whence);\n\t\tretval = res;\n\t\tif (res != (loff_t)retval)\n\t\t\tretval = -EOVERFLOW;\t/* LFS: should only happen on 32 bit platforms */\n\t}\n\tfdput_pos(f);\n\treturn retval;\n}"
  },
  {
    "function_name": "vfs_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "291-301",
    "snippet": "loff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "dax_insert_pfn_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dax.c",
          "lines": "1629-1664",
          "snippet": "static vm_fault_t\ndax_insert_pfn_mkwrite(struct vm_fault *vmf, pfn_t pfn, unsigned int order)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, order);\n\tvoid *entry;\n\tvm_fault_t ret;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\t/* Did we race with someone splitting entry or so? */\n\tif (!entry ||\n\t    (order == 0 && !dax_is_pte_entry(entry)) ||\n\t    (order == PMD_ORDER && !dax_is_pmd_entry(entry))) {\n\t\tput_unlocked_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\ttrace_dax_insert_pfn_mkwrite_no_entry(mapping->host, vmf,\n\t\t\t\t\t\t      VM_FAULT_NOPAGE);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\txas_set_mark(&xas, PAGECACHE_TAG_DIRTY);\n\tdax_lock_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\tif (order == 0)\n\t\tret = vmf_insert_mixed_mkwrite(vmf->vma, vmf->address, pfn);\n#ifdef CONFIG_FS_DAX_PMD\n\telse if (order == PMD_ORDER)\n\t\tret = vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd,\n\t\t\tpfn, true);\n#endif\n\telse\n\t\tret = VM_FAULT_FALLBACK;\n\tdax_unlock_entry(&xas, entry);\n\ttrace_dax_insert_pfn_mkwrite(mapping->host, vmf, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/fs_dax.h>",
            "#include \"internal.h\"",
            "#include <linux/iomap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sizes.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/fs_dax.h>\n#include \"internal.h\"\n#include <linux/iomap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sizes.h>\n#include <linux/pfn_t.h>\n#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\n#define PMD_ORDER\t(PMD_SHIFT - PAGE_SHIFT)\n\nstatic vm_fault_t\ndax_insert_pfn_mkwrite(struct vm_fault *vmf, pfn_t pfn, unsigned int order)\n{\n\tstruct address_space *mapping = vmf->vma->vm_file->f_mapping;\n\tXA_STATE_ORDER(xas, &mapping->i_pages, vmf->pgoff, order);\n\tvoid *entry;\n\tvm_fault_t ret;\n\n\txas_lock_irq(&xas);\n\tentry = get_unlocked_entry(&xas);\n\t/* Did we race with someone splitting entry or so? */\n\tif (!entry ||\n\t    (order == 0 && !dax_is_pte_entry(entry)) ||\n\t    (order == PMD_ORDER && !dax_is_pmd_entry(entry))) {\n\t\tput_unlocked_entry(&xas, entry);\n\t\txas_unlock_irq(&xas);\n\t\ttrace_dax_insert_pfn_mkwrite_no_entry(mapping->host, vmf,\n\t\t\t\t\t\t      VM_FAULT_NOPAGE);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\txas_set_mark(&xas, PAGECACHE_TAG_DIRTY);\n\tdax_lock_entry(&xas, entry);\n\txas_unlock_irq(&xas);\n\tif (order == 0)\n\t\tret = vmf_insert_mixed_mkwrite(vmf->vma, vmf->address, pfn);\n#ifdef CONFIG_FS_DAX_PMD\n\telse if (order == PMD_ORDER)\n\t\tret = vmf_insert_pfn_pmd(vmf->vma, vmf->address, vmf->pmd,\n\t\t\tpfn, true);\n#endif\n\telse\n\t\tret = VM_FAULT_FALLBACK;\n\tdax_unlock_entry(&xas, entry);\n\ttrace_dax_insert_pfn_mkwrite(mapping->host, vmf, ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}"
  },
  {
    "function_name": "default_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "236-288",
    "snippet": "loff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tinode_lock(inode);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tinode_unlock(inode);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unsigned_offsets",
          "args": [
            "file"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "37-40",
          "snippet": "static inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\n\tinode_lock(inode);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\t/*\n\t\t\t * In the generic case the entire file is data, so as\n\t\t\t * long as offset isn't at the end of the file then the\n\t\t\t * offset is data.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\t/*\n\t\t\t * There is a virtual hole at the end of the file, so\n\t\t\t * as long as offset isn't i_size or larger, return\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tinode_unlock(inode);\n\treturn retval;\n}"
  },
  {
    "function_name": "no_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "230-233",
    "snippet": "loff_t no_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn -ESPIPE;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t no_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn -ESPIPE;\n}"
  },
  {
    "function_name": "noop_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "224-227",
    "snippet": "loff_t noop_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn file->f_pos;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t noop_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn file->f_pos;\n}"
  },
  {
    "function_name": "no_seek_end_llseek_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "201-210",
    "snippet": "loff_t no_seek_end_llseek_size(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "size",
            "0"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "85-131",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t no_seek_end_llseek_size(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "no_seek_end_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "181-190",
    "snippet": "loff_t no_seek_end_llseek(struct file *file, loff_t offset, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tOFFSET_MAX, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "OFFSET_MAX",
            "0"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "85-131",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t no_seek_end_llseek(struct file *file, loff_t offset, int whence)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tOFFSET_MAX, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "fixed_size_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "162-171",
    "snippet": "loff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "size",
            "size"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "85-131",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "generic_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "144-151",
    "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "inode->i_sb->s_maxbytes",
            "i_size_read(inode)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "85-131",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
  },
  {
    "function_name": "generic_file_llseek_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "85-131",
    "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "offset",
            "maxsize"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "54-66",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif ((unsigned long long)offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
  },
  {
    "function_name": "vfs_setpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "54-66",
    "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unsigned_offsets",
          "args": [
            "file"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "37-40",
          "snippet": "static inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
  },
  {
    "function_name": "unsigned_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "37-40",
    "snippet": "static inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline bool unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
  },
  {
    "function_name": "lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "322-325",
    "snippet": "SYSCALL_DEFINE3(lseek, unsigned int, fd, off_t, offset, unsigned int, whence)\n{\n\treturn ksys_lseek(fd, offset, whence);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(lseek, unsigned int, fd, off_t, offset, unsigned int, whence)\n{\n\treturn ksys_lseek(fd, offset, whence);\n}"
  },
  {
    "function_name": "lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "328-331",
    "snippet": "SYSCALL_DEFINE3(lseek, unsigned int, fd, compat_off_t, offset, unsigned int, whence)\n{\n\treturn ksys_lseek(fd, offset, whence);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(lseek, unsigned int, fd, compat_off_t, offset, unsigned int, whence)\n{\n\treturn ksys_lseek(fd, offset, whence);\n}"
  },
  {
    "function_name": "llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "335-362",
    "snippet": "SYSCALL_DEFINE5(llseek, unsigned int, fd, unsigned long, offset_high,\n\t\tunsigned long, offset_low, loff_t __user *, result,\n\t\tunsigned int, whence)\n{\n\tint retval;\n\tstruct fd f = fdget_pos(fd);\n\tloff_t offset;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tretval = -EINVAL;\n\tif (whence > SEEK_MAX)\n\t\tgoto out_putf;\n\n\toffset = vfs_llseek(f.file, ((loff_t) offset_high << 32) | offset_low,\n\t\t\twhence);\n\n\tretval = (int)offset;\n\tif (offset >= 0) {\n\t\tretval = -EFAULT;\n\t\tif (!copy_to_user(result, &offset, sizeof(offset)))\n\t\t\tretval = 0;\n\t}\nout_putf:\n\tfdput_pos(f);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(llseek, unsigned int, fd, unsigned long, offset_high,\n\t\tunsigned long, offset_low, loff_t __user *, result,\n\t\tunsigned int, whence)\n{\n\tint retval;\n\tstruct fd f = fdget_pos(fd);\n\tloff_t offset;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tretval = -EINVAL;\n\tif (whence > SEEK_MAX)\n\t\tgoto out_putf;\n\n\toffset = vfs_llseek(f.file, ((loff_t) offset_high << 32) | offset_low,\n\t\t\twhence);\n\n\tretval = (int)offset;\n\tif (offset >= 0) {\n\t\tretval = -EFAULT;\n\t\tif (!copy_to_user(result, &offset, sizeof(offset)))\n\t\t\tretval = 0;\n\t}\nout_putf:\n\tfdput_pos(f);\n\treturn retval;\n}"
  },
  {
    "function_name": "read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "586-589",
    "snippet": "SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)\n{\n\treturn ksys_read(fd, buf, count);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)\n{\n\treturn ksys_read(fd, buf, count);\n}"
  },
  {
    "function_name": "write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "607-611",
    "snippet": "SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,\n\t\tsize_t, count)\n{\n\treturn ksys_write(fd, buf, count);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,\n\t\tsize_t, count)\n{\n\treturn ksys_write(fd, buf, count);\n}"
  },
  {
    "function_name": "pread64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "633-637",
    "snippet": "SYSCALL_DEFINE4(pread64, unsigned int, fd, char __user *, buf,\n\t\t\tsize_t, count, loff_t, pos)\n{\n\treturn ksys_pread64(fd, buf, count, pos);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(pread64, unsigned int, fd, char __user *, buf,\n\t\t\tsize_t, count, loff_t, pos)\n{\n\treturn ksys_pread64(fd, buf, count, pos);\n}"
  },
  {
    "function_name": "pwrite64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "659-663",
    "snippet": "SYSCALL_DEFINE4(pwrite64, unsigned int, fd, const char __user *, buf,\n\t\t\t size_t, count, loff_t, pos)\n{\n\treturn ksys_pwrite64(fd, buf, count, pos);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(pwrite64, unsigned int, fd, const char __user *, buf,\n\t\t\t size_t, count, loff_t, pos)\n{\n\treturn ksys_pwrite64(fd, buf, count, pos);\n}"
  },
  {
    "function_name": "readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1103-1107",
    "snippet": "SYSCALL_DEFINE3(readv, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen)\n{\n\treturn do_readv(fd, vec, vlen, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(readv, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen)\n{\n\treturn do_readv(fd, vec, vlen, 0);\n}"
  },
  {
    "function_name": "writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1109-1113",
    "snippet": "SYSCALL_DEFINE3(writev, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen)\n{\n\treturn do_writev(fd, vec, vlen, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(writev, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen)\n{\n\treturn do_writev(fd, vec, vlen, 0);\n}"
  },
  {
    "function_name": "preadv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1115-1121",
    "snippet": "SYSCALL_DEFINE5(preadv, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\treturn do_preadv(fd, vec, vlen, pos, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(preadv, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\treturn do_preadv(fd, vec, vlen, pos, 0);\n}"
  },
  {
    "function_name": "preadv2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1123-1133",
    "snippet": "SYSCALL_DEFINE6(preadv2, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h,\n\t\trwf_t, flags)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\tif (pos == -1)\n\t\treturn do_readv(fd, vec, vlen, flags);\n\n\treturn do_preadv(fd, vec, vlen, pos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE6(preadv2, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h,\n\t\trwf_t, flags)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\tif (pos == -1)\n\t\treturn do_readv(fd, vec, vlen, flags);\n\n\treturn do_preadv(fd, vec, vlen, pos, flags);\n}"
  },
  {
    "function_name": "pwritev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1135-1141",
    "snippet": "SYSCALL_DEFINE5(pwritev, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\treturn do_pwritev(fd, vec, vlen, pos, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(pwritev, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\treturn do_pwritev(fd, vec, vlen, pos, 0);\n}"
  },
  {
    "function_name": "pwritev2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1143-1153",
    "snippet": "SYSCALL_DEFINE6(pwritev2, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h,\n\t\trwf_t, flags)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\tif (pos == -1)\n\t\treturn do_writev(fd, vec, vlen, flags);\n\n\treturn do_pwritev(fd, vec, vlen, pos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE6(pwritev2, unsigned long, fd, const struct iovec __user *, vec,\n\t\tunsigned long, vlen, unsigned long, pos_l, unsigned long, pos_h,\n\t\trwf_t, flags)\n{\n\tloff_t pos = pos_from_hilo(pos_h, pos_l);\n\n\tif (pos == -1)\n\t\treturn do_writev(fd, vec, vlen, flags);\n\n\treturn do_pwritev(fd, vec, vlen, pos, flags);\n}"
  },
  {
    "function_name": "readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1195-1200",
    "snippet": "SYSCALL_DEFINE3(readv, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen)\n{\n\treturn do_compat_readv(fd, vec, vlen, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(readv, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen)\n{\n\treturn do_compat_readv(fd, vec, vlen, 0);\n}"
  },
  {
    "function_name": "preadv64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1222-1227",
    "snippet": "SYSCALL_DEFINE4(preadv64, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos)\n{\n\treturn do_compat_preadv64(fd, vec, vlen, pos, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(preadv64, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos)\n{\n\treturn do_compat_preadv64(fd, vec, vlen, pos, 0);\n}"
  },
  {
    "function_name": "preadv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1230-1237",
    "snippet": "SYSCALL_DEFINE5(preadv, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\treturn do_compat_preadv64(fd, vec, vlen, pos, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(preadv, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\treturn do_compat_preadv64(fd, vec, vlen, pos, 0);\n}"
  },
  {
    "function_name": "preadv64v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1240-1245",
    "snippet": "SYSCALL_DEFINE5(preadv64v2, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos, rwf_t, flags)\n{\n\treturn do_compat_preadv64(fd, vec, vlen, pos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(preadv64v2, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos, rwf_t, flags)\n{\n\treturn do_compat_preadv64(fd, vec, vlen, pos, flags);\n}"
  },
  {
    "function_name": "preadv2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1248-1259",
    "snippet": "SYSCALL_DEFINE6(preadv2, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high,\n\t\trwf_t, flags)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\tif (pos == -1)\n\t\treturn do_compat_readv(fd, vec, vlen, flags);\n\n\treturn do_compat_preadv64(fd, vec, vlen, pos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE6(preadv2, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high,\n\t\trwf_t, flags)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\tif (pos == -1)\n\t\treturn do_compat_readv(fd, vec, vlen, flags);\n\n\treturn do_compat_preadv64(fd, vec, vlen, pos, flags);\n}"
  },
  {
    "function_name": "writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1301-1306",
    "snippet": "SYSCALL_DEFINE3(writev, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *, vec,\n\t\tcompat_ulong_t, vlen)\n{\n\treturn do_compat_writev(fd, vec, vlen, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(writev, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *, vec,\n\t\tcompat_ulong_t, vlen)\n{\n\treturn do_compat_writev(fd, vec, vlen, 0);\n}"
  },
  {
    "function_name": "pwritev64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1328-1333",
    "snippet": "SYSCALL_DEFINE4(pwritev64, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos)\n{\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(pwritev64, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos)\n{\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, 0);\n}"
  },
  {
    "function_name": "pwritev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1336-1343",
    "snippet": "SYSCALL_DEFINE5(pwritev, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(pwritev, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, 0);\n}"
  },
  {
    "function_name": "pwritev64v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1346-1351",
    "snippet": "SYSCALL_DEFINE5(pwritev64v2, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos, rwf_t, flags)\n{\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE5(pwritev64v2, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos, rwf_t, flags)\n{\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, flags);\n}"
  },
  {
    "function_name": "pwritev2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1354-1364",
    "snippet": "SYSCALL_DEFINE6(pwritev2, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high, rwf_t, flags)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\tif (pos == -1)\n\t\treturn do_compat_writev(fd, vec, vlen, flags);\n\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, flags);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE6(pwritev2, compat_ulong_t, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tcompat_ulong_t, vlen, u32, pos_low, u32, pos_high, rwf_t, flags)\n{\n\tloff_t pos = ((loff_t)pos_high << 32) | pos_low;\n\n\tif (pos == -1)\n\t\treturn do_compat_writev(fd, vec, vlen, flags);\n\n\treturn do_compat_pwritev64(fd, vec, vlen, pos, flags);\n}"
  },
  {
    "function_name": "sendfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1467-1484",
    "snippet": "SYSCALL_DEFINE4(sendfile, int, out_fd, int, in_fd, off_t __user *, offset, size_t, count)\n{\n\tloff_t pos;\n\toff_t off;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(get_user(off, offset)))\n\t\t\treturn -EFAULT;\n\t\tpos = off;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(sendfile, int, out_fd, int, in_fd, off_t __user *, offset, size_t, count)\n{\n\tloff_t pos;\n\toff_t off;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(get_user(off, offset)))\n\t\t\treturn -EFAULT;\n\t\tpos = off;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}"
  },
  {
    "function_name": "sendfile64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1486-1501",
    "snippet": "SYSCALL_DEFINE4(sendfile64, int, out_fd, int, in_fd, loff_t __user *, offset, size_t, count)\n{\n\tloff_t pos;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(copy_from_user(&pos, offset, sizeof(loff_t))))\n\t\t\treturn -EFAULT;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, 0);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(sendfile64, int, out_fd, int, in_fd, loff_t __user *, offset, size_t, count)\n{\n\tloff_t pos;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(copy_from_user(&pos, offset, sizeof(loff_t))))\n\t\t\treturn -EFAULT;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, 0);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}"
  },
  {
    "function_name": "sendfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1504-1522",
    "snippet": "SYSCALL_DEFINE4(sendfile, int, out_fd, int, in_fd,\n\t\tcompat_off_t __user *, offset, compat_size_t, count)\n{\n\tloff_t pos;\n\toff_t off;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(get_user(off, offset)))\n\t\t\treturn -EFAULT;\n\t\tpos = off;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(sendfile, int, out_fd, int, in_fd,\n\t\tcompat_off_t __user *, offset, compat_size_t, count)\n{\n\tloff_t pos;\n\toff_t off;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(get_user(off, offset)))\n\t\t\treturn -EFAULT;\n\t\tpos = off;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}"
  },
  {
    "function_name": "sendfile64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1524-1540",
    "snippet": "SYSCALL_DEFINE4(sendfile64, int, out_fd, int, in_fd,\n\t\tcompat_loff_t __user *, offset, compat_size_t, count)\n{\n\tloff_t pos;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(copy_from_user(&pos, offset, sizeof(loff_t))))\n\t\t\treturn -EFAULT;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, 0);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(sendfile64, int, out_fd, int, in_fd,\n\t\tcompat_loff_t __user *, offset, compat_size_t, count)\n{\n\tloff_t pos;\n\tssize_t ret;\n\n\tif (offset) {\n\t\tif (unlikely(copy_from_user(&pos, offset, sizeof(loff_t))))\n\t\t\treturn -EFAULT;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, 0);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}"
  },
  {
    "function_name": "copy_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
    "lines": "1630-1690",
    "snippet": "SYSCALL_DEFINE6(copy_file_range, int, fd_in, loff_t __user *, off_in,\n\t\tint, fd_out, loff_t __user *, off_out,\n\t\tsize_t, len, unsigned int, flags)\n{\n\tloff_t pos_in;\n\tloff_t pos_out;\n\tstruct fd f_in;\n\tstruct fd f_out;\n\tssize_t ret = -EBADF;\n\n\tf_in = fdget(fd_in);\n\tif (!f_in.file)\n\t\tgoto out2;\n\n\tf_out = fdget(fd_out);\n\tif (!f_out.file)\n\t\tgoto out1;\n\n\tret = -EFAULT;\n\tif (off_in) {\n\t\tif (copy_from_user(&pos_in, off_in, sizeof(loff_t)))\n\t\t\tgoto out;\n\t} else {\n\t\tpos_in = f_in.file->f_pos;\n\t}\n\n\tif (off_out) {\n\t\tif (copy_from_user(&pos_out, off_out, sizeof(loff_t)))\n\t\t\tgoto out;\n\t} else {\n\t\tpos_out = f_out.file->f_pos;\n\t}\n\n\tret = vfs_copy_file_range(f_in.file, pos_in, f_out.file, pos_out, len,\n\t\t\t\t  flags);\n\tif (ret > 0) {\n\t\tpos_in += ret;\n\t\tpos_out += ret;\n\n\t\tif (off_in) {\n\t\t\tif (copy_to_user(off_in, &pos_in, sizeof(loff_t)))\n\t\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tf_in.file->f_pos = pos_in;\n\t\t}\n\n\t\tif (off_out) {\n\t\t\tif (copy_to_user(off_out, &pos_out, sizeof(loff_t)))\n\t\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tf_out.file->f_pos = pos_out;\n\t\t}\n\t}\n\nout:\n\tfdput(f_out);\nout1:\n\tfdput(f_in);\nout2:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include \"internal.h\"",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/uio.h>",
      "#include <linux/file.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/sched/xacct.h>",
      "#include <linux/stat.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE6(copy_file_range, int, fd_in, loff_t __user *, off_in,\n\t\tint, fd_out, loff_t __user *, off_out,\n\t\tsize_t, len, unsigned int, flags)\n{\n\tloff_t pos_in;\n\tloff_t pos_out;\n\tstruct fd f_in;\n\tstruct fd f_out;\n\tssize_t ret = -EBADF;\n\n\tf_in = fdget(fd_in);\n\tif (!f_in.file)\n\t\tgoto out2;\n\n\tf_out = fdget(fd_out);\n\tif (!f_out.file)\n\t\tgoto out1;\n\n\tret = -EFAULT;\n\tif (off_in) {\n\t\tif (copy_from_user(&pos_in, off_in, sizeof(loff_t)))\n\t\t\tgoto out;\n\t} else {\n\t\tpos_in = f_in.file->f_pos;\n\t}\n\n\tif (off_out) {\n\t\tif (copy_from_user(&pos_out, off_out, sizeof(loff_t)))\n\t\t\tgoto out;\n\t} else {\n\t\tpos_out = f_out.file->f_pos;\n\t}\n\n\tret = vfs_copy_file_range(f_in.file, pos_in, f_out.file, pos_out, len,\n\t\t\t\t  flags);\n\tif (ret > 0) {\n\t\tpos_in += ret;\n\t\tpos_out += ret;\n\n\t\tif (off_in) {\n\t\t\tif (copy_to_user(off_in, &pos_in, sizeof(loff_t)))\n\t\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tf_in.file->f_pos = pos_in;\n\t\t}\n\n\t\tif (off_out) {\n\t\t\tif (copy_to_user(off_out, &pos_out, sizeof(loff_t)))\n\t\t\t\tret = -EFAULT;\n\t\t} else {\n\t\t\tf_out.file->f_pos = pos_out;\n\t\t}\n\t}\n\nout:\n\tfdput(f_out);\nout1:\n\tfdput(f_in);\nout2:\n\treturn ret;\n}"
  }
]