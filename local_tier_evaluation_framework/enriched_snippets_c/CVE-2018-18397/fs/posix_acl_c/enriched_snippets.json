[
  {
    "function_name": "simple_acl_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "937-954",
    "snippet": "int simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "62-70",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&inode->i_mode",
            "&default_acl",
            "&acl"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "580-628",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tret = -ENOMEM;\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto err_release;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto err_release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nerr_release_clone:\n\tposix_acl_release(clone);\nerr_release:\n\tposix_acl_release(p);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tret = -ENOMEM;\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto err_release;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto err_release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nerr_release_clone:\n\tposix_acl_release(clone);\nerr_release:\n\tposix_acl_release(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint simple_acl_create(struct inode *dir, struct inode *inode)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn 0;\n}"
  },
  {
    "function_name": "simple_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "921-935",
    "snippet": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_update_mode(inode,\n\t\t\t\t&inode->i_mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "62-70",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_update_mode",
          "args": [
            "inode",
            "&inode->i_mode",
            "&acl"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_update_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "643-659",
          "snippet": "int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_update_mode(inode,\n\t\t\t\t&inode->i_mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_acl_xattr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "897-901",
    "snippet": "static bool\nposix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool\nposix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}"
  },
  {
    "function_name": "posix_acl_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "878-895",
    "snippet": "static int\nposix_acl_xattr_set(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct posix_acl *acl = NULL;\n\tint ret;\n\n\tif (value) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t}\n\tret = set_posix_acl(inode, handler->flags, acl);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_posix_acl",
          "args": [
            "inode",
            "handler->flags",
            "acl"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "set_posix_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "856-875",
          "snippet": "int\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_xattr",
          "args": [
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "723-786",
          "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int\nposix_acl_xattr_set(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, const void *value,\n\t\t    size_t size, int flags)\n{\n\tstruct posix_acl *acl = NULL;\n\tint ret;\n\n\tif (value) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t}\n\tret = set_posix_acl(inode, handler->flags, acl);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
  },
  {
    "function_name": "set_posix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "856-875",
    "snippet": "int\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode->i_op->set_acl",
          "args": [
            "inode",
            "acl",
            "type"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_valid",
          "args": [
            "inode->i_sb->s_user_ns",
            "acl"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "208-270",
          "snippet": "int\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "inode"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn acl ? -EACCES : 0;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (acl) {\n\t\tint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn inode->i_op->set_acl(inode, acl, type);\n}"
  },
  {
    "function_name": "posix_acl_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "831-854",
    "snippet": "static int\nposix_acl_xattr_get(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, void *value, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "acl",
            "value",
            "size"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "792-828",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "inode",
            "handler->flags"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "95-158",
          "snippet": "struct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "inode"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int\nposix_acl_xattr_get(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, void *value, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}"
  },
  {
    "function_name": "posix_acl_to_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "792-828",
    "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ACL_UNDEFINED_ID"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(user_ns, acl_e->e_gid)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "user_ns",
            "acl_e->e_gid"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(user_ns, acl_e->e_uid)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "user_ns",
            "acl_e->e_uid"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl_e->e_perm"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl_e->e_tag"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "POSIX_ACL_XATTR_VERSION"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tstruct posix_acl_xattr_header *ext_acl = buffer;\n\tstruct posix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = (void *)(ext_acl + 1);\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
  },
  {
    "function_name": "posix_acl_from_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "723-786",
    "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "acl_e->e_gid"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_id"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "acl_e->e_uid"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_perm"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "count",
            "GFP_NOFS"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "175-184",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_count",
          "args": [
            "size"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "POSIX_ACL_XATTR_VERSION"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tconst struct posix_acl_xattr_header *header = value;\n\tconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "posix_acl_fix_xattr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "712-718",
    "snippet": "void posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_fix_xattr_userns",
          "args": [
            "user_ns",
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_fix_xattr_userns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "665-702",
          "snippet": "static void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}"
  },
  {
    "function_name": "posix_acl_fix_xattr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "704-710",
    "snippet": "void posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_fix_xattr_userns",
          "args": [
            "&init_user_ns",
            "user_ns",
            "value",
            "size"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_fix_xattr_userns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "665-702",
          "snippet": "static void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}"
  },
  {
    "function_name": "posix_acl_fix_xattr_userns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "665-702",
    "snippet": "static void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(to, gid)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "to",
            "gid"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "from",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_id"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(to, uid)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "to",
            "uid"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "from",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_tag"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_count",
          "args": [
            "size"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "POSIX_ACL_XATTR_VERSION"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "posix_acl_update_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "643-659",
    "snippet": "int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "inode",
            "CAP_FSETID"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "*acl",
            "&mode"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "277-317",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_acl_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "580-628",
    "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tret = -ENOMEM;\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto err_release;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto err_release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nerr_release_clone:\n\tposix_acl_release(clone);\nerr_release:\n\tposix_acl_release(p);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "p"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "clone"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "p"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "*mode"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "clone"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create_masq",
          "args": [
            "clone",
            "mode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create_masq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "415-467",
          "snippet": "static int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_clone",
          "args": [
            "p",
            "GFP_NOFS"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "190-203",
          "snippet": "static struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs_struct.c",
          "lines": "155-158",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "dir",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "95-158",
          "snippet": "struct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "dir"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "*mode"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tstruct posix_acl *clone;\n\tint ret;\n\n\t*acl = NULL;\n\t*default_acl = NULL;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\treturn 0;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\n\t\t*mode &= ~current_umask();\n\t\treturn 0;\n\t}\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tret = -ENOMEM;\n\tclone = posix_acl_clone(p, GFP_NOFS);\n\tif (!clone)\n\t\tgoto err_release;\n\n\tret = posix_acl_create_masq(clone, mode);\n\tif (ret < 0)\n\t\tgoto err_release_clone;\n\n\tif (ret == 0)\n\t\tposix_acl_release(clone);\n\telse\n\t\t*acl = clone;\n\n\tif (!S_ISDIR(*mode))\n\t\tposix_acl_release(p);\n\telse\n\t\t*default_acl = p;\n\n\treturn 0;\n\nerr_release_clone:\n\tposix_acl_release(clone);\nerr_release:\n\tposix_acl_release(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "posix_acl_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "553-577",
    "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->set_acl",
          "args": [
            "inode",
            "acl",
            "ACL_TYPE_ACCESS"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__posix_acl_chmod",
          "args": [
            "&acl",
            "GFP_KERNEL",
            "mode"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "535-550",
          "snippet": "int\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "acl"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "95-158",
          "snippet": "struct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "inode"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
  },
  {
    "function_name": "__posix_acl_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "535-550",
    "snippet": "int\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "*acl"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "clone"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__posix_acl_chmod_masq",
          "args": [
            "clone",
            "mode"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__posix_acl_chmod_masq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "472-515",
          "snippet": "static int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_clone",
          "args": [
            "*acl",
            "gfp"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "190-203",
          "snippet": "static struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = __posix_acl_chmod_masq(clone, mode);\n\t\tif (err) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}"
  },
  {
    "function_name": "__posix_acl_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "517-532",
    "snippet": "int\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "*acl"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "clone"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create_masq",
          "args": [
            "clone",
            "mode_p"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create_masq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "415-467",
          "snippet": "static int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_clone",
          "args": [
            "*acl",
            "gfp"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "190-203",
          "snippet": "static struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\n{\n\tstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\n\tint err = -ENOMEM;\n\tif (clone) {\n\t\terr = posix_acl_create_masq(clone, mode_p);\n\t\tif (err < 0) {\n\t\t\tposix_acl_release(clone);\n\t\t\tclone = NULL;\n\t\t}\n\t}\n\tposix_acl_release(*acl);\n\t*acl = clone;\n\treturn err;\n}"
  },
  {
    "function_name": "__posix_acl_chmod_masq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "472-515",
    "snippet": "static int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_acl_create_masq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "415-467",
    "snippet": "static int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\n                        case ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n                                break;\n\n                        case ACL_OTHER:\n\t\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n                                break;\n\n                        case ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tnot_equiv = 1;\n                                break;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
  },
  {
    "function_name": "posix_acl_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "346-405",
    "snippet": "int\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\n{\n\tconst struct posix_acl_entry *pa, *pe, *mask_obj;\n\tint found = 0;\n\n\twant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\t/* (May have been checked already) */\n\t\t\t\tif (uid_eq(inode->i_uid, current_fsuid()))\n                                        goto check_perm;\n                                break;\n                        case ACL_USER:\n\t\t\t\tif (uid_eq(pa->e_uid, current_fsuid()))\n                                        goto mask;\n\t\t\t\tbreak;\n                        case ACL_GROUP_OBJ:\n                                if (in_group_p(inode->i_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n\t\t\t\tbreak;\n                        case ACL_GROUP:\n\t\t\t\tif (in_group_p(pa->e_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n                                break;\n                        case ACL_MASK:\n                                break;\n                        case ACL_OTHER:\n\t\t\t\tif (found)\n\t\t\t\t\treturn -EACCES;\n\t\t\t\telse\n\t\t\t\t\tgoto check_perm;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\treturn -EIO;\n\nmask:\n\tfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n\t\tif (mask_obj->e_tag == ACL_MASK) {\n\t\t\tif ((pa->e_perm & mask_obj->e_perm & want) == want)\n\t\t\t\treturn 0;\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\ncheck_perm:\n\tif ((pa->e_perm & want) == want)\n\t\treturn 0;\n\treturn -EACCES;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "pa->e_gid"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "pa->e_uid",
            "current_fsuid()"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "inode->i_uid",
            "current_fsuid()"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\n{\n\tconst struct posix_acl_entry *pa, *pe, *mask_obj;\n\tint found = 0;\n\n\twant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n                switch(pa->e_tag) {\n                        case ACL_USER_OBJ:\n\t\t\t\t/* (May have been checked already) */\n\t\t\t\tif (uid_eq(inode->i_uid, current_fsuid()))\n                                        goto check_perm;\n                                break;\n                        case ACL_USER:\n\t\t\t\tif (uid_eq(pa->e_uid, current_fsuid()))\n                                        goto mask;\n\t\t\t\tbreak;\n                        case ACL_GROUP_OBJ:\n                                if (in_group_p(inode->i_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n\t\t\t\tbreak;\n                        case ACL_GROUP:\n\t\t\t\tif (in_group_p(pa->e_gid)) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif ((pa->e_perm & want) == want)\n\t\t\t\t\t\tgoto mask;\n                                }\n                                break;\n                        case ACL_MASK:\n                                break;\n                        case ACL_OTHER:\n\t\t\t\tif (found)\n\t\t\t\t\treturn -EACCES;\n\t\t\t\telse\n\t\t\t\t\tgoto check_perm;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n                }\n        }\n\treturn -EIO;\n\nmask:\n\tfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\n\t\tif (mask_obj->e_tag == ACL_MASK) {\n\t\t\tif ((pa->e_perm & mask_obj->e_perm & want) == want)\n\t\t\t\treturn 0;\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\ncheck_perm:\n\tif ((pa->e_perm & want) == want)\n\t\treturn 0;\n\treturn -EACCES;\n}"
  },
  {
    "function_name": "posix_acl_from_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "323-339",
    "snippet": "struct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "3",
            "flags"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "175-184",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}"
  },
  {
    "function_name": "posix_acl_equiv_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "277-317",
    "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
  },
  {
    "function_name": "posix_acl_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "208-270",
    "snippet": "int\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgid_has_mapping",
          "args": [
            "user_ns",
            "pa->e_gid"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "user_ns",
            "pa->e_uid"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tint state = ACL_USER_OBJ;\n\tint needs_mask = 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\n\t\t\treturn -EINVAL;\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tif (state == ACL_USER_OBJ) {\n\t\t\t\t\tstate = ACL_USER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tif (state != ACL_USER)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kuid_has_mapping(user_ns, pa->e_uid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tif (state == ACL_USER) {\n\t\t\t\t\tstate = ACL_GROUP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase ACL_GROUP:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (!kgid_has_mapping(user_ns, pa->e_gid))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tneeds_mask = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tif (state != ACL_GROUP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tstate = ACL_OTHER;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tif (state == ACL_OTHER ||\n\t\t\t\t    (state == ACL_GROUP && !needs_mask)) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (state == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "posix_acl_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "190-203",
    "snippet": "static struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&clone->a_refcount",
            "1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "acl",
            "size",
            "flags"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl *\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t           sizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\trefcount_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}"
  },
  {
    "function_name": "posix_acl_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "175-184",
    "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_init",
          "args": [
            "acl",
            "count"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "164-169",
          "snippet": "void\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\trefcount_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\trefcount_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "flags"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
  },
  {
    "function_name": "posix_acl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "164-169",
    "snippet": "void\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\trefcount_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&acl->a_refcount",
            "1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid\nposix_acl_init(struct posix_acl *acl, int count)\n{\n\trefcount_set(&acl->a_refcount, 1);\n\tacl->a_count = count;\n}"
  },
  {
    "function_name": "get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "95-158",
    "snippet": "struct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cmpxchg(p, sentinel, acl) != sentinel"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "p",
            "sentinel",
            "acl"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_dup",
          "args": [
            "acl"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "p",
            "sentinel",
            "ACL_NOT_CACHED"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->get_acl",
          "args": [
            "inode",
            "type"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "95-158",
          "snippet": "struct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "NULL"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "62-70",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "p",
            "ACL_NOT_CACHED",
            "sentinel"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acl_by_type",
          "args": [
            "inode",
            "type"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "acl_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "25-35",
          "snippet": "static struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uncached_acl_sentinel",
          "args": [
            "current"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "inode"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_uncached_acl",
          "args": [
            "acl"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cached_acl",
          "args": [
            "inode",
            "type"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "forget_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "82-85",
          "snippet": "void forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}"
  },
  {
    "function_name": "forget_all_cached_acls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "88-92",
    "snippet": "void forget_all_cached_acls(struct inode *inode)\n{\n\t__forget_cached_acl(&inode->i_acl);\n\t__forget_cached_acl(&inode->i_default_acl);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__forget_cached_acl",
          "args": [
            "&inode->i_default_acl"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__forget_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "73-80",
          "snippet": "static void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid forget_all_cached_acls(struct inode *inode)\n{\n\t__forget_cached_acl(&inode->i_acl);\n\t__forget_cached_acl(&inode->i_default_acl);\n}"
  },
  {
    "function_name": "forget_cached_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "82-85",
    "snippet": "void forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__forget_cached_acl",
          "args": [
            "acl_by_type(inode, type)"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "__forget_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "73-80",
          "snippet": "static void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "acl_by_type",
          "args": [
            "inode",
            "type"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "acl_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "25-35",
          "snippet": "static struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\t__forget_cached_acl(acl_by_type(inode, type));\n}"
  },
  {
    "function_name": "__forget_cached_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "73-80",
    "snippet": "static void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "old"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_uncached_acl",
          "args": [
            "old"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "p",
            "ACL_NOT_CACHED"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __forget_cached_acl(struct posix_acl **p)\n{\n\tstruct posix_acl *old;\n\n\told = xchg(p, ACL_NOT_CACHED);\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}"
  },
  {
    "function_name": "set_cached_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "62-70",
    "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "old"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_uncached_acl",
          "args": [
            "old"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "p",
            "posix_acl_dup(acl)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_dup",
          "args": [
            "acl"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acl_by_type",
          "args": [
            "inode",
            "type"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "acl_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "25-35",
          "snippet": "static struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}"
  },
  {
    "function_name": "get_cached_acl_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "56-59",
    "snippet": "struct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\treturn rcu_dereference(*acl_by_type(inode, type));\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*acl_by_type(inode, type)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acl_by_type",
          "args": [
            "inode",
            "type"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "acl_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "25-35",
          "snippet": "static struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\n{\n\treturn rcu_dereference(*acl_by_type(inode, type));\n}"
  },
  {
    "function_name": "get_cached_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "37-53",
    "snippet": "struct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    refcount_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc_not_zero",
          "args": [
            "&acl->a_refcount"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_uncached_acl",
          "args": [
            "acl"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*p"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acl_by_type",
          "args": [
            "inode",
            "type"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "acl_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "25-35",
          "snippet": "static struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    refcount_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}"
  },
  {
    "function_name": "acl_by_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
    "lines": "25-35",
    "snippet": "static struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/user_namespace.h>",
      "#include <linux/export.h>",
      "#include <linux/xattr.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct posix_acl **acl_by_type(struct inode *inode, int type)\n{\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\treturn &inode->i_acl;\n\tcase ACL_TYPE_DEFAULT:\n\t\treturn &inode->i_default_acl;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  }
]