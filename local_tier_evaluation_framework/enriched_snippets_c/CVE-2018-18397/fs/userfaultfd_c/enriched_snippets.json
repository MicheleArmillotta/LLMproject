[
  {
    "function_name": "userfaultfd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1933-1941",
    "snippet": "static int __init userfaultfd_init(void)\n{\n\tuserfaultfd_ctx_cachep = kmem_cache_create(\"userfaultfd_ctx_cache\",\n\t\t\t\t\t\tsizeof(struct userfaultfd_ctx),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC,\n\t\t\t\t\t\tinit_once_userfaultfd_ctx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *userfaultfd_ctx_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"userfaultfd_ctx_cache\"",
            "sizeof(struct userfaultfd_ctx)",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC",
            "init_once_userfaultfd_ctx"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nstatic int __init userfaultfd_init(void)\n{\n\tuserfaultfd_ctx_cachep = kmem_cache_create(\"userfaultfd_ctx_cache\",\n\t\t\t\t\t\tsizeof(struct userfaultfd_ctx),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC,\n\t\t\t\t\t\tinit_once_userfaultfd_ctx);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once_userfaultfd_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1885-1894",
    "snippet": "static void init_once_userfaultfd_ctx(void *mem)\n{\n\tstruct userfaultfd_ctx *ctx = (struct userfaultfd_ctx *) mem;\n\n\tinit_waitqueue_head(&ctx->fault_pending_wqh);\n\tinit_waitqueue_head(&ctx->fault_wqh);\n\tinit_waitqueue_head(&ctx->event_wqh);\n\tinit_waitqueue_head(&ctx->fd_wqh);\n\tseqcount_init(&ctx->refile_seq);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seqcount_init",
          "args": [
            "&ctx->refile_seq"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->fd_wqh"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->event_wqh"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->fault_wqh"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->fault_pending_wqh"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void init_once_userfaultfd_ctx(void *mem)\n{\n\tstruct userfaultfd_ctx *ctx = (struct userfaultfd_ctx *) mem;\n\n\tinit_waitqueue_head(&ctx->fault_pending_wqh);\n\tinit_waitqueue_head(&ctx->fault_wqh);\n\tinit_waitqueue_head(&ctx->event_wqh);\n\tinit_waitqueue_head(&ctx->fd_wqh);\n\tseqcount_init(&ctx->refile_seq);\n}"
  },
  {
    "function_name": "userfaultfd_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1846-1870",
    "snippet": "static void userfaultfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct userfaultfd_ctx *ctx = f->private_data;\n\twait_queue_entry_t *wq;\n\tunsigned long pending = 0, total = 0;\n\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\tlist_for_each_entry(wq, &ctx->fault_pending_wqh.head, entry) {\n\t\tpending++;\n\t\ttotal++;\n\t}\n\tlist_for_each_entry(wq, &ctx->fault_wqh.head, entry) {\n\t\ttotal++;\n\t}\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t/*\n\t * If more protocols will be added, there will be all shown\n\t * separated by a space. Like this:\n\t *\tprotocols: aa:... bb:...\n\t */\n\tseq_printf(m, \"pending:\\t%lu\\ntotal:\\t%lu\\nAPI:\\t%Lx:%x:%Lx\\n\",\n\t\t   pending, total, UFFD_API, ctx->features,\n\t\t   UFFD_API_IOCTLS|UFFD_API_RANGE_IOCTLS);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pending:\\t%lu\\ntotal:\\t%lu\\nAPI:\\t%Lx:%x:%Lx\\n\"",
            "pending",
            "total",
            "UFFD_API",
            "ctx->features",
            "UFFD_API_IOCTLS|UFFD_API_RANGE_IOCTLS"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "401-408",
          "snippet": "void seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&ctx->fault_wqh.head",
            "entry"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&ctx->fault_pending_wqh.head",
            "entry"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct userfaultfd_ctx *ctx = f->private_data;\n\twait_queue_entry_t *wq;\n\tunsigned long pending = 0, total = 0;\n\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\tlist_for_each_entry(wq, &ctx->fault_pending_wqh.head, entry) {\n\t\tpending++;\n\t\ttotal++;\n\t}\n\tlist_for_each_entry(wq, &ctx->fault_wqh.head, entry) {\n\t\ttotal++;\n\t}\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t/*\n\t * If more protocols will be added, there will be all shown\n\t * separated by a space. Like this:\n\t *\tprotocols: aa:... bb:...\n\t */\n\tseq_printf(m, \"pending:\\t%lu\\ntotal:\\t%lu\\nAPI:\\t%Lx:%x:%Lx\\n\",\n\t\t   pending, total, UFFD_API, ctx->features,\n\t\t   UFFD_API_IOCTLS|UFFD_API_RANGE_IOCTLS);\n}"
  },
  {
    "function_name": "userfaultfd_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1813-1843",
    "snippet": "static long userfaultfd_ioctl(struct file *file, unsigned cmd,\n\t\t\t      unsigned long arg)\n{\n\tint ret = -EINVAL;\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\n\tif (cmd != UFFDIO_API && ctx->state == UFFD_STATE_WAIT_API)\n\t\treturn -EINVAL;\n\n\tswitch(cmd) {\n\tcase UFFDIO_API:\n\t\tret = userfaultfd_api(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_REGISTER:\n\t\tret = userfaultfd_register(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_UNREGISTER:\n\t\tret = userfaultfd_unregister(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_WAKE:\n\t\tret = userfaultfd_wake(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_COPY:\n\t\tret = userfaultfd_copy(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_ZEROPAGE:\n\t\tret = userfaultfd_zeropage(ctx, arg);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_zeropage",
          "args": [
            "ctx",
            "arg"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_zeropage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1712-1762",
          "snippet": "static int userfaultfd_zeropage(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_zeropage uffdio_zeropage;\n\tstruct uffdio_zeropage __user *user_uffdio_zeropage;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_zeropage = (struct uffdio_zeropage __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_zeropage, user_uffdio_zeropage,\n\t\t\t   /* don't copy \"zeropage\" last field */\n\t\t\t   sizeof(uffdio_zeropage)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t     uffdio_zeropage.range.len);\n\tif (ret)\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (uffdio_zeropage.mode & ~UFFDIO_ZEROPAGE_MODE_DONTWAKE)\n\t\tgoto out;\n\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mfill_zeropage(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t\t     uffdio_zeropage.range.len,\n\t\t\t\t     &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_zeropage->zeropage)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\t/* len == 0 would wake all */\n\tBUG_ON(!ret);\n\trange.len = ret;\n\tif (!(uffdio_zeropage.mode & UFFDIO_ZEROPAGE_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_zeropage.range.start;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_zeropage.range.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_zeropage(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_zeropage uffdio_zeropage;\n\tstruct uffdio_zeropage __user *user_uffdio_zeropage;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_zeropage = (struct uffdio_zeropage __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_zeropage, user_uffdio_zeropage,\n\t\t\t   /* don't copy \"zeropage\" last field */\n\t\t\t   sizeof(uffdio_zeropage)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t     uffdio_zeropage.range.len);\n\tif (ret)\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (uffdio_zeropage.mode & ~UFFDIO_ZEROPAGE_MODE_DONTWAKE)\n\t\tgoto out;\n\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mfill_zeropage(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t\t     uffdio_zeropage.range.len,\n\t\t\t\t     &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_zeropage->zeropage)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\t/* len == 0 would wake all */\n\tBUG_ON(!ret);\n\trange.len = ret;\n\tif (!(uffdio_zeropage.mode & UFFDIO_ZEROPAGE_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_zeropage.range.start;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_zeropage.range.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_copy",
          "args": [
            "ctx",
            "arg"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1656-1710",
          "snippet": "static int userfaultfd_copy(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_copy uffdio_copy;\n\tstruct uffdio_copy __user *user_uffdio_copy;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_copy = (struct uffdio_copy __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_copy, user_uffdio_copy,\n\t\t\t   /* don't copy \"copy\" last field */\n\t\t\t   sizeof(uffdio_copy)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_copy.dst, uffdio_copy.len);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * double check for wraparound just in case. copy_from_user()\n\t * will later check uffdio_copy.src + uffdio_copy.len to fit\n\t * in the userland range.\n\t */\n\tret = -EINVAL;\n\tif (uffdio_copy.src + uffdio_copy.len <= uffdio_copy.src)\n\t\tgoto out;\n\tif (uffdio_copy.mode & ~UFFDIO_COPY_MODE_DONTWAKE)\n\t\tgoto out;\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mcopy_atomic(ctx->mm, uffdio_copy.dst, uffdio_copy.src,\n\t\t\t\t   uffdio_copy.len, &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_copy->copy)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(!ret);\n\t/* len == 0 would wake all */\n\trange.len = ret;\n\tif (!(uffdio_copy.mode & UFFDIO_COPY_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_copy.dst;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_copy.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_copy(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_copy uffdio_copy;\n\tstruct uffdio_copy __user *user_uffdio_copy;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_copy = (struct uffdio_copy __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_copy, user_uffdio_copy,\n\t\t\t   /* don't copy \"copy\" last field */\n\t\t\t   sizeof(uffdio_copy)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_copy.dst, uffdio_copy.len);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * double check for wraparound just in case. copy_from_user()\n\t * will later check uffdio_copy.src + uffdio_copy.len to fit\n\t * in the userland range.\n\t */\n\tret = -EINVAL;\n\tif (uffdio_copy.src + uffdio_copy.len <= uffdio_copy.src)\n\t\tgoto out;\n\tif (uffdio_copy.mode & ~UFFDIO_COPY_MODE_DONTWAKE)\n\t\tgoto out;\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mcopy_atomic(ctx->mm, uffdio_copy.dst, uffdio_copy.src,\n\t\t\t\t   uffdio_copy.len, &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_copy->copy)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(!ret);\n\t/* len == 0 would wake all */\n\trange.len = ret;\n\tif (!(uffdio_copy.mode & UFFDIO_COPY_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_copy.dst;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_copy.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_wake",
          "args": [
            "ctx",
            "arg"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1624-1654",
          "snippet": "static int userfaultfd_wake(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\tint ret;\n\tstruct uffdio_range uffdio_wake;\n\tstruct userfaultfd_wake_range range;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_wake, buf, sizeof(uffdio_wake)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_wake.start, uffdio_wake.len);\n\tif (ret)\n\t\tgoto out;\n\n\trange.start = uffdio_wake.start;\n\trange.len = uffdio_wake.len;\n\n\t/*\n\t * len == 0 means wake all and we don't want to wake all here,\n\t * so check it again to be sure.\n\t */\n\tVM_BUG_ON(!range.len);\n\n\twake_userfault(ctx, &range);\n\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_wake(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\tint ret;\n\tstruct uffdio_range uffdio_wake;\n\tstruct userfaultfd_wake_range range;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_wake, buf, sizeof(uffdio_wake)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_wake.start, uffdio_wake.len);\n\tif (ret)\n\t\tgoto out;\n\n\trange.start = uffdio_wake.start;\n\trange.len = uffdio_wake.len;\n\n\t/*\n\t * len == 0 means wake all and we don't want to wake all here,\n\t * so check it again to be sure.\n\t */\n\tVM_BUG_ON(!range.len);\n\n\twake_userfault(ctx, &range);\n\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_unregister",
          "args": [
            "ctx",
            "arg"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1473-1618",
          "snippet": "static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_register",
          "args": [
            "ctx",
            "arg"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1277-1471",
          "snippet": "static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If this vma contains ending address, and huge pages\n\t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If this vma contains ending address, and huge pages\n\t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_api",
          "args": [
            "ctx",
            "arg"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1777-1811",
          "snippet": "static int userfaultfd_api(struct userfaultfd_ctx *ctx,\n\t\t\t   unsigned long arg)\n{\n\tstruct uffdio_api uffdio_api;\n\tvoid __user *buf = (void __user *)arg;\n\tint ret;\n\t__u64 features;\n\n\tret = -EINVAL;\n\tif (ctx->state != UFFD_STATE_WAIT_API)\n\t\tgoto out;\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_api, buf, sizeof(uffdio_api)))\n\t\tgoto out;\n\tfeatures = uffdio_api.features;\n\tif (uffdio_api.api != UFFD_API || (features & ~UFFD_API_FEATURES)) {\n\t\tmemset(&uffdio_api, 0, sizeof(uffdio_api));\n\t\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* report all available features and ioctls to userland */\n\tuffdio_api.features = UFFD_API_FEATURES;\n\tuffdio_api.ioctls = UFFD_API_IOCTLS;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\tgoto out;\n\tctx->state = UFFD_STATE_RUNNING;\n\t/* only enable the requested features for this uffd context */\n\tctx->features = uffd_ctx_features(features);\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_api(struct userfaultfd_ctx *ctx,\n\t\t\t   unsigned long arg)\n{\n\tstruct uffdio_api uffdio_api;\n\tvoid __user *buf = (void __user *)arg;\n\tint ret;\n\t__u64 features;\n\n\tret = -EINVAL;\n\tif (ctx->state != UFFD_STATE_WAIT_API)\n\t\tgoto out;\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_api, buf, sizeof(uffdio_api)))\n\t\tgoto out;\n\tfeatures = uffdio_api.features;\n\tif (uffdio_api.api != UFFD_API || (features & ~UFFD_API_FEATURES)) {\n\t\tmemset(&uffdio_api, 0, sizeof(uffdio_api));\n\t\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* report all available features and ioctls to userland */\n\tuffdio_api.features = UFFD_API_FEATURES;\n\tuffdio_api.ioctls = UFFD_API_IOCTLS;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\tgoto out;\n\tctx->state = UFFD_STATE_RUNNING;\n\t/* only enable the requested features for this uffd context */\n\tctx->features = uffd_ctx_features(features);\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic long userfaultfd_ioctl(struct file *file, unsigned cmd,\n\t\t\t      unsigned long arg)\n{\n\tint ret = -EINVAL;\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\n\tif (cmd != UFFDIO_API && ctx->state == UFFD_STATE_WAIT_API)\n\t\treturn -EINVAL;\n\n\tswitch(cmd) {\n\tcase UFFDIO_API:\n\t\tret = userfaultfd_api(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_REGISTER:\n\t\tret = userfaultfd_register(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_UNREGISTER:\n\t\tret = userfaultfd_unregister(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_WAKE:\n\t\tret = userfaultfd_wake(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_COPY:\n\t\tret = userfaultfd_copy(ctx, arg);\n\t\tbreak;\n\tcase UFFDIO_ZEROPAGE:\n\t\tret = userfaultfd_zeropage(ctx, arg);\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd_api",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1777-1811",
    "snippet": "static int userfaultfd_api(struct userfaultfd_ctx *ctx,\n\t\t\t   unsigned long arg)\n{\n\tstruct uffdio_api uffdio_api;\n\tvoid __user *buf = (void __user *)arg;\n\tint ret;\n\t__u64 features;\n\n\tret = -EINVAL;\n\tif (ctx->state != UFFD_STATE_WAIT_API)\n\t\tgoto out;\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_api, buf, sizeof(uffdio_api)))\n\t\tgoto out;\n\tfeatures = uffdio_api.features;\n\tif (uffdio_api.api != UFFD_API || (features & ~UFFD_API_FEATURES)) {\n\t\tmemset(&uffdio_api, 0, sizeof(uffdio_api));\n\t\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* report all available features and ioctls to userland */\n\tuffdio_api.features = UFFD_API_FEATURES;\n\tuffdio_api.ioctls = UFFD_API_IOCTLS;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\tgoto out;\n\tctx->state = UFFD_STATE_RUNNING;\n\t/* only enable the requested features for this uffd context */\n\tctx->features = uffd_ctx_features(features);\n\tret = 0;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uffd_ctx_features",
          "args": [
            "features"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "uffd_ctx_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1764-1770",
          "snippet": "static inline unsigned int uffd_ctx_features(__u64 user_features)\n{\n\t/*\n\t * For the current set of features the bits just coincide\n\t */\n\treturn (unsigned int)user_features;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline unsigned int uffd_ctx_features(__u64 user_features)\n{\n\t/*\n\t * For the current set of features the bits just coincide\n\t */\n\treturn (unsigned int)user_features;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "&uffdio_api",
            "sizeof(uffdio_api)"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "&uffdio_api",
            "sizeof(uffdio_api)"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&uffdio_api",
            "0",
            "sizeof(uffdio_api)"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uffdio_api",
            "buf",
            "sizeof(uffdio_api)"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_api(struct userfaultfd_ctx *ctx,\n\t\t\t   unsigned long arg)\n{\n\tstruct uffdio_api uffdio_api;\n\tvoid __user *buf = (void __user *)arg;\n\tint ret;\n\t__u64 features;\n\n\tret = -EINVAL;\n\tif (ctx->state != UFFD_STATE_WAIT_API)\n\t\tgoto out;\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_api, buf, sizeof(uffdio_api)))\n\t\tgoto out;\n\tfeatures = uffdio_api.features;\n\tif (uffdio_api.api != UFFD_API || (features & ~UFFD_API_FEATURES)) {\n\t\tmemset(&uffdio_api, 0, sizeof(uffdio_api));\n\t\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* report all available features and ioctls to userland */\n\tuffdio_api.features = UFFD_API_FEATURES;\n\tuffdio_api.ioctls = UFFD_API_IOCTLS;\n\tret = -EFAULT;\n\tif (copy_to_user(buf, &uffdio_api, sizeof(uffdio_api)))\n\t\tgoto out;\n\tctx->state = UFFD_STATE_RUNNING;\n\t/* only enable the requested features for this uffd context */\n\tctx->features = uffd_ctx_features(features);\n\tret = 0;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "uffd_ctx_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1764-1770",
    "snippet": "static inline unsigned int uffd_ctx_features(__u64 user_features)\n{\n\t/*\n\t * For the current set of features the bits just coincide\n\t */\n\treturn (unsigned int)user_features;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline unsigned int uffd_ctx_features(__u64 user_features)\n{\n\t/*\n\t * For the current set of features the bits just coincide\n\t */\n\treturn (unsigned int)user_features;\n}"
  },
  {
    "function_name": "userfaultfd_zeropage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1712-1762",
    "snippet": "static int userfaultfd_zeropage(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_zeropage uffdio_zeropage;\n\tstruct uffdio_zeropage __user *user_uffdio_zeropage;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_zeropage = (struct uffdio_zeropage __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_zeropage, user_uffdio_zeropage,\n\t\t\t   /* don't copy \"zeropage\" last field */\n\t\t\t   sizeof(uffdio_zeropage)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t     uffdio_zeropage.range.len);\n\tif (ret)\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (uffdio_zeropage.mode & ~UFFDIO_ZEROPAGE_MODE_DONTWAKE)\n\t\tgoto out;\n\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mfill_zeropage(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t\t     uffdio_zeropage.range.len,\n\t\t\t\t     &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_zeropage->zeropage)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\t/* len == 0 would wake all */\n\tBUG_ON(!ret);\n\trange.len = ret;\n\tif (!(uffdio_zeropage.mode & UFFDIO_ZEROPAGE_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_zeropage.range.start;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_zeropage.range.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_userfault",
          "args": [
            "ctx",
            "&range"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "wake_userfault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1220-1249",
          "snippet": "static __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ret"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "put_user(ret, &user_uffdio_zeropage->zeropage)"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "ret",
            "&user_uffdio_zeropage->zeropage"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "ctx->mm"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfill_zeropage",
          "args": [
            "ctx->mm",
            "uffdio_zeropage.range.start",
            "uffdio_zeropage.range.len",
            "&ctx->mmap_changing"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "ctx->mm"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_range",
          "args": [
            "ctx->mm",
            "uffdio_zeropage.range.start",
            "uffdio_zeropage.range.len"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "validate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1251-1269",
          "snippet": "static __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uffdio_zeropage",
            "user_uffdio_zeropage",
            "/* don't copy \"zeropage\" last field */sizeof(uffdio_zeropage)-sizeof(__s64)"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ctx->mmap_changing"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_zeropage(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_zeropage uffdio_zeropage;\n\tstruct uffdio_zeropage __user *user_uffdio_zeropage;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_zeropage = (struct uffdio_zeropage __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_zeropage, user_uffdio_zeropage,\n\t\t\t   /* don't copy \"zeropage\" last field */\n\t\t\t   sizeof(uffdio_zeropage)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t     uffdio_zeropage.range.len);\n\tif (ret)\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (uffdio_zeropage.mode & ~UFFDIO_ZEROPAGE_MODE_DONTWAKE)\n\t\tgoto out;\n\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mfill_zeropage(ctx->mm, uffdio_zeropage.range.start,\n\t\t\t\t     uffdio_zeropage.range.len,\n\t\t\t\t     &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_zeropage->zeropage)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\t/* len == 0 would wake all */\n\tBUG_ON(!ret);\n\trange.len = ret;\n\tif (!(uffdio_zeropage.mode & UFFDIO_ZEROPAGE_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_zeropage.range.start;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_zeropage.range.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1656-1710",
    "snippet": "static int userfaultfd_copy(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_copy uffdio_copy;\n\tstruct uffdio_copy __user *user_uffdio_copy;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_copy = (struct uffdio_copy __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_copy, user_uffdio_copy,\n\t\t\t   /* don't copy \"copy\" last field */\n\t\t\t   sizeof(uffdio_copy)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_copy.dst, uffdio_copy.len);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * double check for wraparound just in case. copy_from_user()\n\t * will later check uffdio_copy.src + uffdio_copy.len to fit\n\t * in the userland range.\n\t */\n\tret = -EINVAL;\n\tif (uffdio_copy.src + uffdio_copy.len <= uffdio_copy.src)\n\t\tgoto out;\n\tif (uffdio_copy.mode & ~UFFDIO_COPY_MODE_DONTWAKE)\n\t\tgoto out;\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mcopy_atomic(ctx->mm, uffdio_copy.dst, uffdio_copy.src,\n\t\t\t\t   uffdio_copy.len, &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_copy->copy)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(!ret);\n\t/* len == 0 would wake all */\n\trange.len = ret;\n\tif (!(uffdio_copy.mode & UFFDIO_COPY_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_copy.dst;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_copy.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_userfault",
          "args": [
            "ctx",
            "&range"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "wake_userfault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1220-1249",
          "snippet": "static __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ret"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "put_user(ret, &user_uffdio_copy->copy)"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "ret",
            "&user_uffdio_copy->copy"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "ctx->mm"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcopy_atomic",
          "args": [
            "ctx->mm",
            "uffdio_copy.dst",
            "uffdio_copy.src",
            "uffdio_copy.len",
            "&ctx->mmap_changing"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "ctx->mm"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_range",
          "args": [
            "ctx->mm",
            "uffdio_copy.dst",
            "uffdio_copy.len"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "validate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1251-1269",
          "snippet": "static __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uffdio_copy",
            "user_uffdio_copy",
            "/* don't copy \"copy\" last field */sizeof(uffdio_copy)-sizeof(__s64)"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ctx->mmap_changing"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_copy(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\t__s64 ret;\n\tstruct uffdio_copy uffdio_copy;\n\tstruct uffdio_copy __user *user_uffdio_copy;\n\tstruct userfaultfd_wake_range range;\n\n\tuser_uffdio_copy = (struct uffdio_copy __user *) arg;\n\n\tret = -EAGAIN;\n\tif (READ_ONCE(ctx->mmap_changing))\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_copy, user_uffdio_copy,\n\t\t\t   /* don't copy \"copy\" last field */\n\t\t\t   sizeof(uffdio_copy)-sizeof(__s64)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_copy.dst, uffdio_copy.len);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * double check for wraparound just in case. copy_from_user()\n\t * will later check uffdio_copy.src + uffdio_copy.len to fit\n\t * in the userland range.\n\t */\n\tret = -EINVAL;\n\tif (uffdio_copy.src + uffdio_copy.len <= uffdio_copy.src)\n\t\tgoto out;\n\tif (uffdio_copy.mode & ~UFFDIO_COPY_MODE_DONTWAKE)\n\t\tgoto out;\n\tif (mmget_not_zero(ctx->mm)) {\n\t\tret = mcopy_atomic(ctx->mm, uffdio_copy.dst, uffdio_copy.src,\n\t\t\t\t   uffdio_copy.len, &ctx->mmap_changing);\n\t\tmmput(ctx->mm);\n\t} else {\n\t\treturn -ESRCH;\n\t}\n\tif (unlikely(put_user(ret, &user_uffdio_copy->copy)))\n\t\treturn -EFAULT;\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(!ret);\n\t/* len == 0 would wake all */\n\trange.len = ret;\n\tif (!(uffdio_copy.mode & UFFDIO_COPY_MODE_DONTWAKE)) {\n\t\trange.start = uffdio_copy.dst;\n\t\twake_userfault(ctx, &range);\n\t}\n\tret = range.len == uffdio_copy.len ? 0 : -EAGAIN;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1624-1654",
    "snippet": "static int userfaultfd_wake(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\tint ret;\n\tstruct uffdio_range uffdio_wake;\n\tstruct userfaultfd_wake_range range;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_wake, buf, sizeof(uffdio_wake)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_wake.start, uffdio_wake.len);\n\tif (ret)\n\t\tgoto out;\n\n\trange.start = uffdio_wake.start;\n\trange.len = uffdio_wake.len;\n\n\t/*\n\t * len == 0 means wake all and we don't want to wake all here,\n\t * so check it again to be sure.\n\t */\n\tVM_BUG_ON(!range.len);\n\n\twake_userfault(ctx, &range);\n\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_userfault",
          "args": [
            "ctx",
            "&range"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "wake_userfault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1220-1249",
          "snippet": "static __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!range.len"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_range",
          "args": [
            "ctx->mm",
            "uffdio_wake.start",
            "uffdio_wake.len"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "validate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1251-1269",
          "snippet": "static __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uffdio_wake",
            "buf",
            "sizeof(uffdio_wake)"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_wake(struct userfaultfd_ctx *ctx,\n\t\t\t    unsigned long arg)\n{\n\tint ret;\n\tstruct uffdio_range uffdio_wake;\n\tstruct userfaultfd_wake_range range;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_wake, buf, sizeof(uffdio_wake)))\n\t\tgoto out;\n\n\tret = validate_range(ctx->mm, uffdio_wake.start, uffdio_wake.len);\n\tif (ret)\n\t\tgoto out;\n\n\trange.start = uffdio_wake.start;\n\trange.len = uffdio_wake.len;\n\n\t/*\n\t * len == 0 means wake all and we don't want to wake all here,\n\t * so check it again to be sure.\n\t */\n\tVM_BUG_ON(!range.len);\n\n\twake_userfault(ctx, &range);\n\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1473-1618",
    "snippet": "static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_vma",
          "args": [
            "mm",
            "vma",
            "end",
            "0"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_vma",
          "args": [
            "mm",
            "vma",
            "start",
            "1"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "prev",
            "start",
            "vma_end",
            "new_flags",
            "vma->anon_vma",
            "vma->vm_file",
            "vma->vm_pgoff",
            "vma_policy(vma)",
            "NULL_VM_UFFD_CTX"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_drop_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/hugetlbfs/inode.c",
          "lines": "96-98",
          "snippet": "static inline void hugetlb_drop_vma_policy(struct vm_area_struct *vma)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/falloc.h>",
            "#include <linux/sched/signal.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/falloc.h>\n#include <linux/sched/signal.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n\nstatic inline void hugetlb_drop_vma_policy(struct vm_area_struct *vma)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_userfault",
          "args": [
            "vma->vm_userfaultfd_ctx.ctx",
            "&range"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "wake_userfault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1220-1249",
          "snippet": "static __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_missing",
          "args": [
            "vma"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "vma->vm_end"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vma_can_userfault(vma)"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_can_userfault",
          "args": [
            "vma"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "vma_can_userfault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1271-1275",
          "snippet": "static inline bool vma_can_userfault(struct vm_area_struct *vma)\n{\n\treturn vma_is_anonymous(vma) || is_vm_hugetlb_page(vma) ||\n\t\tvma_is_shmem(vma);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool vma_can_userfault(struct vm_area_struct *vma)\n{\n\treturn vma_is_anonymous(vma) || is_vm_hugetlb_page(vma) ||\n\t\tvma_is_shmem(vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!found"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP))"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_kernel_pagesize",
          "args": [
            "vma"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_prev",
          "args": [
            "mm",
            "start",
            "&prev"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "mm"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_range",
          "args": [
            "mm",
            "uffdio_unregister.start",
            "uffdio_unregister.len"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "validate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1251-1269",
          "snippet": "static __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uffdio_unregister",
            "buf",
            "sizeof(uffdio_unregister)"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1277-1471",
    "snippet": "static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If this vma contains ending address, and huge pages\n\t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS",
            "&user_uffdio_register->ioctls"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_vma",
          "args": [
            "mm",
            "vma",
            "end",
            "0"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_vma",
          "args": [
            "mm",
            "vma",
            "start",
            "1"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "prev",
            "start",
            "vma_end",
            "new_flags",
            "vma->anon_vma",
            "vma->vm_file",
            "vma->vm_pgoff",
            "vma_policy(vma)",
            "((struct vm_userfaultfd_ctx){ ctx })"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_drop_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/hugetlbfs/inode.c",
          "lines": "96-98",
          "snippet": "static inline void hugetlb_drop_vma_policy(struct vm_area_struct *vma)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/falloc.h>",
            "#include <linux/sched/signal.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/falloc.h>\n#include <linux/sched/signal.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n\nstatic inline void hugetlb_drop_vma_policy(struct vm_area_struct *vma)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "vma->vm_end"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vma_can_userfault(vma)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_can_userfault",
          "args": [
            "vma"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "vma_can_userfault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1271-1275",
          "snippet": "static inline bool vma_can_userfault(struct vm_area_struct *vma)\n{\n\treturn vma_is_anonymous(vma) || is_vm_hugetlb_page(vma) ||\n\t\tvma_is_shmem(vma);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool vma_can_userfault(struct vm_area_struct *vma)\n{\n\treturn vma_is_anonymous(vma) || is_vm_hugetlb_page(vma) ||\n\t\tvma_is_shmem(vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!found"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "cur"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_kernel_pagesize",
          "args": [
            "cur"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "cur"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP))"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_kernel_pagesize",
          "args": [
            "vma"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma_prev",
          "args": [
            "mm",
            "start",
            "&prev"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "mm"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_range",
          "args": [
            "mm",
            "uffdio_register.range.start",
            "uffdio_register.range.len"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "validate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1251-1269",
          "snippet": "static __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uffdio_register",
            "user_uffdio_register",
            "sizeof(uffdio_register)-sizeof(__u64)"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If this vma contains ending address, and huge pages\n\t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "vma_can_userfault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1271-1275",
    "snippet": "static inline bool vma_can_userfault(struct vm_area_struct *vma)\n{\n\treturn vma_is_anonymous(vma) || is_vm_hugetlb_page(vma) ||\n\t\tvma_is_shmem(vma);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_is_shmem",
          "args": [
            "vma"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool vma_can_userfault(struct vm_area_struct *vma)\n{\n\treturn vma_is_anonymous(vma) || is_vm_hugetlb_page(vma) ||\n\t\tvma_is_shmem(vma);\n}"
  },
  {
    "function_name": "validate_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1251-1269",
    "snippet": "static __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline int validate_range(struct mm_struct *mm,\n\t\t\t\t\t  __u64 start, __u64 len)\n{\n\t__u64 task_size = mm->task_size;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (len & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn -EINVAL;\n\tif (start < mmap_min_addr)\n\t\treturn -EINVAL;\n\tif (start >= task_size)\n\t\treturn -EINVAL;\n\tif (len > task_size - start)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "wake_userfault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1220-1249",
    "snippet": "static __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_userfault",
          "args": [
            "ctx",
            "range"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_userfault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1207-1218",
          "snippet": "static void __wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t     struct userfaultfd_wake_range *range)\n{\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t/* wake all in the range and autoremove */\n\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL,\n\t\t\t\t     range);\n\tif (waitqueue_active(&ctx->fault_wqh))\n\t\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void __wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t     struct userfaultfd_wake_range *range)\n{\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t/* wake all in the range and autoremove */\n\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL,\n\t\t\t\t     range);\n\tif (waitqueue_active(&ctx->fault_wqh))\n\t\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&ctx->refile_seq",
            "seq"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fault_wqh"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fault_pending_wqh"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&ctx->refile_seq"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __always_inline void wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t   struct userfaultfd_wake_range *range)\n{\n\tunsigned seq;\n\tbool need_wakeup;\n\n\t/*\n\t * To be sure waitqueue_active() is not reordered by the CPU\n\t * before the pagetable update, use an explicit SMP memory\n\t * barrier here. PT lock release or up_read(mmap_sem) still\n\t * have release semantics that can allow the\n\t * waitqueue_active() to be reordered before the pte update.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Use waitqueue_active because it's very frequent to\n\t * change the address space atomically even if there are no\n\t * userfaults yet. So we take the spinlock only when we're\n\t * sure we've userfaults to wake.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ctx->refile_seq);\n\t\tneed_wakeup = waitqueue_active(&ctx->fault_pending_wqh) ||\n\t\t\twaitqueue_active(&ctx->fault_wqh);\n\t\tcond_resched();\n\t} while (read_seqcount_retry(&ctx->refile_seq, seq));\n\tif (need_wakeup)\n\t\t__wake_userfault(ctx, range);\n}"
  },
  {
    "function_name": "__wake_userfault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1207-1218",
    "snippet": "static void __wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t     struct userfaultfd_wake_range *range)\n{\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t/* wake all in the range and autoremove */\n\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL,\n\t\t\t\t     range);\n\tif (waitqueue_active(&ctx->fault_wqh))\n\t\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "&ctx->fault_wqh",
            "TASK_NORMAL",
            "1",
            "range"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fault_wqh"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_up_locked_key",
          "args": [
            "&ctx->fault_pending_wqh",
            "TASK_NORMAL",
            "range"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fault_pending_wqh"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void __wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t     struct userfaultfd_wake_range *range)\n{\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t/* wake all in the range and autoremove */\n\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL,\n\t\t\t\t     range);\n\tif (waitqueue_active(&ctx->fault_wqh))\n\t\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n}"
  },
  {
    "function_name": "userfaultfd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1177-1205",
    "snippet": "static ssize_t userfaultfd_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tssize_t _ret, ret = 0;\n\tstruct uffd_msg msg;\n\tint no_wait = file->f_flags & O_NONBLOCK;\n\n\tif (ctx->state == UFFD_STATE_WAIT_API)\n\t\treturn -EINVAL;\n\n\tfor (;;) {\n\t\tif (count < sizeof(msg))\n\t\t\treturn ret ? ret : -EINVAL;\n\t\t_ret = userfaultfd_ctx_read(ctx, no_wait, &msg);\n\t\tif (_ret < 0)\n\t\t\treturn ret ? ret : _ret;\n\t\tif (copy_to_user((__u64 __user *) buf, &msg, sizeof(msg)))\n\t\t\treturn ret ? ret : -EFAULT;\n\t\tret += sizeof(msg);\n\t\tbuf += sizeof(msg);\n\t\tcount -= sizeof(msg);\n\t\t/*\n\t\t * Allow to read more than one fault at time but only\n\t\t * block if waiting for the very first one.\n\t\t */\n\t\tno_wait = O_NONBLOCK;\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(__u64 __user *) buf",
            "&msg",
            "sizeof(msg)"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_read",
          "args": [
            "ctx",
            "no_wait",
            "&msg"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "1012-1175",
          "snippet": "static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\tadd_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\tadd_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic ssize_t userfaultfd_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tssize_t _ret, ret = 0;\n\tstruct uffd_msg msg;\n\tint no_wait = file->f_flags & O_NONBLOCK;\n\n\tif (ctx->state == UFFD_STATE_WAIT_API)\n\t\treturn -EINVAL;\n\n\tfor (;;) {\n\t\tif (count < sizeof(msg))\n\t\t\treturn ret ? ret : -EINVAL;\n\t\t_ret = userfaultfd_ctx_read(ctx, no_wait, &msg);\n\t\tif (_ret < 0)\n\t\t\treturn ret ? ret : _ret;\n\t\tif (copy_to_user((__u64 __user *) buf, &msg, sizeof(msg)))\n\t\t\treturn ret ? ret : -EFAULT;\n\t\tret += sizeof(msg);\n\t\tbuf += sizeof(msg);\n\t\tcount -= sizeof(msg);\n\t\t/*\n\t\t * Allow to read more than one fault at time but only\n\t\t * block if waiting for the very first one.\n\t\t */\n\t\tno_wait = O_NONBLOCK;\n\t}\n}"
  },
  {
    "function_name": "userfaultfd_ctx_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1012-1175",
    "snippet": "static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\tadd_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->event_wqh.lock"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_put",
          "args": [
            "fork_nctx"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "155-169",
          "snippet": "static void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *userfaultfd_ctx_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nstatic void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_event_complete",
          "args": [
            "ctx",
            "uwq"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_event_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "652-658",
          "snippet": "static void userfaultfd_event_complete(struct userfaultfd_ctx *ctx,\n\t\t\t\t       struct userfaultfd_wait_queue *ewq)\n{\n\tewq->msg.event = 0;\n\twake_up_locked(&ctx->event_wqh);\n\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_event_complete(struct userfaultfd_ctx *ctx,\n\t\t\t\t       struct userfaultfd_wait_queue *ewq)\n{\n\tewq->msg.event = 0;\n\twake_up_locked(&ctx->event_wqh);\n\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->event_wqh",
            "&uwq->wq"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&uwq->wq.entry"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&fork_event",
            "typeof(*uwq)",
            "wq.entry"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*uwq"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fork_event"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->event_wqh.lock"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_userfault_fork",
          "args": [
            "ctx",
            "fork_nctx",
            "msg"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_userfault_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "996-1010",
          "snippet": "static int resolve_userfault_fork(struct userfaultfd_ctx *ctx,\n\t\t\t\t  struct userfaultfd_ctx *new,\n\t\t\t\t  struct uffd_msg *msg)\n{\n\tint fd;\n\n\tfd = anon_inode_getfd(\"[userfaultfd]\", &userfaultfd_fops, new,\n\t\t\t      O_RDWR | (new->flags & UFFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmsg->arg.reserved.reserved1 = 0;\n\tmsg->arg.fork.ufd = fd;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations userfaultfd_fops;",
            "static const struct file_operations userfaultfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= userfaultfd_show_fdinfo,\n#endif\n\t.release\t= userfaultfd_release,\n\t.poll\t\t= userfaultfd_poll,\n\t.read\t\t= userfaultfd_read,\n\t.unlocked_ioctl = userfaultfd_ioctl,\n\t.compat_ioctl\t= userfaultfd_ioctl,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic const struct file_operations userfaultfd_fops;\nstatic const struct file_operations userfaultfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= userfaultfd_show_fdinfo,\n#endif\n\t.release\t= userfaultfd_release,\n\t.poll\t\t= userfaultfd_poll,\n\t.read\t\t= userfaultfd_read,\n\t.unlocked_ioctl = userfaultfd_ioctl,\n\t.compat_ioctl\t= userfaultfd_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int resolve_userfault_fork(struct userfaultfd_ctx *ctx,\n\t\t\t\t  struct userfaultfd_ctx *new,\n\t\t\t\t  struct uffd_msg *msg)\n{\n\tint fd;\n\n\tfd = anon_inode_getfd(\"[userfaultfd]\", &userfaultfd_fops, new,\n\t\t\t      O_RDWR | (new->flags & UFFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmsg->arg.reserved.reserved1 = 0;\n\tmsg->arg.fork.ufd = fd;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->fd_wqh.lock"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->fd_wqh",
            "&wait"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->fd_wqh.lock"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->fd_wqh.lock"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_get",
          "args": [
            "fork_nctx"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "141-145",
          "snippet": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&uwq->wq.entry",
            "&fork_event"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_userfault_evt",
          "args": [
            "ctx"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "find_userfault_evt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "947-951",
          "snippet": "static inline struct userfaultfd_wait_queue *find_userfault_evt(\n\t\tstruct userfaultfd_ctx *ctx)\n{\n\treturn find_userfault_in(&ctx->event_wqh);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct userfaultfd_wait_queue *find_userfault_evt(\n\t\tstruct userfaultfd_ctx *ctx)\n{\n\treturn find_userfault_in(&ctx->event_wqh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&ctx->refile_seq"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&ctx->fault_wqh",
            "&uwq->wq"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&ctx->refile_seq"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->fd_wqh",
            "&wait"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->fd_wqh.lock"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "fork_event"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\tadd_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock_irq(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock_irq(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "resolve_userfault_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "996-1010",
    "snippet": "static int resolve_userfault_fork(struct userfaultfd_ctx *ctx,\n\t\t\t\t  struct userfaultfd_ctx *new,\n\t\t\t\t  struct uffd_msg *msg)\n{\n\tint fd;\n\n\tfd = anon_inode_getfd(\"[userfaultfd]\", &userfaultfd_fops, new,\n\t\t\t      O_RDWR | (new->flags & UFFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmsg->arg.reserved.reserved1 = 0;\n\tmsg->arg.fork.ufd = fd;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations userfaultfd_fops;",
      "static const struct file_operations userfaultfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= userfaultfd_show_fdinfo,\n#endif\n\t.release\t= userfaultfd_release,\n\t.poll\t\t= userfaultfd_poll,\n\t.read\t\t= userfaultfd_read,\n\t.unlocked_ioctl = userfaultfd_ioctl,\n\t.compat_ioctl\t= userfaultfd_ioctl,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"[userfaultfd]\"",
            "&userfaultfd_fops",
            "new",
            "O_RDWR | (new->flags & UFFD_SHARED_FCNTL_FLAGS)"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "anon_inode_getfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
          "lines": "121-144",
          "snippet": "int anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nint anon_inode_getfd(const char *name, const struct file_operations *fops,\n\t\t     void *priv, int flags)\n{\n\tint error, fd;\n\tstruct file *file;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\treturn error;\n\tfd = error;\n\n\tfile = anon_inode_getfile(name, fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\tfd_install(fd, file);\n\n\treturn fd;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic const struct file_operations userfaultfd_fops;\nstatic const struct file_operations userfaultfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= userfaultfd_show_fdinfo,\n#endif\n\t.release\t= userfaultfd_release,\n\t.poll\t\t= userfaultfd_poll,\n\t.read\t\t= userfaultfd_read,\n\t.unlocked_ioctl = userfaultfd_ioctl,\n\t.compat_ioctl\t= userfaultfd_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int resolve_userfault_fork(struct userfaultfd_ctx *ctx,\n\t\t\t\t  struct userfaultfd_ctx *new,\n\t\t\t\t  struct uffd_msg *msg)\n{\n\tint fd;\n\n\tfd = anon_inode_getfd(\"[userfaultfd]\", &userfaultfd_fops, new,\n\t\t\t      O_RDWR | (new->flags & UFFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0)\n\t\treturn fd;\n\n\tmsg->arg.reserved.reserved1 = 0;\n\tmsg->arg.fork.ufd = fd;\n\treturn 0;\n}"
  },
  {
    "function_name": "userfaultfd_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "953-992",
    "snippet": "static __poll_t userfaultfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\t__poll_t ret;\n\n\tpoll_wait(file, &ctx->fd_wqh, wait);\n\n\tswitch (ctx->state) {\n\tcase UFFD_STATE_WAIT_API:\n\t\treturn EPOLLERR;\n\tcase UFFD_STATE_RUNNING:\n\t\t/*\n\t\t * poll() never guarantees that read won't block.\n\t\t * userfaults can be waken before they're read().\n\t\t */\n\t\tif (unlikely(!(file->f_flags & O_NONBLOCK)))\n\t\t\treturn EPOLLERR;\n\t\t/*\n\t\t * lockless access to see if there are pending faults\n\t\t * __pollwait last action is the add_wait_queue but\n\t\t * the spin_unlock would allow the waitqueue_active to\n\t\t * pass above the actual list_add inside\n\t\t * add_wait_queue critical section. So use a full\n\t\t * memory barrier to serialize the list_add write of\n\t\t * add_wait_queue() with the waitqueue_active read\n\t\t * below.\n\t\t */\n\t\tret = 0;\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t\tret = EPOLLIN;\n\t\telse if (waitqueue_active(&ctx->event_wqh))\n\t\t\tret = EPOLLIN;\n\n\t\treturn ret;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn EPOLLERR;\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->event_wqh"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fault_pending_wqh"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(file->f_flags & O_NONBLOCK)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&ctx->fd_wqh",
            "wait"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic __poll_t userfaultfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\t__poll_t ret;\n\n\tpoll_wait(file, &ctx->fd_wqh, wait);\n\n\tswitch (ctx->state) {\n\tcase UFFD_STATE_WAIT_API:\n\t\treturn EPOLLERR;\n\tcase UFFD_STATE_RUNNING:\n\t\t/*\n\t\t * poll() never guarantees that read won't block.\n\t\t * userfaults can be waken before they're read().\n\t\t */\n\t\tif (unlikely(!(file->f_flags & O_NONBLOCK)))\n\t\t\treturn EPOLLERR;\n\t\t/*\n\t\t * lockless access to see if there are pending faults\n\t\t * __pollwait last action is the add_wait_queue but\n\t\t * the spin_unlock would allow the waitqueue_active to\n\t\t * pass above the actual list_add inside\n\t\t * add_wait_queue critical section. So use a full\n\t\t * memory barrier to serialize the list_add write of\n\t\t * add_wait_queue() with the waitqueue_active read\n\t\t * below.\n\t\t */\n\t\tret = 0;\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t\tret = EPOLLIN;\n\t\telse if (waitqueue_active(&ctx->event_wqh))\n\t\t\tret = EPOLLIN;\n\n\t\treturn ret;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn EPOLLERR;\n\t}\n}"
  },
  {
    "function_name": "find_userfault_evt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "947-951",
    "snippet": "static inline struct userfaultfd_wait_queue *find_userfault_evt(\n\t\tstruct userfaultfd_ctx *ctx)\n{\n\treturn find_userfault_in(&ctx->event_wqh);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_userfault_in",
          "args": [
            "&ctx->event_wqh"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "find_userfault_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "923-939",
          "snippet": "static inline struct userfaultfd_wait_queue *find_userfault_in(\n\t\twait_queue_head_t *wqh)\n{\n\twait_queue_entry_t *wq;\n\tstruct userfaultfd_wait_queue *uwq;\n\n\tVM_BUG_ON(!spin_is_locked(&wqh->lock));\n\n\tuwq = NULL;\n\tif (!waitqueue_active(wqh))\n\t\tgoto out;\n\t/* walk in reverse to provide FIFO behavior to read userfaults */\n\twq = list_last_entry(&wqh->head, typeof(*wq), entry);\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\nout:\n\treturn uwq;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct userfaultfd_wait_queue *find_userfault_in(\n\t\twait_queue_head_t *wqh)\n{\n\twait_queue_entry_t *wq;\n\tstruct userfaultfd_wait_queue *uwq;\n\n\tVM_BUG_ON(!spin_is_locked(&wqh->lock));\n\n\tuwq = NULL;\n\tif (!waitqueue_active(wqh))\n\t\tgoto out;\n\t/* walk in reverse to provide FIFO behavior to read userfaults */\n\twq = list_last_entry(&wqh->head, typeof(*wq), entry);\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\nout:\n\treturn uwq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct userfaultfd_wait_queue *find_userfault_evt(\n\t\tstruct userfaultfd_ctx *ctx)\n{\n\treturn find_userfault_in(&ctx->event_wqh);\n}"
  },
  {
    "function_name": "find_userfault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "941-945",
    "snippet": "static inline struct userfaultfd_wait_queue *find_userfault(\n\t\tstruct userfaultfd_ctx *ctx)\n{\n\treturn find_userfault_in(&ctx->fault_pending_wqh);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_userfault_in",
          "args": [
            "&ctx->fault_pending_wqh"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "find_userfault_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "923-939",
          "snippet": "static inline struct userfaultfd_wait_queue *find_userfault_in(\n\t\twait_queue_head_t *wqh)\n{\n\twait_queue_entry_t *wq;\n\tstruct userfaultfd_wait_queue *uwq;\n\n\tVM_BUG_ON(!spin_is_locked(&wqh->lock));\n\n\tuwq = NULL;\n\tif (!waitqueue_active(wqh))\n\t\tgoto out;\n\t/* walk in reverse to provide FIFO behavior to read userfaults */\n\twq = list_last_entry(&wqh->head, typeof(*wq), entry);\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\nout:\n\treturn uwq;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct userfaultfd_wait_queue *find_userfault_in(\n\t\twait_queue_head_t *wqh)\n{\n\twait_queue_entry_t *wq;\n\tstruct userfaultfd_wait_queue *uwq;\n\n\tVM_BUG_ON(!spin_is_locked(&wqh->lock));\n\n\tuwq = NULL;\n\tif (!waitqueue_active(wqh))\n\t\tgoto out;\n\t/* walk in reverse to provide FIFO behavior to read userfaults */\n\twq = list_last_entry(&wqh->head, typeof(*wq), entry);\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\nout:\n\treturn uwq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct userfaultfd_wait_queue *find_userfault(\n\t\tstruct userfaultfd_ctx *ctx)\n{\n\treturn find_userfault_in(&ctx->fault_pending_wqh);\n}"
  },
  {
    "function_name": "find_userfault_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "923-939",
    "snippet": "static inline struct userfaultfd_wait_queue *find_userfault_in(\n\t\twait_queue_head_t *wqh)\n{\n\twait_queue_entry_t *wq;\n\tstruct userfaultfd_wait_queue *uwq;\n\n\tVM_BUG_ON(!spin_is_locked(&wqh->lock));\n\n\tuwq = NULL;\n\tif (!waitqueue_active(wqh))\n\t\tgoto out;\n\t/* walk in reverse to provide FIFO behavior to read userfaults */\n\twq = list_last_entry(&wqh->head, typeof(*wq), entry);\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\nout:\n\treturn uwq;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wq",
            "structuserfaultfd_wait_queue",
            "wq"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "&wqh->head",
            "typeof(*wq)",
            "entry"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*wq"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "wqh"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!spin_is_locked(&wqh->lock)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&wqh->lock"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct userfaultfd_wait_queue *find_userfault_in(\n\t\twait_queue_head_t *wqh)\n{\n\twait_queue_entry_t *wq;\n\tstruct userfaultfd_wait_queue *uwq;\n\n\tVM_BUG_ON(!spin_is_locked(&wqh->lock));\n\n\tuwq = NULL;\n\tif (!waitqueue_active(wqh))\n\t\tgoto out;\n\t/* walk in reverse to provide FIFO behavior to read userfaults */\n\twq = list_last_entry(&wqh->head, typeof(*wq), entry);\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\nout:\n\treturn uwq;\n}"
  },
  {
    "function_name": "userfaultfd_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "856-920",
    "snippet": "static int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\t/* len == 0 means wake all */\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\n\tWRITE_ONCE(ctx->released, true);\n\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\n\t/*\n\t * Flush page faults out of all CPUs. NOTE: all page faults\n\t * must be retried without returning VM_FAULT_SIGBUS if\n\t * userfaultfd_ctx_get() succeeds but vma->vma_userfault_ctx\n\t * changes while handle_userfault released the mmap_sem. So\n\t * it's critical that released is set to true (above), before\n\t * taking the mmap_sem for writing.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev)\n\t\t\tvma = prev;\n\t\telse\n\t\t\tprev = vma;\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t}\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\t/*\n\t * After no new page faults can wait on this fault_*wqh, flush\n\t * the last page faults that may have been already waiting on\n\t * the fault_*wqh.\n\t */\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t/* Flush pending events that may still wait on event_wqh */\n\twake_up_all(&ctx->event_wqh);\n\n\twake_up_poll(&ctx->fd_wqh, EPOLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_ctx_put",
          "args": [
            "ctx"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "155-169",
          "snippet": "static void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *userfaultfd_ctx_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nstatic void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&ctx->fd_wqh",
            "EPOLLHUP"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ctx->event_wqh"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "&ctx->fault_wqh",
            "TASK_NORMAL",
            "1",
            "&range"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_up_locked_key",
          "args": [
            "&ctx->fault_pending_wqh",
            "TASK_NORMAL",
            "&range"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "prev",
            "vma->vm_start",
            "vma->vm_end",
            "new_flags",
            "vma->anon_vma",
            "vma->vm_file",
            "vma->vm_pgoff",
            "vma_policy(vma)",
            "NULL_VM_UFFD_CTX"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_drop_vma_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/hugetlbfs/inode.c",
          "lines": "96-98",
          "snippet": "static inline void hugetlb_drop_vma_policy(struct vm_area_struct *vma)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/falloc.h>",
            "#include <linux/sched/signal.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/falloc.h>\n#include <linux/sched/signal.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n\nstatic inline void hugetlb_drop_vma_policy(struct vm_area_struct *vma)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP))"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmget_not_zero",
          "args": [
            "mm"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ctx->released",
            "true"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\t/* len == 0 means wake all */\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\n\tWRITE_ONCE(ctx->released, true);\n\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\n\t/*\n\t * Flush page faults out of all CPUs. NOTE: all page faults\n\t * must be retried without returning VM_FAULT_SIGBUS if\n\t * userfaultfd_ctx_get() succeeds but vma->vma_userfault_ctx\n\t * changes while handle_userfault released the mmap_sem. So\n\t * it's critical that released is set to true (above), before\n\t * taking the mmap_sem for writing.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev)\n\t\t\tvma = prev;\n\t\telse\n\t\t\tprev = vma;\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t}\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\t/*\n\t * After no new page faults can wait on this fault_*wqh, flush\n\t * the last page faults that may have been already waiting on\n\t * the fault_*wqh.\n\t */\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t/* Flush pending events that may still wait on event_wqh */\n\twake_up_all(&ctx->event_wqh);\n\n\twake_up_poll(&ctx->fd_wqh, EPOLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}"
  },
  {
    "function_name": "userfaultfd_unmap_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "837-854",
    "snippet": "void userfaultfd_unmap_complete(struct mm_struct *mm, struct list_head *uf)\n{\n\tstruct userfaultfd_unmap_ctx *ctx, *n;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tlist_for_each_entry_safe(ctx, n, uf, list) {\n\t\tmsg_init(&ewq.msg);\n\n\t\tewq.msg.event = UFFD_EVENT_UNMAP;\n\t\tewq.msg.arg.remove.start = ctx->start;\n\t\tewq.msg.arg.remove.end = ctx->end;\n\n\t\tuserfaultfd_event_wait_completion(ctx->ctx, &ewq);\n\n\t\tlist_del(&ctx->list);\n\t\tkfree(ctx);\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ctx->list"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_event_wait_completion",
          "args": [
            "ctx->ctx",
            "&ewq"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_event_wait_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "575-650",
          "snippet": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_init",
          "args": [
            "&ewq.msg"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "msg_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "171-179",
          "snippet": "static inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ctx",
            "n",
            "uf",
            "list"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nvoid userfaultfd_unmap_complete(struct mm_struct *mm, struct list_head *uf)\n{\n\tstruct userfaultfd_unmap_ctx *ctx, *n;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tlist_for_each_entry_safe(ctx, n, uf, list) {\n\t\tmsg_init(&ewq.msg);\n\n\t\tewq.msg.event = UFFD_EVENT_UNMAP;\n\t\tewq.msg.arg.remove.start = ctx->start;\n\t\tewq.msg.arg.remove.end = ctx->end;\n\n\t\tuserfaultfd_event_wait_completion(ctx->ctx, &ewq);\n\n\t\tlist_del(&ctx->list);\n\t\tkfree(ctx);\n\t}\n}"
  },
  {
    "function_name": "userfaultfd_unmap_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "810-835",
    "snippet": "int userfaultfd_unmap_prep(struct vm_area_struct *vma,\n\t\t\t   unsigned long start, unsigned long end,\n\t\t\t   struct list_head *unmaps)\n{\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next) {\n\t\tstruct userfaultfd_unmap_ctx *unmap_ctx;\n\t\tstruct userfaultfd_ctx *ctx = vma->vm_userfaultfd_ctx.ctx;\n\n\t\tif (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_UNMAP) ||\n\t\t    has_unmap_ctx(ctx, unmaps, start, end))\n\t\t\tcontinue;\n\n\t\tunmap_ctx = kzalloc(sizeof(*unmap_ctx), GFP_KERNEL);\n\t\tif (!unmap_ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tuserfaultfd_ctx_get(ctx);\n\t\tWRITE_ONCE(ctx->mmap_changing, true);\n\t\tunmap_ctx->ctx = ctx;\n\t\tunmap_ctx->start = start;\n\t\tunmap_ctx->end = end;\n\t\tlist_add_tail(&unmap_ctx->list, unmaps);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&unmap_ctx->list",
            "unmaps"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ctx->mmap_changing",
            "true"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_get",
          "args": [
            "ctx"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "141-145",
          "snippet": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*unmap_ctx)",
            "GFP_KERNEL"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_unmap_ctx",
          "args": [
            "ctx",
            "unmaps",
            "start",
            "end"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "has_unmap_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "797-808",
          "snippet": "static bool has_unmap_ctx(struct userfaultfd_ctx *ctx, struct list_head *unmaps,\n\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct userfaultfd_unmap_ctx *unmap_ctx;\n\n\tlist_for_each_entry(unmap_ctx, unmaps, list)\n\t\tif (unmap_ctx->ctx == ctx && unmap_ctx->start == start &&\n\t\t    unmap_ctx->end == end)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic bool has_unmap_ctx(struct userfaultfd_ctx *ctx, struct list_head *unmaps,\n\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct userfaultfd_unmap_ctx *unmap_ctx;\n\n\tlist_for_each_entry(unmap_ctx, unmaps, list)\n\t\tif (unmap_ctx->ctx == ctx && unmap_ctx->start == start &&\n\t\t    unmap_ctx->end == end)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nint userfaultfd_unmap_prep(struct vm_area_struct *vma,\n\t\t\t   unsigned long start, unsigned long end,\n\t\t\t   struct list_head *unmaps)\n{\n\tfor ( ; vma && vma->vm_start < end; vma = vma->vm_next) {\n\t\tstruct userfaultfd_unmap_ctx *unmap_ctx;\n\t\tstruct userfaultfd_ctx *ctx = vma->vm_userfaultfd_ctx.ctx;\n\n\t\tif (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_UNMAP) ||\n\t\t    has_unmap_ctx(ctx, unmaps, start, end))\n\t\t\tcontinue;\n\n\t\tunmap_ctx = kzalloc(sizeof(*unmap_ctx), GFP_KERNEL);\n\t\tif (!unmap_ctx)\n\t\t\treturn -ENOMEM;\n\n\t\tuserfaultfd_ctx_get(ctx);\n\t\tWRITE_ONCE(ctx->mmap_changing, true);\n\t\tunmap_ctx->ctx = ctx;\n\t\tunmap_ctx->start = start;\n\t\tunmap_ctx->end = end;\n\t\tlist_add_tail(&unmap_ctx->list, unmaps);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "has_unmap_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "797-808",
    "snippet": "static bool has_unmap_ctx(struct userfaultfd_ctx *ctx, struct list_head *unmaps,\n\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct userfaultfd_unmap_ctx *unmap_ctx;\n\n\tlist_for_each_entry(unmap_ctx, unmaps, list)\n\t\tif (unmap_ctx->ctx == ctx && unmap_ctx->start == start &&\n\t\t    unmap_ctx->end == end)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "unmap_ctx",
            "unmaps",
            "list"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic bool has_unmap_ctx(struct userfaultfd_ctx *ctx, struct list_head *unmaps,\n\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct userfaultfd_unmap_ctx *unmap_ctx;\n\n\tlist_for_each_entry(unmap_ctx, unmaps, list)\n\t\tif (unmap_ctx->ctx == ctx && unmap_ctx->start == start &&\n\t\t    unmap_ctx->end == end)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "userfaultfd_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "771-795",
    "snippet": "bool userfaultfd_remove(struct vm_area_struct *vma,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct userfaultfd_ctx *ctx;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tctx = vma->vm_userfaultfd_ctx.ctx;\n\tif (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_REMOVE))\n\t\treturn true;\n\n\tuserfaultfd_ctx_get(ctx);\n\tWRITE_ONCE(ctx->mmap_changing, true);\n\tup_read(&mm->mmap_sem);\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_REMOVE;\n\tewq.msg.arg.remove.start = start;\n\tewq.msg.arg.remove.end = end;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_event_wait_completion",
          "args": [
            "ctx",
            "&ewq"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_event_wait_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "575-650",
          "snippet": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_init",
          "args": [
            "&ewq.msg"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "msg_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "171-179",
          "snippet": "static inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ctx->mmap_changing",
            "true"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_get",
          "args": [
            "ctx"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "141-145",
          "snippet": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nbool userfaultfd_remove(struct vm_area_struct *vma,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct userfaultfd_ctx *ctx;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tctx = vma->vm_userfaultfd_ctx.ctx;\n\tif (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_REMOVE))\n\t\treturn true;\n\n\tuserfaultfd_ctx_get(ctx);\n\tWRITE_ONCE(ctx->mmap_changing, true);\n\tup_read(&mm->mmap_sem);\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_REMOVE;\n\tewq.msg.arg.remove.start = start;\n\tewq.msg.arg.remove.end = end;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n\n\treturn false;\n}"
  },
  {
    "function_name": "mremap_userfaultfd_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "746-769",
    "snippet": "void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *vm_ctx,\n\t\t\t\t unsigned long from, unsigned long to,\n\t\t\t\t unsigned long len)\n{\n\tstruct userfaultfd_ctx *ctx = vm_ctx->ctx;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tif (!ctx)\n\t\treturn;\n\n\tif (to & ~PAGE_MASK) {\n\t\tuserfaultfd_ctx_put(ctx);\n\t\treturn;\n\t}\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_REMAP;\n\tewq.msg.arg.remap.from = from;\n\tewq.msg.arg.remap.to = to;\n\tewq.msg.arg.remap.len = len;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_event_wait_completion",
          "args": [
            "ctx",
            "&ewq"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_event_wait_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "575-650",
          "snippet": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_init",
          "args": [
            "&ewq.msg"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "msg_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "171-179",
          "snippet": "static inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_put",
          "args": [
            "ctx"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "155-169",
          "snippet": "static void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *userfaultfd_ctx_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nstatic void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nvoid mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *vm_ctx,\n\t\t\t\t unsigned long from, unsigned long to,\n\t\t\t\t unsigned long len)\n{\n\tstruct userfaultfd_ctx *ctx = vm_ctx->ctx;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tif (!ctx)\n\t\treturn;\n\n\tif (to & ~PAGE_MASK) {\n\t\tuserfaultfd_ctx_put(ctx);\n\t\treturn;\n\t}\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_REMAP;\n\tewq.msg.arg.remap.from = from;\n\tewq.msg.arg.remap.to = to;\n\tewq.msg.arg.remap.len = len;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n}"
  },
  {
    "function_name": "mremap_userfaultfd_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "733-744",
    "snippet": "void mremap_userfaultfd_prep(struct vm_area_struct *vma,\n\t\t\t     struct vm_userfaultfd_ctx *vm_ctx)\n{\n\tstruct userfaultfd_ctx *ctx;\n\n\tctx = vma->vm_userfaultfd_ctx.ctx;\n\tif (ctx && (ctx->features & UFFD_FEATURE_EVENT_REMAP)) {\n\t\tvm_ctx->ctx = ctx;\n\t\tuserfaultfd_ctx_get(ctx);\n\t\tWRITE_ONCE(ctx->mmap_changing, true);\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ctx->mmap_changing",
            "true"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_get",
          "args": [
            "ctx"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "141-145",
          "snippet": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nvoid mremap_userfaultfd_prep(struct vm_area_struct *vma,\n\t\t\t     struct vm_userfaultfd_ctx *vm_ctx)\n{\n\tstruct userfaultfd_ctx *ctx;\n\n\tctx = vma->vm_userfaultfd_ctx.ctx;\n\tif (ctx && (ctx->features & UFFD_FEATURE_EVENT_REMAP)) {\n\t\tvm_ctx->ctx = ctx;\n\t\tuserfaultfd_ctx_get(ctx);\n\t\tWRITE_ONCE(ctx->mmap_changing, true);\n\t}\n}"
  },
  {
    "function_name": "dup_userfaultfd_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "722-731",
    "snippet": "void dup_userfaultfd_complete(struct list_head *fcs)\n{\n\tstruct userfaultfd_fork_ctx *fctx, *n;\n\n\tlist_for_each_entry_safe(fctx, n, fcs, list) {\n\t\tdup_fctx(fctx);\n\t\tlist_del(&fctx->list);\n\t\tkfree(fctx);\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fctx"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&fctx->list"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_fctx",
          "args": [
            "fctx"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "dup_fctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "709-720",
          "snippet": "static void dup_fctx(struct userfaultfd_fork_ctx *fctx)\n{\n\tstruct userfaultfd_ctx *ctx = fctx->orig;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_FORK;\n\tewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void dup_fctx(struct userfaultfd_fork_ctx *fctx)\n{\n\tstruct userfaultfd_ctx *ctx = fctx->orig;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_FORK;\n\tewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "fctx",
            "n",
            "fcs",
            "list"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nvoid dup_userfaultfd_complete(struct list_head *fcs)\n{\n\tstruct userfaultfd_fork_ctx *fctx, *n;\n\n\tlist_for_each_entry_safe(fctx, n, fcs, list) {\n\t\tdup_fctx(fctx);\n\t\tlist_del(&fctx->list);\n\t\tkfree(fctx);\n\t}\n}"
  },
  {
    "function_name": "dup_fctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "709-720",
    "snippet": "static void dup_fctx(struct userfaultfd_fork_ctx *fctx)\n{\n\tstruct userfaultfd_ctx *ctx = fctx->orig;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_FORK;\n\tewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_event_wait_completion",
          "args": [
            "ctx",
            "&ewq"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_event_wait_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "575-650",
          "snippet": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_init",
          "args": [
            "&ewq.msg"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "msg_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "171-179",
          "snippet": "static inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void dup_fctx(struct userfaultfd_fork_ctx *fctx)\n{\n\tstruct userfaultfd_ctx *ctx = fctx->orig;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_FORK;\n\tewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n}"
  },
  {
    "function_name": "dup_userfaultfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "660-707",
    "snippet": "int dup_userfaultfd(struct vm_area_struct *vma, struct list_head *fcs)\n{\n\tstruct userfaultfd_ctx *ctx = NULL, *octx;\n\tstruct userfaultfd_fork_ctx *fctx;\n\n\toctx = vma->vm_userfaultfd_ctx.ctx;\n\tif (!octx || !(octx->features & UFFD_FEATURE_EVENT_FORK)) {\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(fctx, fcs, list)\n\t\tif (fctx->orig == octx) {\n\t\t\tctx = fctx->new;\n\t\t\tbreak;\n\t\t}\n\n\tif (!ctx) {\n\t\tfctx = kmalloc(sizeof(*fctx), GFP_KERNEL);\n\t\tif (!fctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);\n\t\tif (!ctx) {\n\t\t\tkfree(fctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tatomic_set(&ctx->refcount, 1);\n\t\tctx->flags = octx->flags;\n\t\tctx->state = UFFD_STATE_RUNNING;\n\t\tctx->features = octx->features;\n\t\tctx->released = false;\n\t\tctx->mmap_changing = false;\n\t\tctx->mm = vma->vm_mm;\n\t\tmmgrab(ctx->mm);\n\n\t\tuserfaultfd_ctx_get(octx);\n\t\tWRITE_ONCE(octx->mmap_changing, true);\n\t\tfctx->orig = octx;\n\t\tfctx->new = ctx;\n\t\tlist_add_tail(&fctx->list, fcs);\n\t}\n\n\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *userfaultfd_ctx_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fctx->list",
            "fcs"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "octx->mmap_changing",
            "true"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_get",
          "args": [
            "octx"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "141-145",
          "snippet": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "ctx->mm"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ctx->refcount",
            "1"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fctx"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "userfaultfd_ctx_cachep",
            "GFP_KERNEL"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fctx)",
            "GFP_KERNEL"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fctx",
            "fcs",
            "list"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nint dup_userfaultfd(struct vm_area_struct *vma, struct list_head *fcs)\n{\n\tstruct userfaultfd_ctx *ctx = NULL, *octx;\n\tstruct userfaultfd_fork_ctx *fctx;\n\n\toctx = vma->vm_userfaultfd_ctx.ctx;\n\tif (!octx || !(octx->features & UFFD_FEATURE_EVENT_FORK)) {\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(fctx, fcs, list)\n\t\tif (fctx->orig == octx) {\n\t\t\tctx = fctx->new;\n\t\t\tbreak;\n\t\t}\n\n\tif (!ctx) {\n\t\tfctx = kmalloc(sizeof(*fctx), GFP_KERNEL);\n\t\tif (!fctx)\n\t\t\treturn -ENOMEM;\n\n\t\tctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);\n\t\tif (!ctx) {\n\t\t\tkfree(fctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tatomic_set(&ctx->refcount, 1);\n\t\tctx->flags = octx->flags;\n\t\tctx->state = UFFD_STATE_RUNNING;\n\t\tctx->features = octx->features;\n\t\tctx->released = false;\n\t\tctx->mmap_changing = false;\n\t\tctx->mm = vma->vm_mm;\n\t\tmmgrab(ctx->mm);\n\n\t\tuserfaultfd_ctx_get(octx);\n\t\tWRITE_ONCE(octx->mmap_changing, true);\n\t\tfctx->orig = octx;\n\t\tfctx->new = ctx;\n\t\tlist_add_tail(&fctx->list, fcs);\n\t}\n\n\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\treturn 0;\n}"
  },
  {
    "function_name": "userfaultfd_event_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "652-658",
    "snippet": "static void userfaultfd_event_complete(struct userfaultfd_ctx *ctx,\n\t\t\t\t       struct userfaultfd_wait_queue *ewq)\n{\n\tewq->msg.event = 0;\n\twake_up_locked(&ctx->event_wqh);\n\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->event_wqh",
            "&ewq->wq"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ctx->event_wqh"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_event_complete(struct userfaultfd_ctx *ctx,\n\t\t\t\t       struct userfaultfd_wait_queue *ewq)\n{\n\tewq->msg.event = 0;\n\twake_up_locked(&ctx->event_wqh);\n\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n}"
  },
  {
    "function_name": "userfaultfd_event_wait_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "575-650",
    "snippet": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_ctx_put",
          "args": [
            "ctx"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "155-169",
          "snippet": "static void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *userfaultfd_ctx_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nstatic void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ctx->mmap_changing",
            "false"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->event_wqh.lock"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->event_wqh.lock"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&ctx->fd_wqh",
            "EPOLLIN"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ctx->event_wqh",
            "&ewq->wq"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ctx->released"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->event_wqh",
            "&ewq->wq"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_entry",
          "args": [
            "&ewq->wq",
            "current"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->flags & PF_EXITING"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}"
  },
  {
    "function_name": "handle_userfault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "343-573",
    "snippet": "vm_fault_t handle_userfault(struct vm_fault *vmf, unsigned long reason)\n{\n\tstruct mm_struct *mm = vmf->vma->vm_mm;\n\tstruct userfaultfd_ctx *ctx;\n\tstruct userfaultfd_wait_queue uwq;\n\tvm_fault_t ret = VM_FAULT_SIGBUS;\n\tbool must_wait, return_to_userland;\n\tlong blocking_state;\n\n\t/*\n\t * We don't do userfault handling for the final child pid update.\n\t *\n\t * We also don't do userfault handling during\n\t * coredumping. hugetlbfs has the special\n\t * follow_hugetlb_page() to skip missing pages in the\n\t * FOLL_DUMP case, anon memory also checks for FOLL_DUMP with\n\t * the no_page_table() helper in follow_page_mask(), but the\n\t * shmem_vm_ops->fault method is invoked even during\n\t * coredumping without mmap_sem and it ends up here.\n\t */\n\tif (current->flags & (PF_EXITING|PF_DUMPCORE))\n\t\tgoto out;\n\n\t/*\n\t * Coredumping runs without mmap_sem so we can only check that\n\t * the mmap_sem is held, if PF_DUMPCORE was not set.\n\t */\n\tWARN_ON_ONCE(!rwsem_is_locked(&mm->mmap_sem));\n\n\tctx = vmf->vma->vm_userfaultfd_ctx.ctx;\n\tif (!ctx)\n\t\tgoto out;\n\n\tBUG_ON(ctx->mm != mm);\n\n\tVM_BUG_ON(reason & ~(VM_UFFD_MISSING|VM_UFFD_WP));\n\tVM_BUG_ON(!(reason & VM_UFFD_MISSING) ^ !!(reason & VM_UFFD_WP));\n\n\tif (ctx->features & UFFD_FEATURE_SIGBUS)\n\t\tgoto out;\n\n\t/*\n\t * If it's already released don't get it. This avoids to loop\n\t * in __get_user_pages if userfaultfd_release waits on the\n\t * caller of handle_userfault to release the mmap_sem.\n\t */\n\tif (unlikely(READ_ONCE(ctx->released))) {\n\t\t/*\n\t\t * Don't return VM_FAULT_SIGBUS in this case, so a non\n\t\t * cooperative manager can close the uffd after the\n\t\t * last UFFDIO_COPY, without risking to trigger an\n\t\t * involuntary SIGBUS if the process was starting the\n\t\t * userfaultfd while the userfaultfd was still armed\n\t\t * (but after the last UFFDIO_COPY). If the uffd\n\t\t * wasn't already closed when the userfault reached\n\t\t * this point, that would normally be solved by\n\t\t * userfaultfd_must_wait returning 'false'.\n\t\t *\n\t\t * If we were to return VM_FAULT_SIGBUS here, the non\n\t\t * cooperative manager would be instead forced to\n\t\t * always call UFFDIO_UNREGISTER before it can safely\n\t\t * close the uffd.\n\t\t */\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check that we can return VM_FAULT_RETRY.\n\t *\n\t * NOTE: it should become possible to return VM_FAULT_RETRY\n\t * even if FAULT_FLAG_TRIED is set without leading to gup()\n\t * -EBUSY failures, if the userfaultfd is to be extended for\n\t * VM_UFFD_WP tracking and we intend to arm the userfault\n\t * without first stopping userland access to the memory. For\n\t * VM_UFFD_MISSING userfaults this is enough for now.\n\t */\n\tif (unlikely(!(vmf->flags & FAULT_FLAG_ALLOW_RETRY))) {\n\t\t/*\n\t\t * Validate the invariant that nowait must allow retry\n\t\t * to be sure not to return SIGBUS erroneously on\n\t\t * nowait invocations.\n\t\t */\n\t\tBUG_ON(vmf->flags & FAULT_FLAG_RETRY_NOWAIT);\n#ifdef CONFIG_DEBUG_VM\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"FAULT_FLAG_ALLOW_RETRY missing %x\\n\",\n\t\t\t       vmf->flags);\n\t\t\tdump_stack();\n\t\t}\n#endif\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle nowait, not much to do other than tell it to retry\n\t * and wait.\n\t */\n\tret = VM_FAULT_RETRY;\n\tif (vmf->flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\tgoto out;\n\n\t/* take the reference before dropping the mmap_sem */\n\tuserfaultfd_ctx_get(ctx);\n\n\tinit_waitqueue_func_entry(&uwq.wq, userfaultfd_wake_function);\n\tuwq.wq.private = current;\n\tuwq.msg = userfault_msg(vmf->address, vmf->flags, reason,\n\t\t\tctx->features);\n\tuwq.ctx = ctx;\n\tuwq.waken = false;\n\n\treturn_to_userland =\n\t\t(vmf->flags & (FAULT_FLAG_USER|FAULT_FLAG_KILLABLE)) ==\n\t\t(FAULT_FLAG_USER|FAULT_FLAG_KILLABLE);\n\tblocking_state = return_to_userland ? TASK_INTERRUPTIBLE :\n\t\t\t TASK_KILLABLE;\n\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->fault_pending_wqh, &uwq.wq);\n\t/*\n\t * The smp_mb() after __set_current_state prevents the reads\n\t * following the spin_unlock to happen before the list_add in\n\t * __add_wait_queue.\n\t */\n\tset_current_state(blocking_state);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\tif (!is_vm_hugetlb_page(vmf->vma))\n\t\tmust_wait = userfaultfd_must_wait(ctx, vmf->address, vmf->flags,\n\t\t\t\t\t\t  reason);\n\telse\n\t\tmust_wait = userfaultfd_huge_must_wait(ctx, vmf->vma,\n\t\t\t\t\t\t       vmf->address,\n\t\t\t\t\t\t       vmf->flags, reason);\n\tup_read(&mm->mmap_sem);\n\n\tif (likely(must_wait && !READ_ONCE(ctx->released) &&\n\t\t   (return_to_userland ? !signal_pending(current) :\n\t\t    !fatal_signal_pending(current)))) {\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tret |= VM_FAULT_MAJOR;\n\n\t\t/*\n\t\t * False wakeups can orginate even from rwsem before\n\t\t * up_read() however userfaults will wait either for a\n\t\t * targeted wakeup on the specific uwq waitqueue from\n\t\t * wake_userfault() or for signals or for uffd\n\t\t * release.\n\t\t */\n\t\twhile (!READ_ONCE(uwq.waken)) {\n\t\t\t/*\n\t\t\t * This needs the full smp_store_mb()\n\t\t\t * guarantee as the state write must be\n\t\t\t * visible to other CPUs before reading\n\t\t\t * uwq.waken from other CPUs.\n\t\t\t */\n\t\t\tset_current_state(blocking_state);\n\t\t\tif (READ_ONCE(uwq.waken) ||\n\t\t\t    READ_ONCE(ctx->released) ||\n\t\t\t    (return_to_userland ? signal_pending(current) :\n\t\t\t     fatal_signal_pending(current)))\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t}\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (return_to_userland) {\n\t\tif (signal_pending(current) &&\n\t\t    !fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * If we got a SIGSTOP or SIGCONT and this is\n\t\t\t * a normal userland page fault, just let\n\t\t\t * userland return so the signal will be\n\t\t\t * handled and gdb debugging works.  The page\n\t\t\t * fault code immediately after we return from\n\t\t\t * this function is going to release the\n\t\t\t * mmap_sem and it's not depending on it\n\t\t\t * (unlike gup would if we were not to return\n\t\t\t * VM_FAULT_RETRY).\n\t\t\t *\n\t\t\t * If a fatal signal is pending we still take\n\t\t\t * the streamlined VM_FAULT_RETRY failure path\n\t\t\t * and there's no need to retake the mmap_sem\n\t\t\t * in such case.\n\t\t\t */\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tret = VM_FAULT_NOPAGE;\n\t\t}\n\t}\n\n\t/*\n\t * Here we race with the list_del; list_add in\n\t * userfaultfd_ctx_read(), however because we don't ever run\n\t * list_del_init() to refile across the two lists, the prev\n\t * and next pointers will never point to self. list_add also\n\t * would never let any of the two pointers to point to\n\t * self. So list_empty_careful won't risk to see both pointers\n\t * pointing to self at any time during the list refile. The\n\t * only case where list_del_init() is called is the full\n\t * removal in the wake function and there we don't re-list_add\n\t * and it's fine not to block on the spinlock. The uwq on this\n\t * kernel stack can be released after the list_del_init.\n\t */\n\tif (!list_empty_careful(&uwq.wq.entry)) {\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\t/*\n\t\t * No need of list_del_init(), the uwq on the stack\n\t\t * will be freed shortly anyway.\n\t\t */\n\t\tlist_del(&uwq.wq.entry);\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\n\tuserfaultfd_ctx_put(ctx);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "userfaultfd_ctx_put",
          "args": [
            "ctx"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "155-169",
          "snippet": "static void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *userfaultfd_ctx_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nstatic void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&uwq.wq.entry"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&uwq.wq.entry"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ctx->released"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "uwq.waken"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "blocking_state"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "uwq.waken"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "&ctx->fd_wqh",
            "EPOLLIN"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "must_wait && !READ_ONCE(ctx->released) &&\n\t\t   (return_to_userland ? !signal_pending(current) :\n\t\t    !fatal_signal_pending(current))"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ctx->released"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_huge_must_wait",
          "args": [
            "ctx",
            "vmf->vma",
            "vmf->address",
            "vmf->flags",
            "reason"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_huge_must_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "250-257",
          "snippet": "static inline bool userfaultfd_huge_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\treturn false;\t/* should never get here */\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool userfaultfd_huge_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\treturn false;\t/* should never get here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "userfaultfd_must_wait",
          "args": [
            "ctx",
            "vmf->address",
            "vmf->flags",
            "reason"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_must_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "267-326",
          "snippet": "static inline bool userfaultfd_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tbool ret = true;\n\n\tVM_BUG_ON(!rwsem_is_locked(&mm->mmap_sem));\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * READ_ONCE must function as a barrier with narrower scope\n\t * and it must be equivalent to:\n\t *\t_pmd = *pmd; barrier();\n\t *\n\t * This is to deal with the instability (as in\n\t * pmd_trans_unstable) of the pmd.\n\t */\n\t_pmd = READ_ONCE(*pmd);\n\tif (pmd_none(_pmd))\n\t\tgoto out;\n\n\tret = false;\n\tif (!pmd_present(_pmd))\n\t\tgoto out;\n\n\tif (pmd_trans_huge(_pmd))\n\t\tgoto out;\n\n\t/*\n\t * the pmd is stable (as in !pmd_trans_unstable) so we can re-read it\n\t * and use the standard pte_offset_map() instead of parsing _pmd.\n\t */\n\tpte = pte_offset_map(pmd, address);\n\t/*\n\t * Lockless access: we're in a wait_event so it's ok if it\n\t * changes under us.\n\t */\n\tif (pte_none(*pte))\n\t\tret = true;\n\tpte_unmap(pte);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool userfaultfd_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tbool ret = true;\n\n\tVM_BUG_ON(!rwsem_is_locked(&mm->mmap_sem));\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * READ_ONCE must function as a barrier with narrower scope\n\t * and it must be equivalent to:\n\t *\t_pmd = *pmd; barrier();\n\t *\n\t * This is to deal with the instability (as in\n\t * pmd_trans_unstable) of the pmd.\n\t */\n\t_pmd = READ_ONCE(*pmd);\n\tif (pmd_none(_pmd))\n\t\tgoto out;\n\n\tret = false;\n\tif (!pmd_present(_pmd))\n\t\tgoto out;\n\n\tif (pmd_trans_huge(_pmd))\n\t\tgoto out;\n\n\t/*\n\t * the pmd is stable (as in !pmd_trans_unstable) so we can re-read it\n\t * and use the standard pte_offset_map() instead of parsing _pmd.\n\t */\n\tpte = pte_offset_map(pmd, address);\n\t/*\n\t * Lockless access: we're in a wait_event so it's ok if it\n\t * changes under us.\n\t */\n\tif (pte_none(*pte))\n\t\tret = true;\n\tpte_unmap(pte);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vmf->vma"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "blocking_state"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "&ctx->fault_pending_wqh",
            "&uwq.wq"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfault_msg",
          "args": [
            "vmf->address",
            "vmf->flags",
            "reason",
            "ctx->features"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "userfault_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "181-211",
          "snippet": "static inline struct uffd_msg userfault_msg(unsigned long address,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned long reason,\n\t\t\t\t\t    unsigned int features)\n{\n\tstruct uffd_msg msg;\n\tmsg_init(&msg);\n\tmsg.event = UFFD_EVENT_PAGEFAULT;\n\tmsg.arg.pagefault.address = address;\n\tif (flags & FAULT_FLAG_WRITE)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WRITE\n\t\t * was not set in a UFFD_EVENT_PAGEFAULT, it means it\n\t\t * was a read fault, otherwise if set it means it's\n\t\t * a write fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WRITE;\n\tif (reason & VM_UFFD_WP)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WP was\n\t\t * not set in a UFFD_EVENT_PAGEFAULT, it means it was\n\t\t * a missing fault, otherwise if set it means it's a\n\t\t * write protect fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WP;\n\tif (features & UFFD_FEATURE_THREAD_ID)\n\t\tmsg.arg.pagefault.feat.ptid = task_pid_vnr(current);\n\treturn msg;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct uffd_msg userfault_msg(unsigned long address,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned long reason,\n\t\t\t\t\t    unsigned int features)\n{\n\tstruct uffd_msg msg;\n\tmsg_init(&msg);\n\tmsg.event = UFFD_EVENT_PAGEFAULT;\n\tmsg.arg.pagefault.address = address;\n\tif (flags & FAULT_FLAG_WRITE)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WRITE\n\t\t * was not set in a UFFD_EVENT_PAGEFAULT, it means it\n\t\t * was a read fault, otherwise if set it means it's\n\t\t * a write fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WRITE;\n\tif (reason & VM_UFFD_WP)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WP was\n\t\t * not set in a UFFD_EVENT_PAGEFAULT, it means it was\n\t\t * a missing fault, otherwise if set it means it's a\n\t\t * write protect fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WP;\n\tif (features & UFFD_FEATURE_THREAD_ID)\n\t\tmsg.arg.pagefault.feat.ptid = task_pid_vnr(current);\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&uwq.wq",
            "userfaultfd_wake_function"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_ctx_get",
          "args": [
            "ctx"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "userfaultfd_ctx_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "141-145",
          "snippet": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t       \"FAULT_FLAG_ALLOW_RETRY missing %x\\n\"",
            "vmf->flags"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vmf->flags & FAULT_FLAG_RETRY_NOWAIT"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(vmf->flags & FAULT_FLAG_ALLOW_RETRY)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(ctx->released)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ctx->released"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!(reason & VM_UFFD_MISSING) ^ !!(reason & VM_UFFD_WP)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "reason & ~(VM_UFFD_MISSING|VM_UFFD_WP)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ctx->mm != mm"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rwsem_is_locked(&mm->mmap_sem)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nvm_fault_t handle_userfault(struct vm_fault *vmf, unsigned long reason)\n{\n\tstruct mm_struct *mm = vmf->vma->vm_mm;\n\tstruct userfaultfd_ctx *ctx;\n\tstruct userfaultfd_wait_queue uwq;\n\tvm_fault_t ret = VM_FAULT_SIGBUS;\n\tbool must_wait, return_to_userland;\n\tlong blocking_state;\n\n\t/*\n\t * We don't do userfault handling for the final child pid update.\n\t *\n\t * We also don't do userfault handling during\n\t * coredumping. hugetlbfs has the special\n\t * follow_hugetlb_page() to skip missing pages in the\n\t * FOLL_DUMP case, anon memory also checks for FOLL_DUMP with\n\t * the no_page_table() helper in follow_page_mask(), but the\n\t * shmem_vm_ops->fault method is invoked even during\n\t * coredumping without mmap_sem and it ends up here.\n\t */\n\tif (current->flags & (PF_EXITING|PF_DUMPCORE))\n\t\tgoto out;\n\n\t/*\n\t * Coredumping runs without mmap_sem so we can only check that\n\t * the mmap_sem is held, if PF_DUMPCORE was not set.\n\t */\n\tWARN_ON_ONCE(!rwsem_is_locked(&mm->mmap_sem));\n\n\tctx = vmf->vma->vm_userfaultfd_ctx.ctx;\n\tif (!ctx)\n\t\tgoto out;\n\n\tBUG_ON(ctx->mm != mm);\n\n\tVM_BUG_ON(reason & ~(VM_UFFD_MISSING|VM_UFFD_WP));\n\tVM_BUG_ON(!(reason & VM_UFFD_MISSING) ^ !!(reason & VM_UFFD_WP));\n\n\tif (ctx->features & UFFD_FEATURE_SIGBUS)\n\t\tgoto out;\n\n\t/*\n\t * If it's already released don't get it. This avoids to loop\n\t * in __get_user_pages if userfaultfd_release waits on the\n\t * caller of handle_userfault to release the mmap_sem.\n\t */\n\tif (unlikely(READ_ONCE(ctx->released))) {\n\t\t/*\n\t\t * Don't return VM_FAULT_SIGBUS in this case, so a non\n\t\t * cooperative manager can close the uffd after the\n\t\t * last UFFDIO_COPY, without risking to trigger an\n\t\t * involuntary SIGBUS if the process was starting the\n\t\t * userfaultfd while the userfaultfd was still armed\n\t\t * (but after the last UFFDIO_COPY). If the uffd\n\t\t * wasn't already closed when the userfault reached\n\t\t * this point, that would normally be solved by\n\t\t * userfaultfd_must_wait returning 'false'.\n\t\t *\n\t\t * If we were to return VM_FAULT_SIGBUS here, the non\n\t\t * cooperative manager would be instead forced to\n\t\t * always call UFFDIO_UNREGISTER before it can safely\n\t\t * close the uffd.\n\t\t */\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check that we can return VM_FAULT_RETRY.\n\t *\n\t * NOTE: it should become possible to return VM_FAULT_RETRY\n\t * even if FAULT_FLAG_TRIED is set without leading to gup()\n\t * -EBUSY failures, if the userfaultfd is to be extended for\n\t * VM_UFFD_WP tracking and we intend to arm the userfault\n\t * without first stopping userland access to the memory. For\n\t * VM_UFFD_MISSING userfaults this is enough for now.\n\t */\n\tif (unlikely(!(vmf->flags & FAULT_FLAG_ALLOW_RETRY))) {\n\t\t/*\n\t\t * Validate the invariant that nowait must allow retry\n\t\t * to be sure not to return SIGBUS erroneously on\n\t\t * nowait invocations.\n\t\t */\n\t\tBUG_ON(vmf->flags & FAULT_FLAG_RETRY_NOWAIT);\n#ifdef CONFIG_DEBUG_VM\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"FAULT_FLAG_ALLOW_RETRY missing %x\\n\",\n\t\t\t       vmf->flags);\n\t\t\tdump_stack();\n\t\t}\n#endif\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle nowait, not much to do other than tell it to retry\n\t * and wait.\n\t */\n\tret = VM_FAULT_RETRY;\n\tif (vmf->flags & FAULT_FLAG_RETRY_NOWAIT)\n\t\tgoto out;\n\n\t/* take the reference before dropping the mmap_sem */\n\tuserfaultfd_ctx_get(ctx);\n\n\tinit_waitqueue_func_entry(&uwq.wq, userfaultfd_wake_function);\n\tuwq.wq.private = current;\n\tuwq.msg = userfault_msg(vmf->address, vmf->flags, reason,\n\t\t\tctx->features);\n\tuwq.ctx = ctx;\n\tuwq.waken = false;\n\n\treturn_to_userland =\n\t\t(vmf->flags & (FAULT_FLAG_USER|FAULT_FLAG_KILLABLE)) ==\n\t\t(FAULT_FLAG_USER|FAULT_FLAG_KILLABLE);\n\tblocking_state = return_to_userland ? TASK_INTERRUPTIBLE :\n\t\t\t TASK_KILLABLE;\n\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->fault_pending_wqh, &uwq.wq);\n\t/*\n\t * The smp_mb() after __set_current_state prevents the reads\n\t * following the spin_unlock to happen before the list_add in\n\t * __add_wait_queue.\n\t */\n\tset_current_state(blocking_state);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\tif (!is_vm_hugetlb_page(vmf->vma))\n\t\tmust_wait = userfaultfd_must_wait(ctx, vmf->address, vmf->flags,\n\t\t\t\t\t\t  reason);\n\telse\n\t\tmust_wait = userfaultfd_huge_must_wait(ctx, vmf->vma,\n\t\t\t\t\t\t       vmf->address,\n\t\t\t\t\t\t       vmf->flags, reason);\n\tup_read(&mm->mmap_sem);\n\n\tif (likely(must_wait && !READ_ONCE(ctx->released) &&\n\t\t   (return_to_userland ? !signal_pending(current) :\n\t\t    !fatal_signal_pending(current)))) {\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tret |= VM_FAULT_MAJOR;\n\n\t\t/*\n\t\t * False wakeups can orginate even from rwsem before\n\t\t * up_read() however userfaults will wait either for a\n\t\t * targeted wakeup on the specific uwq waitqueue from\n\t\t * wake_userfault() or for signals or for uffd\n\t\t * release.\n\t\t */\n\t\twhile (!READ_ONCE(uwq.waken)) {\n\t\t\t/*\n\t\t\t * This needs the full smp_store_mb()\n\t\t\t * guarantee as the state write must be\n\t\t\t * visible to other CPUs before reading\n\t\t\t * uwq.waken from other CPUs.\n\t\t\t */\n\t\t\tset_current_state(blocking_state);\n\t\t\tif (READ_ONCE(uwq.waken) ||\n\t\t\t    READ_ONCE(ctx->released) ||\n\t\t\t    (return_to_userland ? signal_pending(current) :\n\t\t\t     fatal_signal_pending(current)))\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t}\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (return_to_userland) {\n\t\tif (signal_pending(current) &&\n\t\t    !fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * If we got a SIGSTOP or SIGCONT and this is\n\t\t\t * a normal userland page fault, just let\n\t\t\t * userland return so the signal will be\n\t\t\t * handled and gdb debugging works.  The page\n\t\t\t * fault code immediately after we return from\n\t\t\t * this function is going to release the\n\t\t\t * mmap_sem and it's not depending on it\n\t\t\t * (unlike gup would if we were not to return\n\t\t\t * VM_FAULT_RETRY).\n\t\t\t *\n\t\t\t * If a fatal signal is pending we still take\n\t\t\t * the streamlined VM_FAULT_RETRY failure path\n\t\t\t * and there's no need to retake the mmap_sem\n\t\t\t * in such case.\n\t\t\t */\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tret = VM_FAULT_NOPAGE;\n\t\t}\n\t}\n\n\t/*\n\t * Here we race with the list_del; list_add in\n\t * userfaultfd_ctx_read(), however because we don't ever run\n\t * list_del_init() to refile across the two lists, the prev\n\t * and next pointers will never point to self. list_add also\n\t * would never let any of the two pointers to point to\n\t * self. So list_empty_careful won't risk to see both pointers\n\t * pointing to self at any time during the list refile. The\n\t * only case where list_del_init() is called is the full\n\t * removal in the wake function and there we don't re-list_add\n\t * and it's fine not to block on the spinlock. The uwq on this\n\t * kernel stack can be released after the list_del_init.\n\t */\n\tif (!list_empty_careful(&uwq.wq.entry)) {\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\t/*\n\t\t * No need of list_del_init(), the uwq on the stack\n\t\t * will be freed shortly anyway.\n\t\t */\n\t\tlist_del(&uwq.wq.entry);\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\n\tuserfaultfd_ctx_put(ctx);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd_must_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "267-326",
    "snippet": "static inline bool userfaultfd_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tbool ret = true;\n\n\tVM_BUG_ON(!rwsem_is_locked(&mm->mmap_sem));\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * READ_ONCE must function as a barrier with narrower scope\n\t * and it must be equivalent to:\n\t *\t_pmd = *pmd; barrier();\n\t *\n\t * This is to deal with the instability (as in\n\t * pmd_trans_unstable) of the pmd.\n\t */\n\t_pmd = READ_ONCE(*pmd);\n\tif (pmd_none(_pmd))\n\t\tgoto out;\n\n\tret = false;\n\tif (!pmd_present(_pmd))\n\t\tgoto out;\n\n\tif (pmd_trans_huge(_pmd))\n\t\tgoto out;\n\n\t/*\n\t * the pmd is stable (as in !pmd_trans_unstable) so we can re-read it\n\t * and use the standard pte_offset_map() instead of parsing _pmd.\n\t */\n\tpte = pte_offset_map(pmd, address);\n\t/*\n\t * Lockless access: we're in a wait_event so it's ok if it\n\t * changes under us.\n\t */\n\tif (pte_none(*pte))\n\t\tret = true;\n\tpte_unmap(pte);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "address"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "_pmd"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "_pmd"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "_pmd"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pmd"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "address"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "address"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_present",
          "args": [
            "*p4d"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "address"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pgd"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "address"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!rwsem_is_locked(&mm->mmap_sem)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool userfaultfd_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tbool ret = true;\n\n\tVM_BUG_ON(!rwsem_is_locked(&mm->mmap_sem));\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * READ_ONCE must function as a barrier with narrower scope\n\t * and it must be equivalent to:\n\t *\t_pmd = *pmd; barrier();\n\t *\n\t * This is to deal with the instability (as in\n\t * pmd_trans_unstable) of the pmd.\n\t */\n\t_pmd = READ_ONCE(*pmd);\n\tif (pmd_none(_pmd))\n\t\tgoto out;\n\n\tret = false;\n\tif (!pmd_present(_pmd))\n\t\tgoto out;\n\n\tif (pmd_trans_huge(_pmd))\n\t\tgoto out;\n\n\t/*\n\t * the pmd is stable (as in !pmd_trans_unstable) so we can re-read it\n\t * and use the standard pte_offset_map() instead of parsing _pmd.\n\t */\n\tpte = pte_offset_map(pmd, address);\n\t/*\n\t * Lockless access: we're in a wait_event so it's ok if it\n\t * changes under us.\n\t */\n\tif (pte_none(*pte))\n\t\tret = true;\n\tpte_unmap(pte);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd_huge_must_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "250-257",
    "snippet": "static inline bool userfaultfd_huge_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\treturn false;\t/* should never get here */\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool userfaultfd_huge_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\treturn false;\t/* should never get here */\n}"
  },
  {
    "function_name": "userfaultfd_huge_must_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "218-248",
    "snippet": "static inline bool userfaultfd_huge_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tpte_t *ptep, pte;\n\tbool ret = true;\n\n\tVM_BUG_ON(!rwsem_is_locked(&mm->mmap_sem));\n\n\tptep = huge_pte_offset(mm, address, vma_mmu_pagesize(vma));\n\n\tif (!ptep)\n\t\tgoto out;\n\n\tret = false;\n\tpte = huge_ptep_get(ptep);\n\n\t/*\n\t * Lockless access: we're in a wait_event so it's ok if it\n\t * changes under us.\n\t */\n\tif (huge_pte_none(pte))\n\t\tret = true;\n\tif (!huge_pte_write(pte) && (reason & VM_UFFD_WP))\n\t\tret = true;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "huge_pte_write",
          "args": [
            "pte"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_none",
          "args": [
            "pte"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_ptep_get",
          "args": [
            "ptep"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_pte_offset",
          "args": [
            "mm",
            "address",
            "vma_mmu_pagesize(vma)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_mmu_pagesize",
          "args": [
            "vma"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!rwsem_is_locked(&mm->mmap_sem)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline bool userfaultfd_huge_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tpte_t *ptep, pte;\n\tbool ret = true;\n\n\tVM_BUG_ON(!rwsem_is_locked(&mm->mmap_sem));\n\n\tptep = huge_pte_offset(mm, address, vma_mmu_pagesize(vma));\n\n\tif (!ptep)\n\t\tgoto out;\n\n\tret = false;\n\tpte = huge_ptep_get(ptep);\n\n\t/*\n\t * Lockless access: we're in a wait_event so it's ok if it\n\t * changes under us.\n\t */\n\tif (huge_pte_none(pte))\n\t\tret = true;\n\tif (!huge_pte_write(pte) && (reason & VM_UFFD_WP))\n\t\tret = true;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfault_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "181-211",
    "snippet": "static inline struct uffd_msg userfault_msg(unsigned long address,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned long reason,\n\t\t\t\t\t    unsigned int features)\n{\n\tstruct uffd_msg msg;\n\tmsg_init(&msg);\n\tmsg.event = UFFD_EVENT_PAGEFAULT;\n\tmsg.arg.pagefault.address = address;\n\tif (flags & FAULT_FLAG_WRITE)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WRITE\n\t\t * was not set in a UFFD_EVENT_PAGEFAULT, it means it\n\t\t * was a read fault, otherwise if set it means it's\n\t\t * a write fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WRITE;\n\tif (reason & VM_UFFD_WP)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WP was\n\t\t * not set in a UFFD_EVENT_PAGEFAULT, it means it was\n\t\t * a missing fault, otherwise if set it means it's a\n\t\t * write protect fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WP;\n\tif (features & UFFD_FEATURE_THREAD_ID)\n\t\tmsg.arg.pagefault.feat.ptid = task_pid_vnr(current);\n\treturn msg;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg_init",
          "args": [
            "&msg"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "msg_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
          "lines": "171-179",
          "snippet": "static inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/bug.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline struct uffd_msg userfault_msg(unsigned long address,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned long reason,\n\t\t\t\t\t    unsigned int features)\n{\n\tstruct uffd_msg msg;\n\tmsg_init(&msg);\n\tmsg.event = UFFD_EVENT_PAGEFAULT;\n\tmsg.arg.pagefault.address = address;\n\tif (flags & FAULT_FLAG_WRITE)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WRITE\n\t\t * was not set in a UFFD_EVENT_PAGEFAULT, it means it\n\t\t * was a read fault, otherwise if set it means it's\n\t\t * a write fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WRITE;\n\tif (reason & VM_UFFD_WP)\n\t\t/*\n\t\t * If UFFD_FEATURE_PAGEFAULT_FLAG_WP was set in the\n\t\t * uffdio_api.features and UFFD_PAGEFAULT_FLAG_WP was\n\t\t * not set in a UFFD_EVENT_PAGEFAULT, it means it was\n\t\t * a missing fault, otherwise if set it means it's a\n\t\t * write protect fault.\n\t\t */\n\t\tmsg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WP;\n\tif (features & UFFD_FEATURE_THREAD_ID)\n\t\tmsg.arg.pagefault.feat.ptid = task_pid_vnr(current);\n\treturn msg;\n}"
  },
  {
    "function_name": "msg_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "171-179",
    "snippet": "static inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msg",
            "0",
            "sizeof(struct uffd_msg)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct uffd_msg) != 32"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic inline void msg_init(struct uffd_msg *msg)\n{\n\tBUILD_BUG_ON(sizeof(struct uffd_msg) != 32);\n\t/*\n\t * Must use memset to zero out the paddings or kernel data is\n\t * leaked to userland.\n\t */\n\tmemset(msg, 0, sizeof(struct uffd_msg));\n}"
  },
  {
    "function_name": "userfaultfd_ctx_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "155-169",
    "snippet": "static void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *userfaultfd_ctx_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "userfaultfd_ctx_cachep",
            "ctx"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "ctx->mm"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "waitqueue_active(&ctx->fd_wqh)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fd_wqh"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "spin_is_locked(&ctx->fd_wqh.lock)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&ctx->fd_wqh.lock"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "waitqueue_active(&ctx->event_wqh)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->event_wqh"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "spin_is_locked(&ctx->event_wqh.lock)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&ctx->event_wqh.lock"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "waitqueue_active(&ctx->fault_wqh)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fault_wqh"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "spin_is_locked(&ctx->fault_wqh.lock)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&ctx->fault_wqh.lock"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "waitqueue_active(&ctx->fault_pending_wqh)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->fault_pending_wqh"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "spin_is_locked(&ctx->fault_pending_wqh.lock)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&ctx->fault_pending_wqh.lock"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ctx->refcount"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\n\nstatic void userfaultfd_ctx_put(struct userfaultfd_ctx *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_pending_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_pending_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fault_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fault_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->event_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->event_wqh));\n\t\tVM_BUG_ON(spin_is_locked(&ctx->fd_wqh.lock));\n\t\tVM_BUG_ON(waitqueue_active(&ctx->fd_wqh));\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n}"
  },
  {
    "function_name": "userfaultfd_ctx_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "141-145",
    "snippet": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&ctx->refcount"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\tif (!atomic_inc_not_zero(&ctx->refcount))\n\t\tBUG();\n}"
  },
  {
    "function_name": "userfaultfd_wake_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "96-134",
    "snippet": "static int userfaultfd_wake_function(wait_queue_entry_t *wq, unsigned mode,\n\t\t\t\t     int wake_flags, void *key)\n{\n\tstruct userfaultfd_wake_range *range = key;\n\tint ret;\n\tstruct userfaultfd_wait_queue *uwq;\n\tunsigned long start, len;\n\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\n\tret = 0;\n\t/* len == 0 means wake all */\n\tstart = range->start;\n\tlen = range->len;\n\tif (len && (start > uwq->msg.arg.pagefault.address ||\n\t\t    start + len <= uwq->msg.arg.pagefault.address))\n\t\tgoto out;\n\tWRITE_ONCE(uwq->waken, true);\n\t/*\n\t * The Program-Order guarantees provided by the scheduler\n\t * ensure uwq->waken is visible before the task is woken.\n\t */\n\tret = wake_up_state(wq->private, mode);\n\tif (ret) {\n\t\t/*\n\t\t * Wake only once, autoremove behavior.\n\t\t *\n\t\t * After the effect of list_del_init is visible to the other\n\t\t * CPUs, the waitqueue may disappear from under us, see the\n\t\t * !list_empty_careful() in handle_userfault().\n\t\t *\n\t\t * try_to_wake_up() has an implicit smp_mb(), and the\n\t\t * wq->private is read before calling the extern function\n\t\t * \"wake_up_state\" (which in turns calls try_to_wake_up).\n\t\t */\n\t\tlist_del_init(&wq->entry);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wq->entry"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "wq->private",
            "mode"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "uwq->waken",
            "true"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wq",
            "structuserfaultfd_wait_queue",
            "wq"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic int userfaultfd_wake_function(wait_queue_entry_t *wq, unsigned mode,\n\t\t\t\t     int wake_flags, void *key)\n{\n\tstruct userfaultfd_wake_range *range = key;\n\tint ret;\n\tstruct userfaultfd_wait_queue *uwq;\n\tunsigned long start, len;\n\n\tuwq = container_of(wq, struct userfaultfd_wait_queue, wq);\n\tret = 0;\n\t/* len == 0 means wake all */\n\tstart = range->start;\n\tlen = range->len;\n\tif (len && (start > uwq->msg.arg.pagefault.address ||\n\t\t    start + len <= uwq->msg.arg.pagefault.address))\n\t\tgoto out;\n\tWRITE_ONCE(uwq->waken, true);\n\t/*\n\t * The Program-Order guarantees provided by the scheduler\n\t * ensure uwq->waken is visible before the task is woken.\n\t */\n\tret = wake_up_state(wq->private, mode);\n\tif (ret) {\n\t\t/*\n\t\t * Wake only once, autoremove behavior.\n\t\t *\n\t\t * After the effect of list_del_init is visible to the other\n\t\t * CPUs, the waitqueue may disappear from under us, see the\n\t\t * !list_empty_careful() in handle_userfault().\n\t\t *\n\t\t * try_to_wake_up() has an implicit smp_mb(), and the\n\t\t * wq->private is read before calling the extern function\n\t\t * \"wake_up_state\" (which in turns calls try_to_wake_up).\n\t\t */\n\t\tlist_del_init(&wq->entry);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "userfaultfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/userfaultfd.c",
    "lines": "1896-1931",
    "snippet": "SYSCALL_DEFINE1(userfaultfd, int, flags)\n{\n\tstruct userfaultfd_ctx *ctx;\n\tint fd;\n\n\tBUG_ON(!current->mm);\n\n\t/* Check the UFFD_* constants for consistency.  */\n\tBUILD_BUG_ON(UFFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(UFFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~UFFD_SHARED_FCNTL_FLAGS)\n\t\treturn -EINVAL;\n\n\tctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&ctx->refcount, 1);\n\tctx->flags = flags;\n\tctx->features = 0;\n\tctx->state = UFFD_STATE_WAIT_API;\n\tctx->released = false;\n\tctx->mmap_changing = false;\n\tctx->mm = current->mm;\n\t/* prevent the mm struct to be freed */\n\tmmgrab(ctx->mm);\n\n\tfd = anon_inode_getfd(\"[userfaultfd]\", &userfaultfd_fops, ctx,\n\t\t\t      O_RDWR | (flags & UFFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0) {\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n\treturn fd;\n}",
    "includes": [
      "#include <linux/hugetlb.h>",
      "#include <linux/security.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/bug.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *userfaultfd_ctx_cachep",
      "static const struct file_operations userfaultfd_fops;",
      "static const struct file_operations userfaultfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= userfaultfd_show_fdinfo,\n#endif\n\t.release\t= userfaultfd_release,\n\t.poll\t\t= userfaultfd_poll,\n\t.read\t\t= userfaultfd_read,\n\t.unlocked_ioctl = userfaultfd_ioctl,\n\t.compat_ioctl\t= userfaultfd_ioctl,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/ioctl.h>\n#include <linux/mempolicy.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/hashtable.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *userfaultfd_ctx_cachep;\nstatic const struct file_operations userfaultfd_fops;\nstatic const struct file_operations userfaultfd_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= userfaultfd_show_fdinfo,\n#endif\n\t.release\t= userfaultfd_release,\n\t.poll\t\t= userfaultfd_poll,\n\t.read\t\t= userfaultfd_read,\n\t.unlocked_ioctl = userfaultfd_ioctl,\n\t.compat_ioctl\t= userfaultfd_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nSYSCALL_DEFINE1(userfaultfd, int, flags)\n{\n\tstruct userfaultfd_ctx *ctx;\n\tint fd;\n\n\tBUG_ON(!current->mm);\n\n\t/* Check the UFFD_* constants for consistency.  */\n\tBUILD_BUG_ON(UFFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(UFFD_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~UFFD_SHARED_FCNTL_FLAGS)\n\t\treturn -EINVAL;\n\n\tctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&ctx->refcount, 1);\n\tctx->flags = flags;\n\tctx->features = 0;\n\tctx->state = UFFD_STATE_WAIT_API;\n\tctx->released = false;\n\tctx->mmap_changing = false;\n\tctx->mm = current->mm;\n\t/* prevent the mm struct to be freed */\n\tmmgrab(ctx->mm);\n\n\tfd = anon_inode_getfd(\"[userfaultfd]\", &userfaultfd_fops, ctx,\n\t\t\t      O_RDWR | (flags & UFFD_SHARED_FCNTL_FLAGS));\n\tif (fd < 0) {\n\t\tmmdrop(ctx->mm);\n\t\tkmem_cache_free(userfaultfd_ctx_cachep, ctx);\n\t}\n\treturn fd;\n}"
  }
]