[
  {
    "function_name": "files_maxfiles_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "380-389",
    "snippet": "void __init files_maxfiles_init(void)\n{\n\tunsigned long n;\n\tunsigned long memreserve = (totalram_pages - nr_free_pages()) * 3/2;\n\n\tmemreserve = min(memreserve, totalram_pages - 1);\n\tn = ((totalram_pages - memreserve) * (PAGE_SIZE / 1024)) / 10;\n\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "n",
            "NR_FILE"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "memreserve",
            "totalram_pages - 1"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_free_pages",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\n\nvoid __init files_maxfiles_init(void)\n{\n\tunsigned long n;\n\tunsigned long memreserve = (totalram_pages - nr_free_pages()) * 3/2;\n\n\tmemreserve = min(memreserve, totalram_pages - 1);\n\tn = ((totalram_pages - memreserve) * (PAGE_SIZE / 1024)) / 10;\n\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n}"
  },
  {
    "function_name": "files_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "369-374",
    "snippet": "void __init files_init(void)\n{\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, NULL);\n\tpercpu_counter_init(&nr_files, 0, GFP_KERNEL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *filp_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&nr_files",
            "0",
            "GFP_KERNEL"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"filp\"",
            "sizeof(struct file)",
            "0",
            "SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *filp_cachep;\n\nvoid __init files_init(void)\n{\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, NULL);\n\tpercpu_counter_init(&nr_files, 0, GFP_KERNEL);\n}"
  },
  {
    "function_name": "__fput_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "358-365",
    "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fput",
          "args": [
            "file"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(task->flags & PF_KTHREAD)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_and_test",
          "args": [
            "&file->f_count"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
  },
  {
    "function_name": "fput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "329-348",
    "snippet": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t\t/*\n\t\t\t * After this task has run exit_task_work(),\n\t\t\t * task_work_add() will fail.  Fall through to delayed\n\t\t\t * fput to avoid leaking *file.\n\t\t\t */\n\t\t}\n\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_delayed_work(&delayed_fput_work, 1);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LLIST_HEAD(delayed_fput_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&delayed_fput_work",
            "1"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&file->f_u.fu_llist",
            "&delayed_fput_list"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "task",
            "&file->f_u.fu_rcuhead",
            "true"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "&file->f_u.fu_rcuhead",
            "____fput"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!in_interrupt() && !(task->flags & PF_KTHREAD)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_and_test",
          "args": [
            "&file->f_count"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic LLIST_HEAD(delayed_fput_list);\n\nvoid fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t\t/*\n\t\t\t * After this task has run exit_task_work(),\n\t\t\t * task_work_add() will fail.  Fall through to delayed\n\t\t\t * fput to avoid leaking *file.\n\t\t\t */\n\t\t}\n\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_delayed_work(&delayed_fput_work, 1);\n\t}\n}"
  },
  {
    "function_name": "flush_delayed_fput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "322-325",
    "snippet": "void flush_delayed_fput(void)\n{\n\tdelayed_fput(NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delayed_fput",
          "args": [
            "NULL"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_fput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "298-305",
          "snippet": "static void delayed_fput(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&delayed_fput_list);\n\tstruct file *f, *t;\n\n\tllist_for_each_entry_safe(f, t, node, f_u.fu_llist)\n\t\t__fput(f);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LLIST_HEAD(delayed_fput_list);",
            "static DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic LLIST_HEAD(delayed_fput_list);\nstatic DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);\n\nstatic void delayed_fput(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&delayed_fput_list);\n\tstruct file *f, *t;\n\n\tllist_for_each_entry_safe(f, t, node, f_u.fu_llist)\n\t\t__fput(f);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);\n\nvoid flush_delayed_fput(void)\n{\n\tdelayed_fput(NULL);\n}"
  },
  {
    "function_name": "____fput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "307-310",
    "snippet": "static void ____fput(struct callback_head *work)\n{\n\t__fput(container_of(work, struct file, f_u.fu_rcuhead));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic void ____fput(struct callback_head *work)\n{\n\t__fput(container_of(work, struct file, f_u.fu_rcuhead));\n}"
  },
  {
    "function_name": "delayed_fput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "298-305",
    "snippet": "static void delayed_fput(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&delayed_fput_list);\n\tstruct file *f, *t;\n\n\tllist_for_each_entry_safe(f, t, node, f_u.fu_llist)\n\t\t__fput(f);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LLIST_HEAD(delayed_fput_list);",
      "static DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fput",
          "args": [
            "f"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "f",
            "t",
            "node",
            "f_u.fu_llist"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&delayed_fput_list"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic LLIST_HEAD(delayed_fput_list);\nstatic DECLARE_DELAYED_WORK(delayed_fput_work, delayed_fput);\n\nstatic void delayed_fput(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&delayed_fput_list);\n\tstruct file *f, *t;\n\n\tllist_for_each_entry_safe(f, t, node, f_u.fu_llist)\n\t\t__fput(f);\n}"
  },
  {
    "function_name": "__fput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "253-295",
    "snippet": "static void __fput(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct vfsmount *mnt = file->f_path.mnt;\n\tstruct inode *inode = file->f_inode;\n\n\tif (unlikely(!(file->f_mode & FMODE_OPENED)))\n\t\tgoto out;\n\n\tmight_sleep();\n\n\tfsnotify_close(file);\n\t/*\n\t * The function eventpoll_release() should be the first called\n\t * in the file cleanup chain.\n\t */\n\teventpoll_release(file);\n\tlocks_remove_file(file);\n\n\tima_file_free(file);\n\tif (unlikely(file->f_flags & FASYNC)) {\n\t\tif (file->f_op->fasync)\n\t\t\tfile->f_op->fasync(-1, file, 0);\n\t}\n\tif (file->f_op->release)\n\t\tfile->f_op->release(inode, file);\n\tif (unlikely(S_ISCHR(inode->i_mode) && inode->i_cdev != NULL &&\n\t\t     !(file->f_mode & FMODE_PATH))) {\n\t\tcdev_put(inode->i_cdev);\n\t}\n\tfops_put(file->f_op);\n\tput_pid(file->f_owner.pid);\n\tif ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_dec(inode);\n\tif (file->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(mnt);\n\t}\n\tdput(dentry);\n\tmntput(mnt);\nout:\n\tfile_free(file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_free",
          "args": [
            "file"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "file_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "52-58",
          "snippet": "static inline void file_free(struct file *f)\n{\n\tsecurity_file_free(f);\n\tif (!(f->f_mode & FMODE_NOACCOUNT))\n\t\tpercpu_counter_dec(&nr_files);\n\tcall_rcu(&f->f_u.fu_rcuhead, file_free_rcu);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic inline void file_free(struct file *f)\n{\n\tsecurity_file_free(f);\n\tif (!(f->f_mode & FMODE_NOACCOUNT))\n\t\tpercpu_counter_dec(&nr_files);\n\tcall_rcu(&f->f_u.fu_rcuhead, file_free_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1180-1189",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_drop_write",
          "args": [
            "mnt"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "456-459",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_readcount_dec",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "file->f_owner.pid"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fops_put",
          "args": [
            "file->f_op"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cdev_put",
          "args": [
            "inode->i_cdev"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "cdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/char_dev.c",
          "lines": "364-371",
          "snippet": "void cdev_put(struct cdev *p)\n{\n\tif (p) {\n\t\tstruct module *owner = p->owner;\n\t\tkobject_put(&p->kobj);\n\t\tmodule_put(owner);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid cdev_put(struct cdev *p)\n{\n\tif (p) {\n\t\tstruct module *owner = p->owner;\n\t\tkobject_put(&p->kobj);\n\t\tmodule_put(owner);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "S_ISCHR(inode->i_mode) && inode->i_cdev != NULL &&\n\t\t     !(file->f_mode & FMODE_PATH)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->release",
          "args": [
            "inode",
            "file"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->fasync",
          "args": [
            "-1",
            "file",
            "0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "file->f_flags & FASYNC"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_file_free",
          "args": [
            "file"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_remove_file",
          "args": [
            "file"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "locks_remove_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "2548-2570",
          "snippet": "void locks_remove_file(struct file *filp)\n{\n\tstruct file_lock_context *ctx;\n\n\tctx = smp_load_acquire(&locks_inode(filp)->i_flctx);\n\tif (!ctx)\n\t\treturn;\n\n\t/* remove any OFD locks */\n\tlocks_remove_posix(filp, filp);\n\n\t/* remove flock locks */\n\tlocks_remove_flock(filp, ctx);\n\n\t/* remove any leases */\n\tlocks_remove_lease(filp, ctx);\n\n\tspin_lock(&ctx->flc_lock);\n\tlocks_check_ctx_file_list(filp, &ctx->flc_posix, \"POSIX\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_flock, \"FLOCK\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_lease, \"LEASE\");\n\tspin_unlock(&ctx->flc_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_remove_file(struct file *filp)\n{\n\tstruct file_lock_context *ctx;\n\n\tctx = smp_load_acquire(&locks_inode(filp)->i_flctx);\n\tif (!ctx)\n\t\treturn;\n\n\t/* remove any OFD locks */\n\tlocks_remove_posix(filp, filp);\n\n\t/* remove flock locks */\n\tlocks_remove_flock(filp, ctx);\n\n\t/* remove any leases */\n\tlocks_remove_lease(filp, ctx);\n\n\tspin_lock(&ctx->flc_lock);\n\tlocks_check_ctx_file_list(filp, &ctx->flc_posix, \"POSIX\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_flock, \"FLOCK\");\n\tlocks_check_ctx_file_list(filp, &ctx->flc_lease, \"LEASE\");\n\tspin_unlock(&ctx->flc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eventpoll_release",
          "args": [
            "file"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "eventpoll_release_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "985-1011",
          "snippet": "void eventpoll_release_file(struct file *file)\n{\n\tstruct eventpoll *ep;\n\tstruct epitem *epi, *next;\n\n\t/*\n\t * We don't want to get \"file->f_lock\" because it is not\n\t * necessary. It is not necessary because we're in the \"struct file\"\n\t * cleanup path, and this means that no one is using this file anymore.\n\t * So, for example, epoll_ctl() cannot hit here since if we reach this\n\t * point, the file counter already went to zero and fget() would fail.\n\t * The only hit might come from ep_free() but by holding the mutex\n\t * will correctly serialize the operation. We do need to acquire\n\t * \"ep->mtx\" after \"epmutex\" because ep_remove() requires it when called\n\t * from anywhere but ep_free().\n\t *\n\t * Besides, ep_remove() acquires the lock, so we can't hold it here.\n\t */\n\tmutex_lock(&epmutex);\n\tlist_for_each_entry_safe(epi, next, &file->f_ep_links, fllink) {\n\t\tep = epi->ep;\n\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\tep_remove(ep, epi);\n\t\tmutex_unlock(&ep->mtx);\n\t}\n\tmutex_unlock(&epmutex);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(epmutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nvoid eventpoll_release_file(struct file *file)\n{\n\tstruct eventpoll *ep;\n\tstruct epitem *epi, *next;\n\n\t/*\n\t * We don't want to get \"file->f_lock\" because it is not\n\t * necessary. It is not necessary because we're in the \"struct file\"\n\t * cleanup path, and this means that no one is using this file anymore.\n\t * So, for example, epoll_ctl() cannot hit here since if we reach this\n\t * point, the file counter already went to zero and fget() would fail.\n\t * The only hit might come from ep_free() but by holding the mutex\n\t * will correctly serialize the operation. We do need to acquire\n\t * \"ep->mtx\" after \"epmutex\" because ep_remove() requires it when called\n\t * from anywhere but ep_free().\n\t *\n\t * Besides, ep_remove() acquires the lock, so we can't hold it here.\n\t */\n\tmutex_lock(&epmutex);\n\tlist_for_each_entry_safe(epi, next, &file->f_ep_links, fllink) {\n\t\tep = epi->ep;\n\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\tep_remove(ep, epi);\n\t\tmutex_unlock(&ep->mtx);\n\t}\n\tmutex_unlock(&epmutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_close",
          "args": [
            "file"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(file->f_mode & FMODE_OPENED)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic void __fput(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct vfsmount *mnt = file->f_path.mnt;\n\tstruct inode *inode = file->f_inode;\n\n\tif (unlikely(!(file->f_mode & FMODE_OPENED)))\n\t\tgoto out;\n\n\tmight_sleep();\n\n\tfsnotify_close(file);\n\t/*\n\t * The function eventpoll_release() should be the first called\n\t * in the file cleanup chain.\n\t */\n\teventpoll_release(file);\n\tlocks_remove_file(file);\n\n\tima_file_free(file);\n\tif (unlikely(file->f_flags & FASYNC)) {\n\t\tif (file->f_op->fasync)\n\t\t\tfile->f_op->fasync(-1, file, 0);\n\t}\n\tif (file->f_op->release)\n\t\tfile->f_op->release(inode, file);\n\tif (unlikely(S_ISCHR(inode->i_mode) && inode->i_cdev != NULL &&\n\t\t     !(file->f_mode & FMODE_PATH))) {\n\t\tcdev_put(inode->i_cdev);\n\t}\n\tfops_put(file->f_op);\n\tput_pid(file->f_owner.pid);\n\tif ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_dec(inode);\n\tif (file->f_mode & FMODE_WRITER) {\n\t\tput_write_access(inode);\n\t\t__mnt_drop_write(mnt);\n\t}\n\tdput(dentry);\n\tmntput(mnt);\nout:\n\tfile_free(file);\n}"
  },
  {
    "function_name": "alloc_file_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "240-249",
    "snippet": "struct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&f->f_path"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "469-473",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file",
          "args": [
            "&base->f_path",
            "flags",
            "fops"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "240-249",
          "snippet": "struct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}"
  },
  {
    "function_name": "alloc_file_pseudo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "213-237",
    "snippet": "struct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "402-405",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file",
          "args": [
            "&path",
            "flags",
            "fops"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "240-249",
          "snippet": "struct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file_clone(struct file *base, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct file *f = alloc_file(&base->f_path, flags, fops);\n\tif (!IS_ERR(f)) {\n\t\tpath_get(&f->f_path);\n\t\tf->f_mapping = base->f_mapping;\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "path.dentry",
            "inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1937-1940",
          "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "mnt"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1192-1197",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "path.dentry",
            "&anon_ops"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1736-1763",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc_pseudo",
          "args": [
            "mnt->mnt_sb",
            "&this"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1720-1723",
          "snippet": "struct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "name",
            "strlen(name)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "alloc_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "187-211",
    "snippet": "static struct file *alloc_file(const struct path *path, int flags,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = alloc_empty_file(flags, current_cred());\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tfile->f_wb_err = filemap_sample_wb_err(file->f_mapping);\n\tif ((file->f_mode & FMODE_READ) &&\n\t     likely(fop->read || fop->read_iter))\n\t\tfile->f_mode |= FMODE_CAN_READ;\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->write_iter))\n\t\tfile->f_mode |= FMODE_CAN_WRITE;\n\tfile->f_mode |= FMODE_OPENED;\n\tfile->f_op = fop;\n\tif ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_readcount_inc",
          "args": [
            "path->dentry->d_inode"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fop->write || fop->write_iter"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fop->read || fop->read_iter"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_sample_wb_err",
          "args": [
            "file->f_mapping"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_empty_file",
          "args": [
            "flags",
            "current_cred()"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_empty_file_noaccount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "170-178",
          "snippet": "struct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct file *alloc_file(const struct path *path, int flags,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = alloc_empty_file(flags, current_cred());\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tfile->f_wb_err = filemap_sample_wb_err(file->f_mapping);\n\tif ((file->f_mode & FMODE_READ) &&\n\t     likely(fop->read || fop->read_iter))\n\t\tfile->f_mode |= FMODE_CAN_READ;\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->write_iter))\n\t\tfile->f_mode |= FMODE_CAN_WRITE;\n\tfile->f_mode |= FMODE_OPENED;\n\tfile->f_op = fop;\n\tif ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}"
  },
  {
    "function_name": "alloc_empty_file_noaccount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "170-178",
    "snippet": "struct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_file",
          "args": [
            "flags",
            "cred"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "95-121",
          "snippet": "static struct file *__alloc_file(int flags, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free_rcu(&f->f_u.fu_rcuhead);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\tf->f_flags = flags;\n\tf->f_mode = OPEN_FMODE(flags);\n\t/* f->f_version: 0 */\n\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filp_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *filp_cachep;\n\nstatic struct file *__alloc_file(int flags, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free_rcu(&f->f_u.fu_rcuhead);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\tf->f_flags = flags;\n\tf->f_mode = OPEN_FMODE(flags);\n\t/* f->f_version: 0 */\n\n\treturn f;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_empty_file_noaccount(int flags, const struct cred *cred)\n{\n\tstruct file *f = __alloc_file(flags, cred);\n\n\tif (!IS_ERR(f))\n\t\tf->f_mode |= FMODE_NOACCOUNT;\n\n\treturn f;\n}"
  },
  {
    "function_name": "alloc_empty_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "133-163",
    "snippet": "struct file *alloc_empty_file(int flags, const struct cred *cred)\n{\n\tstatic long old_max;\n\tstruct file *f;\n\n\t/*\n\t * Privileged users can go above max_files\n\t */\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * percpu_counters are inaccurate.  Do an expensive check before\n\t\t * we go and fail.\n\t\t */\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\n\tf = __alloc_file(flags, cred);\n\tif (!IS_ERR(f))\n\t\tpercpu_counter_inc(&nr_files);\n\n\treturn f;\n\nover:\n\t/* Ran out of filps - report that */\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENFILE"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_files",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "63-66",
          "snippet": "static long get_nr_files(void)\n{\n\treturn percpu_counter_read_positive(&nr_files);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic long get_nr_files(void)\n{\n\treturn percpu_counter_read_positive(&nr_files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"VFS: file-max limit %lu reached\\n\"",
            "get_max_files()"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_max_files",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "71-74",
          "snippet": "unsigned long get_max_files(void)\n{\n\treturn files_stat.max_files;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\n\nunsigned long get_max_files(void)\n{\n\treturn files_stat.max_files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_inc",
          "args": [
            "&nr_files"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_file",
          "args": [
            "flags",
            "cred"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "95-121",
          "snippet": "static struct file *__alloc_file(int flags, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free_rcu(&f->f_u.fu_rcuhead);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\tf->f_flags = flags;\n\tf->f_mode = OPEN_FMODE(flags);\n\t/* f->f_version: 0 */\n\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filp_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *filp_cachep;\n\nstatic struct file *__alloc_file(int flags, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free_rcu(&f->f_u.fu_rcuhead);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\tf->f_flags = flags;\n\tf->f_mode = OPEN_FMODE(flags);\n\t/* f->f_version: 0 */\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum_positive",
          "args": [
            "&nr_files"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\n\nstruct file *alloc_empty_file(int flags, const struct cred *cred)\n{\n\tstatic long old_max;\n\tstruct file *f;\n\n\t/*\n\t * Privileged users can go above max_files\n\t */\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * percpu_counters are inaccurate.  Do an expensive check before\n\t\t * we go and fail.\n\t\t */\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\n\tf = __alloc_file(flags, cred);\n\tif (!IS_ERR(f))\n\t\tpercpu_counter_inc(&nr_files);\n\n\treturn f;\n\nover:\n\t/* Ran out of filps - report that */\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}"
  },
  {
    "function_name": "__alloc_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "95-121",
    "snippet": "static struct file *__alloc_file(int flags, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free_rcu(&f->f_u.fu_rcuhead);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\tf->f_flags = flags;\n\tf->f_mode = OPEN_FMODE(flags);\n\t/* f->f_version: 0 */\n\n\treturn f;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *filp_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "flags"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventpoll_init_file",
          "args": [
            "f"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&f->f_pos_lock"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&f->f_lock"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&f->f_owner.lock"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&f->f_count",
            "1"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_free_rcu",
          "args": [
            "&f->f_u.fu_rcuhead"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "file_free_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "44-50",
          "snippet": "static void file_free_rcu(struct rcu_head *head)\n{\n\tstruct file *f = container_of(head, struct file, f_u.fu_rcuhead);\n\n\tput_cred(f->f_cred);\n\tkmem_cache_free(filp_cachep, f);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *filp_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *filp_cachep;\n\nstatic void file_free_rcu(struct rcu_head *head)\n{\n\tstruct file *f = container_of(head, struct file, f_u.fu_rcuhead);\n\n\tput_cred(f->f_cred);\n\tkmem_cache_free(filp_cachep, f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_file_alloc",
          "args": [
            "f"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "cred"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cifs/smb1ops.c",
          "lines": "145-149",
          "snippet": "static unsigned int\ncifs_get_credits(struct mid_q_entry *mid)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_get_credits(struct mid_q_entry *mid)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!f"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "filp_cachep",
            "GFP_KERNEL"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *filp_cachep;\n\nstatic struct file *__alloc_file(int flags, const struct cred *cred)\n{\n\tstruct file *f;\n\tint error;\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free_rcu(&f->f_u.fu_rcuhead);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\tmutex_init(&f->f_pos_lock);\n\teventpoll_init_file(f);\n\tf->f_flags = flags;\n\tf->f_mode = OPEN_FMODE(flags);\n\t/* f->f_version: 0 */\n\n\treturn f;\n}"
  },
  {
    "function_name": "proc_nr_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "88-92",
    "snippet": "int proc_nr_files(struct ctl_table *table, int write,\n                     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nint proc_nr_files(struct ctl_table *table, int write,\n                     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "proc_nr_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "81-86",
    "snippet": "int proc_nr_files(struct ctl_table *table, int write,\n                     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tfiles_stat.nr_files = get_nr_files();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_files",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "63-66",
          "snippet": "static long get_nr_files(void)\n{\n\treturn percpu_counter_read_positive(&nr_files);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic long get_nr_files(void)\n{\n\treturn percpu_counter_read_positive(&nr_files);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\n\nint proc_nr_files(struct ctl_table *table, int write,\n                     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tfiles_stat.nr_files = get_nr_files();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "get_max_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "71-74",
    "snippet": "unsigned long get_max_files(void)\n{\n\treturn files_stat.max_files;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\n\nunsigned long get_max_files(void)\n{\n\treturn files_stat.max_files;\n}"
  },
  {
    "function_name": "get_nr_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "63-66",
    "snippet": "static long get_nr_files(void)\n{\n\treturn percpu_counter_read_positive(&nr_files);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&nr_files"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic long get_nr_files(void)\n{\n\treturn percpu_counter_read_positive(&nr_files);\n}"
  },
  {
    "function_name": "file_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "52-58",
    "snippet": "static inline void file_free(struct file *f)\n{\n\tsecurity_file_free(f);\n\tif (!(f->f_mode & FMODE_NOACCOUNT))\n\t\tpercpu_counter_dec(&nr_files);\n\tcall_rcu(&f->f_u.fu_rcuhead, file_free_rcu);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&f->f_u.fu_rcuhead",
            "file_free_rcu"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_dec",
          "args": [
            "&nr_files"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_file_free",
          "args": [
            "f"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic inline void file_free(struct file *f)\n{\n\tsecurity_file_free(f);\n\tif (!(f->f_mode & FMODE_NOACCOUNT))\n\t\tpercpu_counter_dec(&nr_files);\n\tcall_rcu(&f->f_u.fu_rcuhead, file_free_rcu);\n}"
  },
  {
    "function_name": "file_free_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
    "lines": "44-50",
    "snippet": "static void file_free_rcu(struct rcu_head *head)\n{\n\tstruct file *f = container_of(head, struct file, f_u.fu_rcuhead);\n\n\tput_cred(f->f_cred);\n\tkmem_cache_free(filp_cachep, f);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/atomic.h>",
      "#include <linux/swap.h>",
      "#include <linux/ima.h>",
      "#include <linux/task_work.h>",
      "#include <linux/percpu.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cdev.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/cred.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *filp_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "filp_cachep",
            "f"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "f->f_cred"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structfile",
            "f_u.fu_rcuhead"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *filp_cachep;\n\nstatic void file_free_rcu(struct rcu_head *head)\n{\n\tstruct file *f = container_of(head, struct file, f_u.fu_rcuhead);\n\n\tput_cred(f->f_cred);\n\tkmem_cache_free(filp_cachep, f);\n}"
  }
]