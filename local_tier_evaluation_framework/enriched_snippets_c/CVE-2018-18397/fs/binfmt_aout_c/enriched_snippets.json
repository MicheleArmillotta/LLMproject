[
  {
    "function_name": "exit_aout_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
    "lines": "419-422",
    "snippet": "static void __exit exit_aout_binfmt(void)\n{\n\tunregister_binfmt(&aout_format);\n}",
    "includes": [
      "#include <asm/a.out-core.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/coredump.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/a.out.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt aout_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_aout_binary,\n\t.load_shlib\t= load_aout_library,\n\t.core_dump\t= aout_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_binfmt",
          "args": [
            "&aout_format"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt aout_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_aout_binary,\n\t.load_shlib\t= load_aout_library,\n\t.core_dump\t= aout_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};\n\nstatic void __exit exit_aout_binfmt(void)\n{\n\tunregister_binfmt(&aout_format);\n}"
  },
  {
    "function_name": "init_aout_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
    "lines": "413-417",
    "snippet": "static int __init init_aout_binfmt(void)\n{\n\tregister_binfmt(&aout_format);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/a.out-core.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/coredump.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/a.out.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt aout_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_aout_binary,\n\t.load_shlib\t= load_aout_library,\n\t.core_dump\t= aout_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_binfmt",
          "args": [
            "&aout_format"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt aout_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_aout_binary,\n\t.load_shlib\t= load_aout_library,\n\t.core_dump\t= aout_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};\n\nstatic int __init init_aout_binfmt(void)\n{\n\tregister_binfmt(&aout_format);\n\treturn 0;\n}"
  },
  {
    "function_name": "load_aout_library",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
    "lines": "338-411",
    "snippet": "static int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\tloff_t pos = 0;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, &ex, sizeof(ex), &pos);\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tretval = vm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\tretval = vm_brk(start_addr + len, bss - len);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <asm/a.out-core.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/coredump.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/a.out.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int load_aout_library(struct file*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "start_addr + len",
            "bss - len"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "ex.a_text + ex.a_data"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "file",
            "start_addr",
            "ex.a_text + ex.a_data",
            "PROT_READ | PROT_WRITE | PROT_EXEC",
            "MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE",
            "N_TXTOFF(ex)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTOFF",
          "args": [
            "ex"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_code",
          "args": [
            "file",
            "start_addr",
            "N_TXTOFF(ex)",
            "ex.a_text + ex.a_data"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "read_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "998-1004",
          "snippet": "ssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "N_TXTOFF",
          "args": [
            "ex"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "start_addr",
            "ex.a_text + ex.a_data + ex.a_bss"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\"",
            "file"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTOFF",
          "args": [
            "ex"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_FLAGS",
          "args": [
            "ex"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTOFF",
          "args": [
            "ex"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_SYMSIZE",
          "args": [
            "ex"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_DRSIZE",
          "args": [
            "ex"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TRSIZE",
          "args": [
            "ex"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "&ex",
            "sizeof(ex)",
            "&pos"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_library(struct file*);\n\nstatic int load_aout_library(struct file *file)\n{\n\tstruct inode * inode;\n\tunsigned long bss, start_addr, len;\n\tunsigned long error;\n\tint retval;\n\tstruct exec ex;\n\tloff_t pos = 0;\n\n\tinode = file_inode(file);\n\n\tretval = -ENOEXEC;\n\terror = kernel_read(file, &ex, sizeof(ex), &pos);\n\tif (error != sizeof(ex))\n\t\tgoto out;\n\n\t/* We come in here for the regular a.out style of shared libraries */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != QMAGIC) || N_TRSIZE(ex) ||\n\t    N_DRSIZE(ex) || ((ex.a_entry & 0xfff) && N_MAGIC(ex) == ZMAGIC) ||\n\t    i_size_read(inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!file->f_op->mmap)\n\t\tgoto out;\n\n\tif (N_FLAGS(ex))\n\t\tgoto out;\n\n\t/* For  QMAGIC, the starting address is 0x20 into the page.  We mask\n\t   this off to get the starting address for the page */\n\n\tstart_addr =  ex.a_entry & 0xfffff000;\n\n\tif ((N_TXTOFF(ex) & ~PAGE_MASK) != 0) {\n\t\tif (printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"N_TXTOFF is not page aligned. Please convert library: %pD\\n\",\n\t\t\t       file);\n\t\t}\n\t\tretval = vm_brk(start_addr, ex.a_text + ex.a_data + ex.a_bss);\n\t\tif (retval)\n\t\t\tgoto out;\n\n\t\tread_code(file, start_addr, N_TXTOFF(ex),\n\t\t\t  ex.a_text + ex.a_data);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file, start_addr, ex.a_text + ex.a_data,\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\tN_TXTOFF(ex));\n\tretval = error;\n\tif (error != start_addr)\n\t\tgoto out;\n\n\tlen = PAGE_ALIGN(ex.a_text + ex.a_data);\n\tbss = ex.a_text + ex.a_data + ex.a_bss;\n\tif (bss > len) {\n\t\tretval = vm_brk(start_addr + len, bss - len);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "load_aout_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
    "lines": "199-336",
    "snippet": "static int load_aout_binary(struct linux_binprm * bprm)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct exec ex;\n\tunsigned long error;\n\tunsigned long fd_offset;\n\tunsigned long rlim;\n\tint retval;\n\n\tex = *((struct exec *) bprm->buf);\t\t/* exec-header */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != OMAGIC &&\n\t     N_MAGIC(ex) != QMAGIC && N_MAGIC(ex) != NMAGIC) ||\n\t    N_TRSIZE(ex) || N_DRSIZE(ex) ||\n\t    i_size_read(file_inode(bprm->file)) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\treturn -ENOEXEC;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!bprm->file->f_op->mmap)\n\t\treturn -ENOEXEC;\n\n\tfd_offset = N_TXTOFF(ex);\n\n\t/* Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (ex.a_data + ex.a_bss > rlim)\n\t\treturn -ENOMEM;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\t/* OK, This is the point of no return */\n#ifdef __alpha__\n\tSET_AOUT_PERSONALITY(bprm, ex);\n#else\n\tset_personality(PER_LINUX);\n#endif\n\tsetup_new_exec(bprm);\n\n\tcurrent->mm->end_code = ex.a_text +\n\t\t(current->mm->start_code = N_TXTADDR(ex));\n\tcurrent->mm->end_data = ex.a_data +\n\t\t(current->mm->start_data = N_DATADDR(ex));\n\tcurrent->mm->brk = ex.a_bss +\n\t\t(current->mm->start_brk = N_BSSADDR(ex));\n\n\tretval = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tinstall_exec_creds(bprm);\n\n\tif (N_MAGIC(ex) == OMAGIC) {\n\t\tunsigned long text_addr, map_size;\n\t\tloff_t pos;\n\n\t\ttext_addr = N_TXTADDR(ex);\n\n#ifdef __alpha__\n\t\tpos = fd_offset;\n\t\tmap_size = ex.a_text+ex.a_data + PAGE_SIZE - 1;\n#else\n\t\tpos = 32;\n\t\tmap_size = ex.a_text+ex.a_data;\n#endif\n\t\terror = vm_brk(text_addr & PAGE_MASK, map_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = read_code(bprm->file, text_addr, pos,\n\t\t\t\t  ex.a_text+ex.a_data);\n\t\tif ((signed long)error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((ex.a_text & 0xfff || ex.a_data & 0xfff) &&\n\t\t    (N_MAGIC(ex) != NMAGIC) && printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_NOTICE \"executable not page aligned\\n\");\n\t\t}\n\n\t\tif ((fd_offset & ~PAGE_MASK) != 0 && printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"fd_offset is not page aligned. Please convert program: %pD\\n\",\n\t\t\t       bprm->file);\n\t\t}\n\n\t\tif (!bprm->file->f_op->mmap||((fd_offset & ~PAGE_MASK) != 0)) {\n\t\t\terror = vm_brk(N_TXTADDR(ex), ex.a_text+ex.a_data);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tread_code(bprm->file, N_TXTADDR(ex), fd_offset,\n\t\t\t\t  ex.a_text + ex.a_data);\n\t\t\tgoto beyond_if;\n\t\t}\n\n\t\terror = vm_mmap(bprm->file, N_TXTADDR(ex), ex.a_text,\n\t\t\tPROT_READ | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\n\t\t\tfd_offset);\n\n\t\tif (error != N_TXTADDR(ex))\n\t\t\treturn error;\n\n\t\terror = vm_mmap(bprm->file, N_DATADDR(ex), ex.a_data,\n\t\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\n\t\t\t\tfd_offset + ex.a_text);\n\t\tif (error != N_DATADDR(ex))\n\t\t\treturn error;\n\t}\nbeyond_if:\n\tset_binfmt(&aout_format);\n\n\tretval = set_brk(current->mm->start_brk, current->mm->brk);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tcurrent->mm->start_stack =\n\t\t(unsigned long) create_aout_tables((char __user *) bprm->p, bprm);\n#ifdef __alpha__\n\tregs->gp = ex.a_gpvalue;\n#endif\n\tfinalize_exec(bprm);\n\tstart_thread(regs, ex.a_entry, current->mm->start_stack);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/a.out-core.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/coredump.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/a.out.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int load_aout_binary(struct linux_binprm *);",
      "static int load_aout_library(struct file*);",
      "static struct linux_binfmt aout_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_aout_binary,\n\t.load_shlib\t= load_aout_library,\n\t.core_dump\t= aout_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_thread",
          "args": [
            "regs",
            "ex.a_entry",
            "current->mm->start_stack"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalize_exec",
          "args": [
            "bprm"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "finalize_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1388-1394",
          "snippet": "void finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_aout_tables",
          "args": [
            "(char __user *) bprm->p",
            "bprm"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "create_aout_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
          "lines": "141-192",
          "snippet": "static unsigned long __user *create_aout_tables(char __user *p, struct linux_binprm * bprm)\n{\n\tchar __user * __user *argv;\n\tchar __user * __user *envp;\n\tunsigned long __user *sp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\n\tsp = (void __user *)((-(unsigned long)sizeof(char *)) & (unsigned long) p);\n#ifdef __alpha__\n/* whee.. test-programs are so much fun. */\n\tput_user(0, --sp);\n\tput_user(0, --sp);\n\tif (bprm->loader) {\n\t\tput_user(0, --sp);\n\t\tput_user(1003, --sp);\n\t\tput_user(bprm->loader, --sp);\n\t\tput_user(1002, --sp);\n\t}\n\tput_user(bprm->exec, --sp);\n\tput_user(1001, --sp);\n#endif\n\tsp -= envc+1;\n\tenvp = (char __user * __user *) sp;\n\tsp -= argc+1;\n\targv = (char __user * __user *) sp;\n#ifndef __alpha__\n\tput_user((unsigned long) envp,--sp);\n\tput_user((unsigned long) argv,--sp);\n#endif\n\tput_user(argc,--sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tchar c;\n\t\tput_user(p,argv++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tchar c;\n\t\tput_user(p,envp++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn sp;\n}",
          "includes": [
            "#include <asm/a.out-core.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/coredump.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/a.out.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int load_aout_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_binary(struct linux_binprm *);\n\nstatic unsigned long __user *create_aout_tables(char __user *p, struct linux_binprm * bprm)\n{\n\tchar __user * __user *argv;\n\tchar __user * __user *envp;\n\tunsigned long __user *sp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\n\tsp = (void __user *)((-(unsigned long)sizeof(char *)) & (unsigned long) p);\n#ifdef __alpha__\n/* whee.. test-programs are so much fun. */\n\tput_user(0, --sp);\n\tput_user(0, --sp);\n\tif (bprm->loader) {\n\t\tput_user(0, --sp);\n\t\tput_user(1003, --sp);\n\t\tput_user(bprm->loader, --sp);\n\t\tput_user(1002, --sp);\n\t}\n\tput_user(bprm->exec, --sp);\n\tput_user(1001, --sp);\n#endif\n\tsp -= envc+1;\n\tenvp = (char __user * __user *) sp;\n\tsp -= argc+1;\n\targv = (char __user * __user *) sp;\n#ifndef __alpha__\n\tput_user((unsigned long) envp,--sp);\n\tput_user((unsigned long) argv,--sp);\n#endif\n\tput_user(argc,--sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tchar c;\n\t\tput_user(p,argv++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tchar c;\n\t\tput_user(p,envp++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_brk",
          "args": [
            "current->mm->start_brk",
            "current->mm->brk"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "set_brk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
          "lines": "127-134",
          "snippet": "static int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = PAGE_ALIGN(start);\n\tend = PAGE_ALIGN(end);\n\tif (end > start)\n\t\treturn vm_brk(start, end - start);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/a.out-core.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/slab.h>",
            "#include <linux/coredump.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/a.out.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = PAGE_ALIGN(start);\n\tend = PAGE_ALIGN(end);\n\tif (end > start)\n\t\treturn vm_brk(start, end - start);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_binfmt",
          "args": [
            "&aout_format"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "set_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1931-1941",
          "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "N_DATADDR",
          "args": [
            "ex"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "bprm->file",
            "N_DATADDR(ex)",
            "ex.a_data",
            "PROT_READ | PROT_WRITE | PROT_EXEC",
            "MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE",
            "fd_offset + ex.a_text"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_DATADDR",
          "args": [
            "ex"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTADDR",
          "args": [
            "ex"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "bprm->file",
            "N_TXTADDR(ex)",
            "ex.a_text",
            "PROT_READ | PROT_EXEC",
            "MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE",
            "fd_offset"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTADDR",
          "args": [
            "ex"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_code",
          "args": [
            "bprm->file",
            "N_TXTADDR(ex)",
            "fd_offset",
            "ex.a_text + ex.a_data"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "read_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "998-1004",
          "snippet": "ssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "N_TXTADDR",
          "args": [
            "ex"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "N_TXTADDR(ex)",
            "ex.a_text+ex.a_data"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTADDR",
          "args": [
            "ex"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \n\t\t\t       \"fd_offset is not page aligned. Please convert program: %pD\\n\"",
            "bprm->file"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"executable not page aligned\\n\""
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "text_addr & PAGE_MASK",
            "map_size"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTADDR",
          "args": [
            "ex"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "install_exec_creds",
          "args": [
            "bprm"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "install_exec_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1448-1470",
          "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_arg_pages",
          "args": [
            "bprm",
            "STACK_TOP",
            "EXSTACK_DEFAULT"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "setup_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "688-798",
          "snippet": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "N_BSSADDR",
          "args": [
            "ex"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_DATADDR",
          "args": [
            "ex"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTADDR",
          "args": [
            "ex"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_new_exec",
          "args": [
            "bprm"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1330-1384",
          "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int suid_dumpable = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_personality",
          "args": [
            "PER_LINUX"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_AOUT_PERSONALITY",
          "args": [
            "bprm",
            "ex"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_old_exec",
          "args": [
            "bprm"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "flush_old_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1254-1306",
          "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_DATA"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTOFF",
          "args": [
            "ex"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TXTOFF",
          "args": [
            "ex"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_SYMSIZE",
          "args": [
            "ex"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(bprm->file)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "N_DRSIZE",
          "args": [
            "ex"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_TRSIZE",
          "args": [
            "ex"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "N_MAGIC",
          "args": [
            "ex"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_binary(struct linux_binprm *);\nstatic int load_aout_library(struct file*);\nstatic struct linux_binfmt aout_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_aout_binary,\n\t.load_shlib\t= load_aout_library,\n\t.core_dump\t= aout_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};\n\nstatic int load_aout_binary(struct linux_binprm * bprm)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct exec ex;\n\tunsigned long error;\n\tunsigned long fd_offset;\n\tunsigned long rlim;\n\tint retval;\n\n\tex = *((struct exec *) bprm->buf);\t\t/* exec-header */\n\tif ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != OMAGIC &&\n\t     N_MAGIC(ex) != QMAGIC && N_MAGIC(ex) != NMAGIC) ||\n\t    N_TRSIZE(ex) || N_DRSIZE(ex) ||\n\t    i_size_read(file_inode(bprm->file)) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {\n\t\treturn -ENOEXEC;\n\t}\n\n\t/*\n\t * Requires a mmap handler. This prevents people from using a.out\n\t * as part of an exploit attack against /proc-related vulnerabilities.\n\t */\n\tif (!bprm->file->f_op->mmap)\n\t\treturn -ENOEXEC;\n\n\tfd_offset = N_TXTOFF(ex);\n\n\t/* Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (ex.a_data + ex.a_bss > rlim)\n\t\treturn -ENOMEM;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\t/* OK, This is the point of no return */\n#ifdef __alpha__\n\tSET_AOUT_PERSONALITY(bprm, ex);\n#else\n\tset_personality(PER_LINUX);\n#endif\n\tsetup_new_exec(bprm);\n\n\tcurrent->mm->end_code = ex.a_text +\n\t\t(current->mm->start_code = N_TXTADDR(ex));\n\tcurrent->mm->end_data = ex.a_data +\n\t\t(current->mm->start_data = N_DATADDR(ex));\n\tcurrent->mm->brk = ex.a_bss +\n\t\t(current->mm->start_brk = N_BSSADDR(ex));\n\n\tretval = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tinstall_exec_creds(bprm);\n\n\tif (N_MAGIC(ex) == OMAGIC) {\n\t\tunsigned long text_addr, map_size;\n\t\tloff_t pos;\n\n\t\ttext_addr = N_TXTADDR(ex);\n\n#ifdef __alpha__\n\t\tpos = fd_offset;\n\t\tmap_size = ex.a_text+ex.a_data + PAGE_SIZE - 1;\n#else\n\t\tpos = 32;\n\t\tmap_size = ex.a_text+ex.a_data;\n#endif\n\t\terror = vm_brk(text_addr & PAGE_MASK, map_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = read_code(bprm->file, text_addr, pos,\n\t\t\t\t  ex.a_text+ex.a_data);\n\t\tif ((signed long)error < 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((ex.a_text & 0xfff || ex.a_data & 0xfff) &&\n\t\t    (N_MAGIC(ex) != NMAGIC) && printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_NOTICE \"executable not page aligned\\n\");\n\t\t}\n\n\t\tif ((fd_offset & ~PAGE_MASK) != 0 && printk_ratelimit())\n\t\t{\n\t\t\tprintk(KERN_WARNING \n\t\t\t       \"fd_offset is not page aligned. Please convert program: %pD\\n\",\n\t\t\t       bprm->file);\n\t\t}\n\n\t\tif (!bprm->file->f_op->mmap||((fd_offset & ~PAGE_MASK) != 0)) {\n\t\t\terror = vm_brk(N_TXTADDR(ex), ex.a_text+ex.a_data);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tread_code(bprm->file, N_TXTADDR(ex), fd_offset,\n\t\t\t\t  ex.a_text + ex.a_data);\n\t\t\tgoto beyond_if;\n\t\t}\n\n\t\terror = vm_mmap(bprm->file, N_TXTADDR(ex), ex.a_text,\n\t\t\tPROT_READ | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\n\t\t\tfd_offset);\n\n\t\tif (error != N_TXTADDR(ex))\n\t\t\treturn error;\n\n\t\terror = vm_mmap(bprm->file, N_DATADDR(ex), ex.a_data,\n\t\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE,\n\t\t\t\tfd_offset + ex.a_text);\n\t\tif (error != N_DATADDR(ex))\n\t\t\treturn error;\n\t}\nbeyond_if:\n\tset_binfmt(&aout_format);\n\n\tretval = set_brk(current->mm->start_brk, current->mm->brk);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tcurrent->mm->start_stack =\n\t\t(unsigned long) create_aout_tables((char __user *) bprm->p, bprm);\n#ifdef __alpha__\n\tregs->gp = ex.a_gpvalue;\n#endif\n\tfinalize_exec(bprm);\n\tstart_thread(regs, ex.a_entry, current->mm->start_stack);\n\treturn 0;\n}"
  },
  {
    "function_name": "create_aout_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
    "lines": "141-192",
    "snippet": "static unsigned long __user *create_aout_tables(char __user *p, struct linux_binprm * bprm)\n{\n\tchar __user * __user *argv;\n\tchar __user * __user *envp;\n\tunsigned long __user *sp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\n\tsp = (void __user *)((-(unsigned long)sizeof(char *)) & (unsigned long) p);\n#ifdef __alpha__\n/* whee.. test-programs are so much fun. */\n\tput_user(0, --sp);\n\tput_user(0, --sp);\n\tif (bprm->loader) {\n\t\tput_user(0, --sp);\n\t\tput_user(1003, --sp);\n\t\tput_user(bprm->loader, --sp);\n\t\tput_user(1002, --sp);\n\t}\n\tput_user(bprm->exec, --sp);\n\tput_user(1001, --sp);\n#endif\n\tsp -= envc+1;\n\tenvp = (char __user * __user *) sp;\n\tsp -= argc+1;\n\targv = (char __user * __user *) sp;\n#ifndef __alpha__\n\tput_user((unsigned long) envp,--sp);\n\tput_user((unsigned long) argv,--sp);\n#endif\n\tput_user(argc,--sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tchar c;\n\t\tput_user(p,argv++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tchar c;\n\t\tput_user(p,envp++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn sp;\n}",
    "includes": [
      "#include <asm/a.out-core.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/coredump.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/a.out.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int load_aout_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "NULL",
            "envp"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "c",
            "p++"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "p",
            "envp++"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "NULL",
            "argv"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "p",
            "argv++"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "argc",
            "--sp"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long) argv",
            "--sp"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long) envp",
            "--sp"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "1001",
            "--sp"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "bprm->exec",
            "--sp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "1002",
            "--sp"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "bprm->loader",
            "--sp"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "1003",
            "--sp"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "0",
            "--sp"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "0",
            "--sp"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "0",
            "--sp"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_aout_binary(struct linux_binprm *);\n\nstatic unsigned long __user *create_aout_tables(char __user *p, struct linux_binprm * bprm)\n{\n\tchar __user * __user *argv;\n\tchar __user * __user *envp;\n\tunsigned long __user *sp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\n\tsp = (void __user *)((-(unsigned long)sizeof(char *)) & (unsigned long) p);\n#ifdef __alpha__\n/* whee.. test-programs are so much fun. */\n\tput_user(0, --sp);\n\tput_user(0, --sp);\n\tif (bprm->loader) {\n\t\tput_user(0, --sp);\n\t\tput_user(1003, --sp);\n\t\tput_user(bprm->loader, --sp);\n\t\tput_user(1002, --sp);\n\t}\n\tput_user(bprm->exec, --sp);\n\tput_user(1001, --sp);\n#endif\n\tsp -= envc+1;\n\tenvp = (char __user * __user *) sp;\n\tsp -= argc+1;\n\targv = (char __user * __user *) sp;\n#ifndef __alpha__\n\tput_user((unsigned long) envp,--sp);\n\tput_user((unsigned long) argv,--sp);\n#endif\n\tput_user(argc,--sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tchar c;\n\t\tput_user(p,argv++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tchar c;\n\t\tput_user(p,envp++);\n\t\tdo {\n\t\t\tget_user(c,p++);\n\t\t} while (c);\n\t}\n\tput_user(NULL,envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn sp;\n}"
  },
  {
    "function_name": "set_brk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
    "lines": "127-134",
    "snippet": "static int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = PAGE_ALIGN(start);\n\tend = PAGE_ALIGN(end);\n\tif (end > start)\n\t\treturn vm_brk(start, end - start);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/a.out-core.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/coredump.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/a.out.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "start",
            "end - start"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "end"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "start"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = PAGE_ALIGN(start);\n\tend = PAGE_ALIGN(end);\n\tif (end > start)\n\t\treturn vm_brk(start, end - start);\n\treturn 0;\n}"
  },
  {
    "function_name": "aout_core_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_aout.c",
    "lines": "47-112",
    "snippet": "static int aout_core_dump(struct coredump_params *cprm)\n{\n\tmm_segment_t fs;\n\tint has_dumped = 0;\n\tvoid __user *dump_start;\n\tint dump_size;\n\tstruct user dump;\n#ifdef __alpha__\n#       define START_DATA(u)\t((void __user *)u.start_data)\n#else\n#\tdefine START_DATA(u)\t((void __user *)((u.u_tsize << PAGE_SHIFT) + \\\n\t\t\t\t u.start_code))\n#endif\n#       define START_STACK(u)   ((void __user *)u.start_stack)\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\thas_dumped = 1;\n       \tstrncpy(dump.u_comm, current->comm, sizeof(dump.u_comm));\n\tdump.u_ar0 = offsetof(struct user, regs);\n\tdump.signal = cprm->siginfo->si_signo;\n\taout_dump_thread(cprm->regs, &dump);\n\n/* If the size of the dump file exceeds the rlimit, then see what would happen\n   if we wrote the stack, but not the data area.  */\n\tif ((dump.u_dsize + dump.u_ssize+1) * PAGE_SIZE > cprm->limit)\n\t\tdump.u_dsize = 0;\n\n/* Make sure we have enough room to write the stack and data areas. */\n\tif ((dump.u_ssize + 1) * PAGE_SIZE > cprm->limit)\n\t\tdump.u_ssize = 0;\n\n/* make sure we actually have a data and stack area to dump */\n\tset_fs(USER_DS);\n\tif (!access_ok(VERIFY_READ, START_DATA(dump), dump.u_dsize << PAGE_SHIFT))\n\t\tdump.u_dsize = 0;\n\tif (!access_ok(VERIFY_READ, START_STACK(dump), dump.u_ssize << PAGE_SHIFT))\n\t\tdump.u_ssize = 0;\n\n\tset_fs(KERNEL_DS);\n/* struct user */\n\tif (!dump_emit(cprm, &dump, sizeof(dump)))\n\t\tgoto end_coredump;\n/* Now dump all of the user data.  Include malloced stuff as well */\n\tif (!dump_skip(cprm, PAGE_SIZE - sizeof(dump)))\n\t\tgoto end_coredump;\n/* now we start writing out the user space info */\n\tset_fs(USER_DS);\n/* Dump the data area */\n\tif (dump.u_dsize != 0) {\n\t\tdump_start = START_DATA(dump);\n\t\tdump_size = dump.u_dsize << PAGE_SHIFT;\n\t\tif (!dump_emit(cprm, dump_start, dump_size))\n\t\t\tgoto end_coredump;\n\t}\n/* Now prepare to dump the stack area */\n\tif (dump.u_ssize != 0) {\n\t\tdump_start = START_STACK(dump);\n\t\tdump_size = dump.u_ssize << PAGE_SHIFT;\n\t\tif (!dump_emit(cprm, dump_start, dump_size))\n\t\t\tgoto end_coredump;\n\t}\nend_coredump:\n\tset_fs(fs);\n\treturn has_dumped;\n}",
    "includes": [
      "#include <asm/a.out-core.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/slab.h>",
      "#include <linux/coredump.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/a.out.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define aout_core_dump NULL"
    ],
    "globals_used": [
      "static int load_aout_library(struct file*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "dump_start",
            "dump_size"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "dump_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "783-802",
          "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "START_STACK",
          "args": [
            "dump"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_DATA",
          "args": [
            "dump"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_skip",
          "args": [
            "cprm",
            "PAGE_SIZE - sizeof(dump)"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "dump_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "805-823",
          "snippet": "int dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "START_STACK(dump)",
            "dump.u_ssize << PAGE_SHIFT"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_STACK",
          "args": [
            "dump"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "START_DATA(dump)",
            "dump.u_dsize << PAGE_SHIFT"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "START_DATA",
          "args": [
            "dump"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aout_dump_thread",
          "args": [
            "cprm->regs",
            "&dump"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "dump.u_comm",
            "current->comm",
            "sizeof(dump.u_comm)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/a.out-core.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/coredump.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/a.out.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define aout_core_dump NULL\n\nstatic int load_aout_library(struct file*);\n\nstatic int aout_core_dump(struct coredump_params *cprm)\n{\n\tmm_segment_t fs;\n\tint has_dumped = 0;\n\tvoid __user *dump_start;\n\tint dump_size;\n\tstruct user dump;\n#ifdef __alpha__\n#       define START_DATA(u)\t((void __user *)u.start_data)\n#else\n#\tdefine START_DATA(u)\t((void __user *)((u.u_tsize << PAGE_SHIFT) + \\\n\t\t\t\t u.start_code))\n#endif\n#       define START_STACK(u)   ((void __user *)u.start_stack)\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\thas_dumped = 1;\n       \tstrncpy(dump.u_comm, current->comm, sizeof(dump.u_comm));\n\tdump.u_ar0 = offsetof(struct user, regs);\n\tdump.signal = cprm->siginfo->si_signo;\n\taout_dump_thread(cprm->regs, &dump);\n\n/* If the size of the dump file exceeds the rlimit, then see what would happen\n   if we wrote the stack, but not the data area.  */\n\tif ((dump.u_dsize + dump.u_ssize+1) * PAGE_SIZE > cprm->limit)\n\t\tdump.u_dsize = 0;\n\n/* Make sure we have enough room to write the stack and data areas. */\n\tif ((dump.u_ssize + 1) * PAGE_SIZE > cprm->limit)\n\t\tdump.u_ssize = 0;\n\n/* make sure we actually have a data and stack area to dump */\n\tset_fs(USER_DS);\n\tif (!access_ok(VERIFY_READ, START_DATA(dump), dump.u_dsize << PAGE_SHIFT))\n\t\tdump.u_dsize = 0;\n\tif (!access_ok(VERIFY_READ, START_STACK(dump), dump.u_ssize << PAGE_SHIFT))\n\t\tdump.u_ssize = 0;\n\n\tset_fs(KERNEL_DS);\n/* struct user */\n\tif (!dump_emit(cprm, &dump, sizeof(dump)))\n\t\tgoto end_coredump;\n/* Now dump all of the user data.  Include malloced stuff as well */\n\tif (!dump_skip(cprm, PAGE_SIZE - sizeof(dump)))\n\t\tgoto end_coredump;\n/* now we start writing out the user space info */\n\tset_fs(USER_DS);\n/* Dump the data area */\n\tif (dump.u_dsize != 0) {\n\t\tdump_start = START_DATA(dump);\n\t\tdump_size = dump.u_dsize << PAGE_SHIFT;\n\t\tif (!dump_emit(cprm, dump_start, dump_size))\n\t\t\tgoto end_coredump;\n\t}\n/* Now prepare to dump the stack area */\n\tif (dump.u_ssize != 0) {\n\t\tdump_start = START_STACK(dump);\n\t\tdump_size = dump.u_ssize << PAGE_SHIFT;\n\t\tif (!dump_emit(cprm, dump_start, dump_size))\n\t\t\tgoto end_coredump;\n\t}\nend_coredump:\n\tset_fs(fs);\n\treturn has_dumped;\n}"
  }
]