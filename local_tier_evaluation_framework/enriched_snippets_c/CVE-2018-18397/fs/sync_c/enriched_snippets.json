[
  {
    "function_name": "ksys_sync_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "284-361",
    "snippet": "int ksys_sync_file_range(int fd, loff_t offset, loff_t nbytes,\n\t\t\t unsigned int flags)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct address_space *mapping;\n\tloff_t endbyte;\t\t\t/* inclusive */\n\tumode_t i_mode;\n\n\tret = -EINVAL;\n\tif (flags & ~VALID_FLAGS)\n\t\tgoto out;\n\n\tendbyte = offset + nbytes;\n\n\tif ((s64)offset < 0)\n\t\tgoto out;\n\tif ((s64)endbyte < 0)\n\t\tgoto out;\n\tif (endbyte < offset)\n\t\tgoto out;\n\n\tif (sizeof(pgoff_t) == 4) {\n\t\tif (offset >= (0x100000000ULL << PAGE_SHIFT)) {\n\t\t\t/*\n\t\t\t * The range starts outside a 32 bit machine's\n\t\t\t * pagecache addressing capabilities.  Let it \"succeed\"\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (endbyte >= (0x100000000ULL << PAGE_SHIFT)) {\n\t\t\t/*\n\t\t\t * Out to EOF\n\t\t\t */\n\t\t\tnbytes = 0;\n\t\t}\n\t}\n\n\tif (nbytes == 0)\n\t\tendbyte = LLONG_MAX;\n\telse\n\t\tendbyte--;\t\t/* inclusive */\n\n\tret = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\ti_mode = file_inode(f.file)->i_mode;\n\tret = -ESPIPE;\n\tif (!S_ISREG(i_mode) && !S_ISBLK(i_mode) && !S_ISDIR(i_mode) &&\n\t\t\t!S_ISLNK(i_mode))\n\t\tgoto out_put;\n\n\tmapping = f.file->f_mapping;\n\tret = 0;\n\tif (flags & SYNC_FILE_RANGE_WAIT_BEFORE) {\n\t\tret = file_fdatawait_range(f.file, offset, endbyte);\n\t\tif (ret < 0)\n\t\t\tgoto out_put;\n\t}\n\n\tif (flags & SYNC_FILE_RANGE_WRITE) {\n\t\tret = __filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t\t WB_SYNC_NONE);\n\t\tif (ret < 0)\n\t\t\tgoto out_put;\n\t}\n\n\tif (flags & SYNC_FILE_RANGE_WAIT_AFTER)\n\t\tret = file_fdatawait_range(f.file, offset, endbyte);\n\nout_put:\n\tfdput(f);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \\\n\t\t\tSYNC_FILE_RANGE_WAIT_AFTER)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_fdatawait_range",
          "args": [
            "f.file",
            "offset",
            "endbyte"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__filemap_fdatawrite_range",
          "args": [
            "mapping",
            "offset",
            "endbyte",
            "WB_SYNC_NONE"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_fdatawait_range",
          "args": [
            "f.file",
            "offset",
            "endbyte"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "i_mode"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i_mode"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "i_mode"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "i_mode"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f.file"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\n#define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \\\n\t\t\tSYNC_FILE_RANGE_WAIT_AFTER)\n\nint ksys_sync_file_range(int fd, loff_t offset, loff_t nbytes,\n\t\t\t unsigned int flags)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct address_space *mapping;\n\tloff_t endbyte;\t\t\t/* inclusive */\n\tumode_t i_mode;\n\n\tret = -EINVAL;\n\tif (flags & ~VALID_FLAGS)\n\t\tgoto out;\n\n\tendbyte = offset + nbytes;\n\n\tif ((s64)offset < 0)\n\t\tgoto out;\n\tif ((s64)endbyte < 0)\n\t\tgoto out;\n\tif (endbyte < offset)\n\t\tgoto out;\n\n\tif (sizeof(pgoff_t) == 4) {\n\t\tif (offset >= (0x100000000ULL << PAGE_SHIFT)) {\n\t\t\t/*\n\t\t\t * The range starts outside a 32 bit machine's\n\t\t\t * pagecache addressing capabilities.  Let it \"succeed\"\n\t\t\t */\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (endbyte >= (0x100000000ULL << PAGE_SHIFT)) {\n\t\t\t/*\n\t\t\t * Out to EOF\n\t\t\t */\n\t\t\tnbytes = 0;\n\t\t}\n\t}\n\n\tif (nbytes == 0)\n\t\tendbyte = LLONG_MAX;\n\telse\n\t\tendbyte--;\t\t/* inclusive */\n\n\tret = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\ti_mode = file_inode(f.file)->i_mode;\n\tret = -ESPIPE;\n\tif (!S_ISREG(i_mode) && !S_ISBLK(i_mode) && !S_ISDIR(i_mode) &&\n\t\t\t!S_ISLNK(i_mode))\n\t\tgoto out_put;\n\n\tmapping = f.file->f_mapping;\n\tret = 0;\n\tif (flags & SYNC_FILE_RANGE_WAIT_BEFORE) {\n\t\tret = file_fdatawait_range(f.file, offset, endbyte);\n\t\tif (ret < 0)\n\t\t\tgoto out_put;\n\t}\n\n\tif (flags & SYNC_FILE_RANGE_WRITE) {\n\t\tret = __filemap_fdatawrite_range(mapping, offset, endbyte,\n\t\t\t\t\t\t WB_SYNC_NONE);\n\t\tif (ret < 0)\n\t\t\tgoto out_put;\n\t}\n\n\tif (flags & SYNC_FILE_RANGE_WAIT_AFTER)\n\t\tret = file_fdatawait_range(f.file, offset, endbyte);\n\nout_put:\n\tfdput(f);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "do_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "215-225",
    "snippet": "static int do_fsync(unsigned int fd, int datasync)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (f.file) {\n\t\tret = vfs_fsync(f.file, datasync);\n\t\tfdput(f);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "f.file",
            "datasync"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "209-212",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic int do_fsync(unsigned int fd, int datasync)\n{\n\tstruct fd f = fdget(fd);\n\tint ret = -EBADF;\n\n\tif (f.file) {\n\t\tret = vfs_fsync(f.file, datasync);\n\t\tfdput(f);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "vfs_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "209-212",
    "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_fsync_range",
          "args": [
            "file",
            "0",
            "LLONG_MAX",
            "datasync"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "189-198",
          "snippet": "int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME))\n\t\tmark_inode_dirty_sync(inode);\n\treturn file->f_op->fsync(file, start, end, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME))\n\t\tmark_inode_dirty_sync(inode);\n\treturn file->f_op->fsync(file, start, end, datasync);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
  },
  {
    "function_name": "vfs_fsync_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "189-198",
    "snippet": "int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME))\n\t\tmark_inode_dirty_sync(inode);\n\treturn file->f_op->fsync(file, start, end, datasync);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file->f_op->fsync",
          "args": [
            "file",
            "start",
            "end",
            "datasync"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/nilfs.h",
          "lines": "285-288",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_ondisk.h>",
            "#include <linux/nilfs2_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nilfs_init_gcinode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_ondisk.h>\n#include <linux/nilfs2_api.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nint nilfs_init_gcinode(struct inode *inode);\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME))\n\t\tmark_inode_dirty_sync(inode);\n\treturn file->f_op->fsync(file, start, end, datasync);\n}"
  },
  {
    "function_name": "emergency_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "146-155",
    "snippet": "void emergency_sync(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_sync_work);\n\t\tschedule_work(work);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "work"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/direct.c",
          "lines": "740-757",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq);",
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq);\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "do_sync_work"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*work)",
            "GFP_ATOMIC"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nvoid emergency_sync(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_sync_work);\n\t\tschedule_work(work);\n\t}\n}"
  },
  {
    "function_name": "do_sync_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "128-144",
    "snippet": "static void do_sync_work(struct work_struct *work)\n{\n\tint nowait = 0;\n\n\t/*\n\t * Sync twice to reduce the possibility we skipped some inodes / pages\n\t * because they were temporarily locked\n\t */\n\titerate_supers(sync_inodes_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\titerate_bdevs(fdatawrite_one_bdev, NULL);\n\titerate_supers(sync_inodes_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\titerate_bdevs(fdatawrite_one_bdev, NULL);\n\tprintk(\"Emergency Sync complete\\n\");\n\tkfree(work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Emergency Sync complete\\n\""
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_bdevs",
          "args": [
            "fdatawrite_one_bdev",
            "NULL"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_bdevs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "2133-2172",
          "snippet": "void iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct block_device *bdev;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * s_inode_list_lock  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * s_inode_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\t\tbdev = I_BDEV(inode);\n\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tif (bdev->bd_openers)\n\t\t\tfunc(bdev, arg);\n\t\tmutex_unlock(&bdev->bd_mutex);\n\n\t\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\t}\n\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\tiput(old_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct super_block *blockdev_superblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *blockdev_superblock;\n\nvoid iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct block_device *bdev;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * s_inode_list_lock  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * s_inode_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\t\tbdev = I_BDEV(inode);\n\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tif (bdev->bd_openers)\n\t\t\tfunc(bdev, arg);\n\t\tmutex_unlock(&bdev->bd_mutex);\n\n\t\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\t}\n\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\tiput(old_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_supers",
          "args": [
            "sync_fs_one_sb",
            "&nowait"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_supers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "620-644",
          "snippet": "void iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic void do_sync_work(struct work_struct *work)\n{\n\tint nowait = 0;\n\n\t/*\n\t * Sync twice to reduce the possibility we skipped some inodes / pages\n\t * because they were temporarily locked\n\t */\n\titerate_supers(sync_inodes_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\titerate_bdevs(fdatawrite_one_bdev, NULL);\n\titerate_supers(sync_inodes_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\titerate_bdevs(fdatawrite_one_bdev, NULL);\n\tprintk(\"Emergency Sync complete\\n\");\n\tkfree(work);\n}"
  },
  {
    "function_name": "ksys_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "108-120",
    "snippet": "void ksys_sync(void)\n{\n\tint nowait = 0, wait = 1;\n\n\twakeup_flusher_threads(WB_REASON_SYNC);\n\titerate_supers(sync_inodes_one_sb, NULL);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &wait);\n\titerate_bdevs(fdatawrite_one_bdev, NULL);\n\titerate_bdevs(fdatawait_one_bdev, NULL);\n\tif (unlikely(laptop_mode))\n\t\tlaptop_sync_completion();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "laptop_sync_completion",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "laptop_mode"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_bdevs",
          "args": [
            "fdatawait_one_bdev",
            "NULL"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_bdevs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "2133-2172",
          "snippet": "void iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct block_device *bdev;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * s_inode_list_lock  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * s_inode_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\t\tbdev = I_BDEV(inode);\n\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tif (bdev->bd_openers)\n\t\t\tfunc(bdev, arg);\n\t\tmutex_unlock(&bdev->bd_mutex);\n\n\t\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\t}\n\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\tiput(old_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct super_block *blockdev_superblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *blockdev_superblock;\n\nvoid iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct block_device *bdev;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * s_inode_list_lock  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * s_inode_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\t\tbdev = I_BDEV(inode);\n\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tif (bdev->bd_openers)\n\t\t\tfunc(bdev, arg);\n\t\tmutex_unlock(&bdev->bd_mutex);\n\n\t\tspin_lock(&blockdev_superblock->s_inode_list_lock);\n\t}\n\tspin_unlock(&blockdev_superblock->s_inode_list_lock);\n\tiput(old_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_supers",
          "args": [
            "sync_fs_one_sb",
            "&wait"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_supers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "620-644",
          "snippet": "void iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_flusher_threads",
          "args": [
            "WB_REASON_SYNC"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_flusher_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1991-2005",
          "snippet": "void wakeup_flusher_threads(enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\t/*\n\t * If we are expecting writeback progress we must submit plugged IO.\n\t */\n\tif (blk_needs_flush_plug(current))\n\t\tblk_schedule_flush_plug(current);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)\n\t\t__wakeup_flusher_threads_bdi(bdi, reason);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wakeup_flusher_threads(enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\t/*\n\t * If we are expecting writeback progress we must submit plugged IO.\n\t */\n\tif (blk_needs_flush_plug(current))\n\t\tblk_schedule_flush_plug(current);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)\n\t\t__wakeup_flusher_threads_bdi(bdi, reason);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nvoid ksys_sync(void)\n{\n\tint nowait = 0, wait = 1;\n\n\twakeup_flusher_threads(WB_REASON_SYNC);\n\titerate_supers(sync_inodes_one_sb, NULL);\n\titerate_supers(sync_fs_one_sb, &nowait);\n\titerate_supers(sync_fs_one_sb, &wait);\n\titerate_bdevs(fdatawrite_one_bdev, NULL);\n\titerate_bdevs(fdatawait_one_bdev, NULL);\n\tif (unlikely(laptop_mode))\n\t\tlaptop_sync_completion();\n}"
  },
  {
    "function_name": "fdatawait_one_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "88-96",
    "snippet": "static void fdatawait_one_bdev(struct block_device *bdev, void *arg)\n{\n\t/*\n\t * We keep the error status of individual mapping so that\n\t * applications can catch the writeback error using fsync(2).\n\t * See filemap_fdatawait_keep_errors() for details.\n\t */\n\tfilemap_fdatawait_keep_errors(bdev->bd_inode->i_mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawait_keep_errors",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic void fdatawait_one_bdev(struct block_device *bdev, void *arg)\n{\n\t/*\n\t * We keep the error status of individual mapping so that\n\t * applications can catch the writeback error using fsync(2).\n\t * See filemap_fdatawait_keep_errors() for details.\n\t */\n\tfilemap_fdatawait_keep_errors(bdev->bd_inode->i_mapping);\n}"
  },
  {
    "function_name": "fdatawrite_one_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "83-86",
    "snippet": "static void fdatawrite_one_bdev(struct block_device *bdev, void *arg)\n{\n\tfilemap_fdatawrite(bdev->bd_inode->i_mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic void fdatawrite_one_bdev(struct block_device *bdev, void *arg)\n{\n\tfilemap_fdatawrite(bdev->bd_inode->i_mapping);\n}"
  },
  {
    "function_name": "sync_fs_one_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "77-81",
    "snippet": "static void sync_fs_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!sb_rdonly(sb) && sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, *(int *)arg);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb->s_op->sync_fs",
          "args": [
            "sb",
            "*(int *)arg"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic void sync_fs_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!sb_rdonly(sb) && sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, *(int *)arg);\n}"
  },
  {
    "function_name": "sync_inodes_one_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "71-75",
    "snippet": "static void sync_inodes_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!sb_rdonly(sb))\n\t\tsync_inodes_sb(sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_inodes_sb",
          "args": [
            "sb"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inodes_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2393-2420",
          "snippet": "void sync_inodes_sb(struct super_block *sb)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\t/*\n\t * Can't skip on !bdi_has_dirty() because we should wait for !dirty\n\t * inodes under writeback and I_DIRTY_TIME inodes ignored by\n\t * bdi_has_dirty() need to be written out too.\n\t */\n\tif (bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(bdi, &work, false);\n\twb_wait_for_completion(bdi, &done);\n\n\twait_sb_inodes(sb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid sync_inodes_sb(struct super_block *sb)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\t/*\n\t * Can't skip on !bdi_has_dirty() because we should wait for !dirty\n\t * inodes under writeback and I_DIRTY_TIME inodes ignored by\n\t * bdi_has_dirty() need to be written out too.\n\t */\n\tif (bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(bdi, &work, false);\n\twb_wait_for_completion(bdi, &done);\n\n\twait_sb_inodes(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic void sync_inodes_one_sb(struct super_block *sb, void *arg)\n{\n\tif (!sb_rdonly(sb))\n\t\tsync_inodes_sb(sb);\n}"
  },
  {
    "function_name": "sync_filesystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "48-68",
    "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_filesystem",
          "args": [
            "sb",
            "1"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "31-41",
          "snippet": "static int __sync_filesystem(struct super_block *sb, int wait)\n{\n\tif (wait)\n\t\tsync_inodes_sb(sb);\n\telse\n\t\twriteback_inodes_sb(sb, WB_REASON_SYNC);\n\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, wait);\n\treturn __sync_blockdev(sb->s_bdev, wait);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic int __sync_filesystem(struct super_block *sb, int wait)\n{\n\tif (wait)\n\t\tsync_inodes_sb(sb);\n\telse\n\t\twriteback_inodes_sb(sb, WB_REASON_SYNC);\n\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, wait);\n\treturn __sync_blockdev(sb->s_bdev, wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rwsem_is_locked(&sb->s_umount)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&sb->s_umount"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
  },
  {
    "function_name": "__sync_filesystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "31-41",
    "snippet": "static int __sync_filesystem(struct super_block *sb, int wait)\n{\n\tif (wait)\n\t\tsync_inodes_sb(sb);\n\telse\n\t\twriteback_inodes_sb(sb, WB_REASON_SYNC);\n\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, wait);\n\treturn __sync_blockdev(sb->s_bdev, wait);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_blockdev",
          "args": [
            "sb->s_bdev",
            "wait"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/internal.h",
          "lines": "34-37",
          "snippet": "static inline int __sync_blockdev(struct block_device *bdev, int wait)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int __sync_blockdev(struct block_device *bdev, int wait)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->sync_fs",
          "args": [
            "sb",
            "wait"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_inodes_sb",
          "args": [
            "sb",
            "WB_REASON_SYNC"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_writeback_inodes_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2376-2383",
          "snippet": "void try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn;\n\n\t__writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason, true);\n\tup_read(&sb->s_umount);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn;\n\n\t__writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason, true);\n\tup_read(&sb->s_umount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inodes_sb",
          "args": [
            "sb"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inodes_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2393-2420",
          "snippet": "void sync_inodes_sb(struct super_block *sb)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\t/*\n\t * Can't skip on !bdi_has_dirty() because we should wait for !dirty\n\t * inodes under writeback and I_DIRTY_TIME inodes ignored by\n\t * bdi_has_dirty() need to be written out too.\n\t */\n\tif (bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(bdi, &work, false);\n\twb_wait_for_completion(bdi, &done);\n\n\twait_sb_inodes(sb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid sync_inodes_sb(struct super_block *sb)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\t/*\n\t * Can't skip on !bdi_has_dirty() because we should wait for !dirty\n\t * inodes under writeback and I_DIRTY_TIME inodes ignored by\n\t * bdi_has_dirty() need to be written out too.\n\t */\n\tif (bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(bdi, &work, false);\n\twb_wait_for_completion(bdi, &done);\n\n\twait_sb_inodes(sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nstatic int __sync_filesystem(struct super_block *sb, int wait)\n{\n\tif (wait)\n\t\tsync_inodes_sb(sb);\n\telse\n\t\twriteback_inodes_sb(sb, WB_REASON_SYNC);\n\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, wait);\n\treturn __sync_blockdev(sb->s_bdev, wait);\n}"
  },
  {
    "function_name": "sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "122-126",
    "snippet": "SYSCALL_DEFINE0(sync)\n{\n\tksys_sync();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE0(sync)\n{\n\tksys_sync();\n\treturn 0;\n}"
  },
  {
    "function_name": "syncfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "160-176",
    "snippet": "SYSCALL_DEFINE1(syncfs, int, fd)\n{\n\tstruct fd f = fdget(fd);\n\tstruct super_block *sb;\n\tint ret;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tsb = f.file->f_path.dentry->d_sb;\n\n\tdown_read(&sb->s_umount);\n\tret = sync_filesystem(sb);\n\tup_read(&sb->s_umount);\n\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE1(syncfs, int, fd)\n{\n\tstruct fd f = fdget(fd);\n\tstruct super_block *sb;\n\tint ret;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tsb = f.file->f_path.dentry->d_sb;\n\n\tdown_read(&sb->s_umount);\n\tret = sync_filesystem(sb);\n\tup_read(&sb->s_umount);\n\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "227-230",
    "snippet": "SYSCALL_DEFINE1(fsync, unsigned int, fd)\n{\n\treturn do_fsync(fd, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE1(fsync, unsigned int, fd)\n{\n\treturn do_fsync(fd, 0);\n}"
  },
  {
    "function_name": "fdatasync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "232-235",
    "snippet": "SYSCALL_DEFINE1(fdatasync, unsigned int, fd)\n{\n\treturn do_fsync(fd, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE1(fdatasync, unsigned int, fd)\n{\n\treturn do_fsync(fd, 1);\n}"
  },
  {
    "function_name": "sync_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "363-367",
    "snippet": "SYSCALL_DEFINE4(sync_file_range, int, fd, loff_t, offset, loff_t, nbytes,\n\t\t\t\tunsigned int, flags)\n{\n\treturn ksys_sync_file_range(fd, offset, nbytes, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE4(sync_file_range, int, fd, loff_t, offset, loff_t, nbytes,\n\t\t\t\tunsigned int, flags)\n{\n\treturn ksys_sync_file_range(fd, offset, nbytes, flags);\n}"
  },
  {
    "function_name": "sync_file_range2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
    "lines": "371-375",
    "snippet": "SYSCALL_DEFINE4(sync_file_range2, int, fd, unsigned int, flags,\n\t\t\t\t loff_t, offset, loff_t, nbytes)\n{\n\treturn ksys_sync_file_range(fd, offset, nbytes, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/backing-dev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/linkage.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE4(sync_file_range2, int, fd, unsigned int, flags,\n\t\t\t\t loff_t, offset, loff_t, nbytes)\n{\n\treturn ksys_sync_file_range(fd, offset, nbytes, flags);\n}"
  }
]