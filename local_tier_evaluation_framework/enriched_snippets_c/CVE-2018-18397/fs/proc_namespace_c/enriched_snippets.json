[
  {
    "function_name": "mountstats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "313-316",
    "snippet": "static int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsstat);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mounts_open_common",
          "args": [
            "inode",
            "file",
            "show_vfsstat"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "mounts_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "238-292",
          "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsstat);\n}"
  },
  {
    "function_name": "mountinfo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "308-311",
    "snippet": "static int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_mountinfo);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mounts_open_common",
          "args": [
            "inode",
            "file",
            "show_mountinfo"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "mounts_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "238-292",
          "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_mountinfo);\n}"
  },
  {
    "function_name": "mounts_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "303-306",
    "snippet": "static int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsmnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mounts_open_common",
          "args": [
            "inode",
            "file",
            "show_vfsmnt"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "mounts_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "238-292",
          "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsmnt);\n}"
  },
  {
    "function_name": "mounts_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "294-301",
    "snippet": "static int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct proc_mounts *p = m->private;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release_private(inode, file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "602-609",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "p->ns"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "put_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "3246-3252",
          "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&p->root"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct proc_mounts *p = m->private;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release_private(inode, file);\n}"
  },
  {
    "function_name": "mounts_open_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "238-292",
    "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "put_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "3246-3252",
          "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&root"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open_private",
          "args": [
            "file",
            "&mounts_op",
            "sizeof(struct proc_mounts)"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "638-642",
          "snippet": "int seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_root",
          "args": [
            "task->fs",
            "&root"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_root_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "230-238",
          "snippet": "static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "get_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "113-116",
          "snippet": "static inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc/internal.h",
          "lines": "121-124",
          "snippet": "static inline struct task_struct *get_proc_task(const struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern void pid_update_inode(struct task_struct *, struct inode *);",
            "bool proc_fill_cache(struct file *, struct dir_context *, const char *, unsigned int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern void pid_update_inode(struct task_struct *, struct inode *);\nbool proc_fill_cache(struct file *, struct dir_context *, const char *, unsigned int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(const struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tstruct seq_file *m;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = seq_open_private(file, &mounts_op, sizeof(struct proc_mounts));\n\tif (ret)\n\t\tgoto err_put_path;\n\n\tm = file->private_data;\n\tm->poll_event = ns->event;\n\n\tp = m->private;\n\tp->ns = ns;\n\tp->root = root;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
  },
  {
    "function_name": "show_vfsstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "193-236",
    "snippet": "static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err;\n\n\t/* device */\n\tif (sb->s_op->show_devname) {\n\t\tseq_puts(m, \"device \");\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tif (r->mnt_devname) {\n\t\t\tseq_puts(m, \"device \");\n\t\t\tmangle(m, r->mnt_devname);\n\t\t} else\n\t\t\tseq_puts(m, \"no device\");\n\t}\n\n\t/* mount point */\n\tseq_puts(m, \" mounted on \");\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\n\t/* file system type */\n\tseq_puts(m, \"with fstype \");\n\tshow_type(m, sb);\n\n\t/* optional statistics */\n\tif (sb->s_op->show_stats) {\n\t\tseq_putc(m, ' ');\n\t\terr = sb->s_op->show_stats(m, mnt_path.dentry);\n\t}\n\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "645-651",
          "snippet": "void seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_stats",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_type",
          "args": [
            "m",
            "sb"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "show_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "88-95",
          "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"with fstype \""
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "654-664",
          "snippet": "void seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path_root",
          "args": [
            "m",
            "&mnt_path",
            "&p->root",
            "\" \\t\\n\\\\\""
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "489-514",
          "snippet": "int seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "r->mnt_devname"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "83-86",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_devname",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __legitimize_mnt(struct vfsmount *, unsigned);",
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern int __legitimize_mnt(struct vfsmount *, unsigned);\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err;\n\n\t/* device */\n\tif (sb->s_op->show_devname) {\n\t\tseq_puts(m, \"device \");\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tif (r->mnt_devname) {\n\t\t\tseq_puts(m, \"device \");\n\t\t\tmangle(m, r->mnt_devname);\n\t\t} else\n\t\t\tseq_puts(m, \"no device\");\n\t}\n\n\t/* mount point */\n\tseq_puts(m, \" mounted on \");\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\n\t/* file system type */\n\tseq_puts(m, \"with fstype \");\n\tshow_type(m, sb);\n\n\t/* optional statistics */\n\tif (sb->s_op->show_stats) {\n\t\tseq_putc(m, ' ');\n\t\terr = sb->s_op->show_stats(m, mnt_path.dentry);\n\t}\n\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "show_mountinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "131-191",
    "snippet": "static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct super_block *sb = mnt->mnt_sb;\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tint err;\n\n\tseq_printf(m, \"%i %i %u:%u \", r->mnt_id, r->mnt_parent->mnt_id,\n\t\t   MAJOR(sb->s_dev), MINOR(sb->s_dev));\n\tif (sb->s_op->show_path) {\n\t\terr = sb->s_op->show_path(m, mnt->mnt_root);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tseq_dentry(m, mnt->mnt_root, \" \\t\\n\\\\\");\n\t}\n\tseq_putc(m, ' ');\n\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\n\tseq_puts(m, mnt->mnt_flags & MNT_READONLY ? \" ro\" : \" rw\");\n\tshow_mnt_opts(m, mnt);\n\n\t/* Tagged fields (\"foo:X\" or \"bar\") */\n\tif (IS_MNT_SHARED(r))\n\t\tseq_printf(m, \" shared:%i\", r->mnt_group_id);\n\tif (IS_MNT_SLAVE(r)) {\n\t\tint master = r->mnt_master->mnt_group_id;\n\t\tint dom = get_dominating_id(r, &p->root);\n\t\tseq_printf(m, \" master:%i\", master);\n\t\tif (dom && dom != master)\n\t\t\tseq_printf(m, \" propagate_from:%i\", dom);\n\t}\n\tif (IS_MNT_UNBINDABLE(r))\n\t\tseq_puts(m, \" unbindable\");\n\n\t/* Filesystem specific data */\n\tseq_puts(m, \" - \");\n\tshow_type(m, sb);\n\tseq_putc(m, ' ');\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt->mnt_root);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_puts(m, sb_rdonly(sb) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt->mnt_root);\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "645-651",
          "snippet": "void seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_options",
          "args": [
            "m",
            "mnt->mnt_root"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_sb_opts",
          "args": [
            "m",
            "sb"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "show_sb_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "45-62",
          "snippet": "static int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ SB_SYNCHRONOUS, \",sync\" },\n\t\t{ SB_DIRSYNC, \",dirsync\" },\n\t\t{ SB_MANDLOCK, \",mand\" },\n\t\t{ SB_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ SB_SYNCHRONOUS, \",sync\" },\n\t\t{ SB_DIRSYNC, \",dirsync\" },\n\t\t{ SB_MANDLOCK, \",mand\" },\n\t\t{ SB_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "sb_rdonly(sb) ? \" ro\" : \" rw\""
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "654-664",
          "snippet": "void seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "r->mnt_devname ? r->mnt_devname : \"none\""
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "83-86",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_devname",
          "args": [
            "m",
            "mnt->mnt_root"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_type",
          "args": [
            "m",
            "sb"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "show_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "88-95",
          "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_UNBINDABLE",
          "args": [
            "r"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" propagate_from:%i\"",
            "dom"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "401-408",
          "snippet": "void seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dominating_id",
          "args": [
            "r",
            "&p->root"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SLAVE",
          "args": [
            "r"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "r"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_mnt_opts",
          "args": [
            "m",
            "mnt"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "show_mnt_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "64-81",
          "snippet": "static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path_root",
          "args": [
            "m",
            "&mnt_path",
            "&p->root",
            "\" \\t\\n\\\\\""
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "489-514",
          "snippet": "int seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_dentry",
          "args": [
            "m",
            "mnt->mnt_root",
            "\" \\t\\n\\\\\""
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "seq_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "519-536",
          "snippet": "int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_path",
          "args": [
            "m",
            "mnt->mnt_root"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "sb->s_dev"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "sb->s_dev"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __legitimize_mnt(struct vfsmount *, unsigned);",
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern int __legitimize_mnt(struct vfsmount *, unsigned);\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct super_block *sb = mnt->mnt_sb;\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tint err;\n\n\tseq_printf(m, \"%i %i %u:%u \", r->mnt_id, r->mnt_parent->mnt_id,\n\t\t   MAJOR(sb->s_dev), MINOR(sb->s_dev));\n\tif (sb->s_op->show_path) {\n\t\terr = sb->s_op->show_path(m, mnt->mnt_root);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tseq_dentry(m, mnt->mnt_root, \" \\t\\n\\\\\");\n\t}\n\tseq_putc(m, ' ');\n\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\n\tseq_puts(m, mnt->mnt_flags & MNT_READONLY ? \" ro\" : \" rw\");\n\tshow_mnt_opts(m, mnt);\n\n\t/* Tagged fields (\"foo:X\" or \"bar\") */\n\tif (IS_MNT_SHARED(r))\n\t\tseq_printf(m, \" shared:%i\", r->mnt_group_id);\n\tif (IS_MNT_SLAVE(r)) {\n\t\tint master = r->mnt_master->mnt_group_id;\n\t\tint dom = get_dominating_id(r, &p->root);\n\t\tseq_printf(m, \" master:%i\", master);\n\t\tif (dom && dom != master)\n\t\t\tseq_printf(m, \" propagate_from:%i\", dom);\n\t}\n\tif (IS_MNT_UNBINDABLE(r))\n\t\tseq_puts(m, \" unbindable\");\n\n\t/* Filesystem specific data */\n\tseq_puts(m, \" - \");\n\tshow_type(m, sb);\n\tseq_putc(m, ' ');\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt->mnt_root);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_puts(m, sb_rdonly(sb) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt->mnt_root);\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "show_vfsmnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "97-129",
    "snippet": "static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err;\n\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_putc(m, ' ');\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\tshow_type(m, sb);\n\tseq_puts(m, __mnt_is_readonly(mnt) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tshow_mnt_opts(m, mnt);\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt_path.dentry);\n\tseq_puts(m, \" 0 0\\n\");\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" 0 0\\n\""
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "654-664",
          "snippet": "void seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_options",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_mnt_opts",
          "args": [
            "m",
            "mnt"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "show_mnt_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "64-81",
          "snippet": "static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_sb_opts",
          "args": [
            "m",
            "sb"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "show_sb_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "45-62",
          "snippet": "static int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ SB_SYNCHRONOUS, \",sync\" },\n\t\t{ SB_DIRSYNC, \",dirsync\" },\n\t\t{ SB_MANDLOCK, \",mand\" },\n\t\t{ SB_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ SB_SYNCHRONOUS, \",sync\" },\n\t\t{ SB_DIRSYNC, \",dirsync\" },\n\t\t{ SB_MANDLOCK, \",mand\" },\n\t\t{ SB_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_is_readonly",
          "args": [
            "mnt"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_is_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "248-255",
          "snippet": "int __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (sb_rdonly(mnt->mnt_sb))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nint __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (sb_rdonly(mnt->mnt_sb))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_type",
          "args": [
            "m",
            "sb"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "show_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "88-95",
          "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "' '"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "645-651",
          "snippet": "void seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path_root",
          "args": [
            "m",
            "&mnt_path",
            "&p->root",
            "\" \\t\\n\\\\\""
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "489-514",
          "snippet": "int seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "r->mnt_devname ? r->mnt_devname : \"none\""
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "83-86",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_devname",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "77-80",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int __legitimize_mnt(struct vfsmount *, unsigned);",
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern int __legitimize_mnt(struct vfsmount *, unsigned);\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = m->private;\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err;\n\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_putc(m, ' ');\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\tshow_type(m, sb);\n\tseq_puts(m, __mnt_is_readonly(mnt) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tshow_mnt_opts(m, mnt);\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt_path.dentry);\n\tseq_puts(m, \" 0 0\\n\");\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "show_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "88-95",
    "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "sb->s_subtype"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
          "lines": "83-86",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/sched/task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'.'"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "645-651",
          "snippet": "void seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count >= m->size)\n\t\treturn;\n\n\tm->buf[m->count++] = c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
  },
  {
    "function_name": "mangle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "83-86",
    "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "s",
            "\" \\t\\n\\\\\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "seq_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "375-383",
          "snippet": "void seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint ret;\n\n\tret = string_escape_str(s, buf, size, ESCAPE_OCTAL, esc);\n\tseq_commit(m, ret < size ? ret : -1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint ret;\n\n\tret = string_escape_str(s, buf, size, ESCAPE_OCTAL, esc);\n\tseq_commit(m, ret < size ? ret : -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
  },
  {
    "function_name": "show_mnt_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "64-81",
    "snippet": "static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "fs_infop->str"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "654-664",
          "snippet": "void seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}"
  },
  {
    "function_name": "show_sb_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "45-62",
    "snippet": "static int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ SB_SYNCHRONOUS, \",sync\" },\n\t\t{ SB_DIRSYNC, \",dirsync\" },\n\t\t{ SB_MANDLOCK, \",mand\" },\n\t\t{ SB_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_sb_show_options",
          "args": [
            "m",
            "sb"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "fs_infop->str"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "654-664",
          "snippet": "void seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\n\tif (m->count + len >= m->size) {\n\t\tseq_set_overflow(m);\n\t\treturn;\n\t}\n\tmemcpy(m->buf + m->count, s, len);\n\tm->count += len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ SB_SYNCHRONOUS, \",sync\" },\n\t\t{ SB_DIRSYNC, \",dirsync\" },\n\t\t{ SB_MANDLOCK, \",mand\" },\n\t\t{ SB_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}"
  },
  {
    "function_name": "mounts_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/proc_namespace.c",
    "lines": "21-38",
    "snippet": "static __poll_t mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct proc_mounts *p = m->private;\n\tstruct mnt_namespace *ns = p->ns;\n\t__poll_t res = EPOLLIN | EPOLLRDNORM;\n\tint event;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\n\tevent = READ_ONCE(ns->event);\n\tif (m->poll_event != event) {\n\t\tm->poll_event = event;\n\t\tres |= EPOLLERR | EPOLLPRI;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/sched/task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ns->event"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&p->ns->poll",
            "wait"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/sched/task.h>\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic __poll_t mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct proc_mounts *p = m->private;\n\tstruct mnt_namespace *ns = p->ns;\n\t__poll_t res = EPOLLIN | EPOLLRDNORM;\n\tint event;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\n\tevent = READ_ONCE(ns->event);\n\tif (m->poll_event != event) {\n\t\tm->poll_event = event;\n\t\tres |= EPOLLERR | EPOLLPRI;\n\t}\n\n\treturn res;\n}"
  }
]