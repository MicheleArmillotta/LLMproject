[
  {
    "function_name": "do_tee",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1703-1728",
    "snippet": "static long do_tee(struct file *in, struct file *out, size_t len,\n\t\t   unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe = get_pipe_info(in);\n\tstruct pipe_inode_info *opipe = get_pipe_info(out);\n\tint ret = -EINVAL;\n\n\t/*\n\t * Duplicate the contents of ipipe to opipe without actually\n\t * copying the data.\n\t */\n\tif (ipipe && opipe && ipipe != opipe) {\n\t\t/*\n\t\t * Keep going, unless we encounter an error. The ipipe/opipe\n\t\t * ordering doesn't really matter.\n\t\t */\n\t\tret = ipipe_prep(ipipe, flags);\n\t\tif (!ret) {\n\t\t\tret = opipe_prep(opipe, flags);\n\t\t\tif (!ret)\n\t\t\t\tret = link_pipe(ipipe, opipe, len, flags);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "link_pipe",
          "args": [
            "ipipe",
            "opipe",
            "len",
            "flags"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "link_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1622-1695",
          "snippet": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opipe_prep",
          "args": [
            "opipe",
            "flags"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "opipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1467-1502",
          "snippet": "static int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipipe_prep",
          "args": [
            "ipipe",
            "flags"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "ipipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1429-1461",
          "snippet": "static int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "out"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "1117-1120",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_tee(struct file *in, struct file *out, size_t len,\n\t\t   unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe = get_pipe_info(in);\n\tstruct pipe_inode_info *opipe = get_pipe_info(out);\n\tint ret = -EINVAL;\n\n\t/*\n\t * Duplicate the contents of ipipe to opipe without actually\n\t * copying the data.\n\t */\n\tif (ipipe && opipe && ipipe != opipe) {\n\t\t/*\n\t\t * Keep going, unless we encounter an error. The ipipe/opipe\n\t\t * ordering doesn't really matter.\n\t\t */\n\t\tret = ipipe_prep(ipipe, flags);\n\t\tif (!ret) {\n\t\t\tret = opipe_prep(opipe, flags);\n\t\t\tif (!ret)\n\t\t\t\tret = link_pipe(ipipe, opipe, len, flags);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "link_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1622-1695",
    "snippet": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_pipe_readers",
          "args": [
            "opipe"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "166-172",
          "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "opipe"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_buf_get",
          "args": [
            "ipipe",
            "ibuf"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "192-195",
          "snippet": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_double_lock",
          "args": [
            "ipipe",
            "opipe"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "91-103",
          "snippet": "void pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "splice_pipe_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1507-1617",
    "snippet": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_pipe_writers",
          "args": [
            "ipipe"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "456-462",
          "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_pipe_readers",
          "args": [
            "opipe"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "166-172",
          "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "opipe"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_buf_get",
          "args": [
            "ipipe",
            "ibuf"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "192-195",
          "snippet": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_double_lock",
          "args": [
            "ipipe",
            "opipe"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "91-103",
          "snippet": "void pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "opipe_prep",
          "args": [
            "opipe",
            "flags"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "opipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1467-1502",
          "snippet": "static int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipipe_prep",
          "args": [
            "ipipe",
            "flags"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "ipipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1429-1461",
          "snippet": "static int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "opipe_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1467-1502",
    "snippet": "static int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "106-119",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "ipipe_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1429-1461",
    "snippet": "static int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "106-119",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "do_vmsplice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1328-1340",
    "snippet": "static long do_vmsplice(struct file *f, struct iov_iter *iter, unsigned int flags)\n{\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == WRITE)\n\t\treturn vmsplice_to_pipe(f, iter, flags);\n\telse\n\t\treturn vmsplice_to_user(f, iter, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmsplice_to_user",
          "args": [
            "f",
            "iter",
            "flags"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "vmsplice_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1245-1266",
          "snippet": "static long vmsplice_to_user(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe = get_pipe_info(file);\n\tstruct splice_desc sd = {\n\t\t.total_len = iov_iter_count(iter),\n\t\t.flags = flags,\n\t\t.u.data = iter\n\t};\n\tlong ret = 0;\n\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (sd.total_len) {\n\t\tpipe_lock(pipe);\n\t\tret = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tpipe_unlock(pipe);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long vmsplice_to_user(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe = get_pipe_info(file);\n\tstruct splice_desc sd = {\n\t\t.total_len = iov_iter_count(iter),\n\t\t.flags = flags,\n\t\t.u.data = iter\n\t};\n\tlong ret = 0;\n\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (sd.total_len) {\n\t\tpipe_lock(pipe);\n\t\tret = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tpipe_unlock(pipe);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmsplice_to_pipe",
          "args": [
            "f",
            "iter",
            "flags"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "vmsplice_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1273-1295",
          "snippet": "static long vmsplice_to_pipe(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret = 0;\n\tunsigned buf_flag = 0;\n\n\tif (flags & SPLICE_F_GIFT)\n\t\tbuf_flag = PIPE_BUF_FLAG_GIFT;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tpipe_lock(pipe);\n\tret = wait_for_space(pipe, flags);\n\tif (!ret)\n\t\tret = iter_to_pipe(iter, pipe, buf_flag);\n\tpipe_unlock(pipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long vmsplice_to_pipe(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret = 0;\n\tunsigned buf_flag = 0;\n\n\tif (flags & SPLICE_F_GIFT)\n\t\tbuf_flag = PIPE_BUF_FLAG_GIFT;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tpipe_lock(pipe);\n\tret = wait_for_space(pipe, flags);\n\tif (!ret)\n\t\tret = iter_to_pipe(iter, pipe, buf_flag);\n\tpipe_unlock(pipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(pipe);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_rw",
          "args": [
            "iter"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & ~SPLICE_F_ALL"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_vmsplice(struct file *f, struct iov_iter *iter, unsigned int flags)\n{\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == WRITE)\n\t\treturn vmsplice_to_pipe(f, iter, flags);\n\telse\n\t\treturn vmsplice_to_user(f, iter, flags);\n}"
  },
  {
    "function_name": "vmsplice_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1297-1310",
    "snippet": "static int vmsplice_type(struct fd f, int *type)\n{\n\tif (!f.file)\n\t\treturn -EBADF;\n\tif (f.file->f_mode & FMODE_WRITE) {\n\t\t*type = WRITE;\n\t} else if (f.file->f_mode & FMODE_READ) {\n\t\t*type = READ;\n\t} else {\n\t\tfdput(f);\n\t\treturn -EBADF;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int vmsplice_type(struct fd f, int *type)\n{\n\tif (!f.file)\n\t\treturn -EBADF;\n\tif (f.file->f_mode & FMODE_WRITE) {\n\t\t*type = WRITE;\n\t} else if (f.file->f_mode & FMODE_READ) {\n\t\t*type = READ;\n\t} else {\n\t\tfdput(f);\n\t\treturn -EBADF;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "vmsplice_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1273-1295",
    "snippet": "static long vmsplice_to_pipe(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret = 0;\n\tunsigned buf_flag = 0;\n\n\tif (flags & SPLICE_F_GIFT)\n\t\tbuf_flag = PIPE_BUF_FLAG_GIFT;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tpipe_lock(pipe);\n\tret = wait_for_space(pipe, flags);\n\tif (!ret)\n\t\tret = iter_to_pipe(iter, pipe, buf_flag);\n\tpipe_unlock(pipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_pipe_readers",
          "args": [
            "pipe"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "166-172",
          "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_to_pipe",
          "args": [
            "iter",
            "pipe",
            "buf_flag"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "iter_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1188-1232",
          "snippet": "static int iter_to_pipe(struct iov_iter *from,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tunsigned flags)\n{\n\tstruct pipe_buffer buf = {\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.flags = flags\n\t};\n\tsize_t total = 0;\n\tint ret = 0;\n\tbool failed = false;\n\n\twhile (iov_iter_count(from) && !failed) {\n\t\tstruct page *pages[16];\n\t\tssize_t copied;\n\t\tsize_t start;\n\t\tint n;\n\n\t\tcopied = iov_iter_get_pages(from, pages, ~0UL, 16, &start);\n\t\tif (copied <= 0) {\n\t\t\tret = copied;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (n = 0; copied; n++, start = 0) {\n\t\t\tint size = min_t(int, copied, PAGE_SIZE - start);\n\t\t\tif (!failed) {\n\t\t\t\tbuf.page = pages[n];\n\t\t\t\tbuf.offset = start;\n\t\t\t\tbuf.len = size;\n\t\t\t\tret = add_to_pipe(pipe, &buf);\n\t\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\t\tfailed = true;\n\t\t\t\t} else {\n\t\t\t\t\tiov_iter_advance(from, ret);\n\t\t\t\t\ttotal += ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tput_page(pages[n]);\n\t\t\t}\n\t\t\tcopied -= size;\n\t\t}\n\t}\n\treturn total ? total : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct pipe_buf_operations user_page_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = user_page_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic const struct pipe_buf_operations user_page_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = user_page_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int iter_to_pipe(struct iov_iter *from,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tunsigned flags)\n{\n\tstruct pipe_buffer buf = {\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.flags = flags\n\t};\n\tsize_t total = 0;\n\tint ret = 0;\n\tbool failed = false;\n\n\twhile (iov_iter_count(from) && !failed) {\n\t\tstruct page *pages[16];\n\t\tssize_t copied;\n\t\tsize_t start;\n\t\tint n;\n\n\t\tcopied = iov_iter_get_pages(from, pages, ~0UL, 16, &start);\n\t\tif (copied <= 0) {\n\t\t\tret = copied;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (n = 0; copied; n++, start = 0) {\n\t\t\tint size = min_t(int, copied, PAGE_SIZE - start);\n\t\t\tif (!failed) {\n\t\t\t\tbuf.page = pages[n];\n\t\t\t\tbuf.offset = start;\n\t\t\t\tbuf.len = size;\n\t\t\t\tret = add_to_pipe(pipe, &buf);\n\t\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\t\tfailed = true;\n\t\t\t\t} else {\n\t\t\t\t\tiov_iter_advance(from, ret);\n\t\t\t\t\ttotal += ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tput_page(pages[n]);\n\t\t\t}\n\t\t\tcopied -= size;\n\t\t}\n\t}\n\treturn total ? total : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_space",
          "args": [
            "pipe",
            "flags"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1069-1086",
          "snippet": "static int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)\n{\n\tfor (;;) {\n\t\tif (unlikely(!pipe->readers)) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (pipe->nrbufs != pipe->buffers)\n\t\t\treturn 0;\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)\n{\n\tfor (;;) {\n\t\tif (unlikely(!pipe->readers)) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (pipe->nrbufs != pipe->buffers)\n\t\t\treturn 0;\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "file"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "1117-1120",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long vmsplice_to_pipe(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret = 0;\n\tunsigned buf_flag = 0;\n\n\tif (flags & SPLICE_F_GIFT)\n\t\tbuf_flag = PIPE_BUF_FLAG_GIFT;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tpipe_lock(pipe);\n\tret = wait_for_space(pipe, flags);\n\tif (!ret)\n\t\tret = iter_to_pipe(iter, pipe, buf_flag);\n\tpipe_unlock(pipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "vmsplice_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1245-1266",
    "snippet": "static long vmsplice_to_user(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe = get_pipe_info(file);\n\tstruct splice_desc sd = {\n\t\t.total_len = iov_iter_count(iter),\n\t\t.flags = flags,\n\t\t.u.data = iter\n\t};\n\tlong ret = 0;\n\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (sd.total_len) {\n\t\tpipe_lock(pipe);\n\t\tret = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tpipe_unlock(pipe);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__splice_from_pipe",
          "args": [
            "pipe",
            "&sd",
            "pipe_to_user"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "__splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "617-632",
          "snippet": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tcond_resched();\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tcond_resched();\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "file"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "1117-1120",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long vmsplice_to_user(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe = get_pipe_info(file);\n\tstruct splice_desc sd = {\n\t\t.total_len = iov_iter_count(iter),\n\t\t.flags = flags,\n\t\t.u.data = iter\n\t};\n\tlong ret = 0;\n\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (sd.total_len) {\n\t\tpipe_lock(pipe);\n\t\tret = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\t\tpipe_unlock(pipe);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pipe_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1234-1239",
    "snippet": "static int pipe_to_user(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tint n = copy_page_to_iter(buf->page, buf->offset, sd->len, sd->u.data);\n\treturn n == sd->len ? n : -EFAULT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "buf->page",
            "buf->offset",
            "sd->len",
            "sd->u.data"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int pipe_to_user(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tint n = copy_page_to_iter(buf->page, buf->offset, sd->len, sd->u.data);\n\treturn n == sd->len ? n : -EFAULT;\n}"
  },
  {
    "function_name": "iter_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1188-1232",
    "snippet": "static int iter_to_pipe(struct iov_iter *from,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tunsigned flags)\n{\n\tstruct pipe_buffer buf = {\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.flags = flags\n\t};\n\tsize_t total = 0;\n\tint ret = 0;\n\tbool failed = false;\n\n\twhile (iov_iter_count(from) && !failed) {\n\t\tstruct page *pages[16];\n\t\tssize_t copied;\n\t\tsize_t start;\n\t\tint n;\n\n\t\tcopied = iov_iter_get_pages(from, pages, ~0UL, 16, &start);\n\t\tif (copied <= 0) {\n\t\t\tret = copied;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (n = 0; copied; n++, start = 0) {\n\t\t\tint size = min_t(int, copied, PAGE_SIZE - start);\n\t\t\tif (!failed) {\n\t\t\t\tbuf.page = pages[n];\n\t\t\t\tbuf.offset = start;\n\t\t\t\tbuf.len = size;\n\t\t\t\tret = add_to_pipe(pipe, &buf);\n\t\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\t\tfailed = true;\n\t\t\t\t} else {\n\t\t\t\t\tiov_iter_advance(from, ret);\n\t\t\t\t\ttotal += ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tput_page(pages[n]);\n\t\t\t}\n\t\t\tcopied -= size;\n\t\t}\n\t}\n\treturn total ? total : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pipe_buf_operations user_page_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = user_page_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[n]"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "from",
            "ret"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_pipe",
          "args": [
            "pipe",
            "&buf"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "230-247",
          "snippet": "ssize_t add_to_pipe(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tint ret;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t} else if (pipe->nrbufs == pipe->buffers) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tpipe->bufs[newbuf] = *buf;\n\t\tpipe->nrbufs++;\n\t\treturn buf->len;\n\t}\n\tpipe_buf_release(pipe, buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nssize_t add_to_pipe(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tint ret;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t} else if (pipe->nrbufs == pipe->buffers) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tpipe->bufs[newbuf] = *buf;\n\t\tpipe->nrbufs++;\n\t\treturn buf->len;\n\t}\n\tpipe_buf_release(pipe, buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "copied",
            "PAGE_SIZE - start"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_get_pages",
          "args": [
            "from",
            "pages",
            "~0UL",
            "16",
            "&start"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic const struct pipe_buf_operations user_page_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = user_page_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int iter_to_pipe(struct iov_iter *from,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tunsigned flags)\n{\n\tstruct pipe_buffer buf = {\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.flags = flags\n\t};\n\tsize_t total = 0;\n\tint ret = 0;\n\tbool failed = false;\n\n\twhile (iov_iter_count(from) && !failed) {\n\t\tstruct page *pages[16];\n\t\tssize_t copied;\n\t\tsize_t start;\n\t\tint n;\n\n\t\tcopied = iov_iter_get_pages(from, pages, ~0UL, 16, &start);\n\t\tif (copied <= 0) {\n\t\t\tret = copied;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (n = 0; copied; n++, start = 0) {\n\t\t\tint size = min_t(int, copied, PAGE_SIZE - start);\n\t\t\tif (!failed) {\n\t\t\t\tbuf.page = pages[n];\n\t\t\t\tbuf.offset = start;\n\t\t\t\tbuf.len = size;\n\t\t\t\tret = add_to_pipe(pipe, &buf);\n\t\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\t\tfailed = true;\n\t\t\t\t} else {\n\t\t\t\t\tiov_iter_advance(from, ret);\n\t\t\t\t\ttotal += ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tput_page(pages[n]);\n\t\t\t}\n\t\t\tcopied -= size;\n\t\t}\n\t}\n\treturn total ? total : ret;\n}"
  },
  {
    "function_name": "do_splice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1095-1186",
    "snippet": "static long do_splice(struct file *in, loff_t __user *off_in,\n\t\t      struct file *out, loff_t __user *off_out,\n\t\t      size_t len, unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe;\n\tstruct pipe_inode_info *opipe;\n\tloff_t offset;\n\tlong ret;\n\n\tipipe = get_pipe_info(in);\n\topipe = get_pipe_info(out);\n\n\tif (ipipe && opipe) {\n\t\tif (off_in || off_out)\n\t\t\treturn -ESPIPE;\n\n\t\tif (!(in->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\n\t\tif (!(out->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\t/* Splicing to self would be fun, but... */\n\t\tif (ipipe == opipe)\n\t\t\treturn -EINVAL;\n\n\t\treturn splice_pipe_to_pipe(ipipe, opipe, len, flags);\n\t}\n\n\tif (ipipe) {\n\t\tif (off_in)\n\t\t\treturn -ESPIPE;\n\t\tif (off_out) {\n\t\t\tif (!(out->f_mode & FMODE_PWRITE))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_out, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = out->f_pos;\n\t\t}\n\n\t\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\t\treturn -EBADF;\n\n\t\tif (unlikely(out->f_flags & O_APPEND))\n\t\t\treturn -EINVAL;\n\n\t\tret = rw_verify_area(WRITE, out, &offset, len);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tfile_start_write(out);\n\t\tret = do_splice_from(ipipe, out, &offset, len, flags);\n\t\tfile_end_write(out);\n\n\t\tif (!off_out)\n\t\t\tout->f_pos = offset;\n\t\telse if (copy_to_user(off_out, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\tif (opipe) {\n\t\tif (off_out)\n\t\t\treturn -ESPIPE;\n\t\tif (off_in) {\n\t\t\tif (!(in->f_mode & FMODE_PREAD))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_in, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = in->f_pos;\n\t\t}\n\n\t\tpipe_lock(opipe);\n\t\tret = wait_for_space(opipe, flags);\n\t\tif (!ret)\n\t\t\tret = do_splice_to(in, &offset, opipe, len, flags);\n\t\tpipe_unlock(opipe);\n\t\tif (ret > 0)\n\t\t\twakeup_pipe_readers(opipe);\n\t\tif (!off_in)\n\t\t\tin->f_pos = offset;\n\t\telse if (copy_to_user(off_in, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "off_in",
            "&offset",
            "sizeof(loff_t)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_pipe_readers",
          "args": [
            "opipe"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "166-172",
          "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "opipe"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_splice_to",
          "args": [
            "in",
            "&offset",
            "opipe",
            "len",
            "flags"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "857-881",
          "snippet": "static long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(len > MAX_RW_COUNT))\n\t\tlen = MAX_RW_COUNT;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(len > MAX_RW_COUNT))\n\t\tlen = MAX_RW_COUNT;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_space",
          "args": [
            "opipe",
            "flags"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1069-1086",
          "snippet": "static int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)\n{\n\tfor (;;) {\n\t\tif (unlikely(!pipe->readers)) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (pipe->nrbufs != pipe->buffers)\n\t\t\treturn 0;\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)\n{\n\tfor (;;) {\n\t\tif (unlikely(!pipe->readers)) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (pipe->nrbufs != pipe->buffers)\n\t\t\treturn 0;\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "opipe"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&offset",
            "off_in",
            "sizeof(loff_t)"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "off_out",
            "&offset",
            "sizeof(loff_t)"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "out"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_from",
          "args": [
            "ipipe",
            "out",
            "&offset",
            "len",
            "flags"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "840-852",
          "snippet": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "out"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "out",
            "&offset",
            "len"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "out->f_flags & O_APPEND"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(out->f_mode & FMODE_WRITE)"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_pipe_to_pipe",
          "args": [
            "ipipe",
            "opipe",
            "len",
            "flags"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "splice_pipe_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1507-1617",
          "snippet": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "out"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "1117-1120",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice(struct file *in, loff_t __user *off_in,\n\t\t      struct file *out, loff_t __user *off_out,\n\t\t      size_t len, unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe;\n\tstruct pipe_inode_info *opipe;\n\tloff_t offset;\n\tlong ret;\n\n\tipipe = get_pipe_info(in);\n\topipe = get_pipe_info(out);\n\n\tif (ipipe && opipe) {\n\t\tif (off_in || off_out)\n\t\t\treturn -ESPIPE;\n\n\t\tif (!(in->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\n\t\tif (!(out->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\t/* Splicing to self would be fun, but... */\n\t\tif (ipipe == opipe)\n\t\t\treturn -EINVAL;\n\n\t\treturn splice_pipe_to_pipe(ipipe, opipe, len, flags);\n\t}\n\n\tif (ipipe) {\n\t\tif (off_in)\n\t\t\treturn -ESPIPE;\n\t\tif (off_out) {\n\t\t\tif (!(out->f_mode & FMODE_PWRITE))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_out, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = out->f_pos;\n\t\t}\n\n\t\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\t\treturn -EBADF;\n\n\t\tif (unlikely(out->f_flags & O_APPEND))\n\t\t\treturn -EINVAL;\n\n\t\tret = rw_verify_area(WRITE, out, &offset, len);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tfile_start_write(out);\n\t\tret = do_splice_from(ipipe, out, &offset, len, flags);\n\t\tfile_end_write(out);\n\n\t\tif (!off_out)\n\t\t\tout->f_pos = offset;\n\t\telse if (copy_to_user(off_out, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\tif (opipe) {\n\t\tif (off_out)\n\t\t\treturn -ESPIPE;\n\t\tif (off_in) {\n\t\t\tif (!(in->f_mode & FMODE_PREAD))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_in, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = in->f_pos;\n\t\t}\n\n\t\tpipe_lock(opipe);\n\t\tret = wait_for_space(opipe, flags);\n\t\tif (!ret)\n\t\t\tret = do_splice_to(in, &offset, opipe, len, flags);\n\t\tpipe_unlock(opipe);\n\t\tif (ret > 0)\n\t\t\twakeup_pipe_readers(opipe);\n\t\tif (!off_in)\n\t\t\tin->f_pos = offset;\n\t\telse if (copy_to_user(off_in, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "wait_for_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1069-1086",
    "snippet": "static int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)\n{\n\tfor (;;) {\n\t\tif (unlikely(!pipe->readers)) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (pipe->nrbufs != pipe->buffers)\n\t\t\treturn 0;\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "106-119",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pipe->readers"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int wait_for_space(struct pipe_inode_info *pipe, unsigned flags)\n{\n\tfor (;;) {\n\t\tif (unlikely(!pipe->readers)) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (pipe->nrbufs != pipe->buffers)\n\t\t\treturn 0;\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n}"
  },
  {
    "function_name": "do_splice_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1038-1066",
    "snippet": "long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_direct_to_actor",
          "args": [
            "in",
            "&sd",
            "direct_splice_actor"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "splice_direct_to_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "896-1010",
          "snippet": "ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags, more;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\tmore = sd->flags & SPLICE_F_MORE;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * If more data is pending, set SPLICE_F_MORE\n\t\t * If this is the last data and SPLICE_F_MORE was not set\n\t\t * initially, clears it.\n\t\t */\n\t\tif (read_len < len)\n\t\t\tsd->flags |= SPLICE_F_MORE;\n\t\telse if (!more)\n\t\t\tsd->flags &= ~SPLICE_F_MORE;\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags, more;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\tmore = sd->flags & SPLICE_F_MORE;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * If more data is pending, set SPLICE_F_MORE\n\t\t * If this is the last data and SPLICE_F_MORE was not set\n\t\t * initially, clears it.\n\t\t */\n\t\tif (read_len < len)\n\t\t\tsd->flags |= SPLICE_F_MORE;\n\t\telse if (!more)\n\t\t\tsd->flags &= ~SPLICE_F_MORE;\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "out",
            "opos",
            "len"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "out->f_flags & O_APPEND"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(out->f_mode & FMODE_WRITE)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "direct_splice_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1013-1020",
    "snippet": "static int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_splice_from",
          "args": [
            "pipe",
            "file",
            "sd->opos",
            "sd->total_len",
            "sd->flags"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "840-852",
          "snippet": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}"
  },
  {
    "function_name": "splice_direct_to_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "896-1010",
    "snippet": "ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags, more;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\tmore = sd->flags & SPLICE_F_MORE;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * If more data is pending, set SPLICE_F_MORE\n\t\t * If this is the last data and SPLICE_F_MORE was not set\n\t\t * initially, clears it.\n\t\t */\n\t\tif (read_len < len)\n\t\t\tsd->flags |= SPLICE_F_MORE;\n\t\telse if (!more)\n\t\t\tsd->flags &= ~SPLICE_F_MORE;\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_buf_release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_pipe_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "91-96",
          "snippet": "static void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "in"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_file_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/file.c",
          "lines": "155-175",
          "snippet": "static void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/uio.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/uio.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actor",
          "args": [
            "pipe",
            "sd"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "direct_splice_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "1013-1020",
          "snippet": "static int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_to",
          "args": [
            "in",
            "&pos",
            "pipe",
            "len",
            "flags"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "857-881",
          "snippet": "static long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(len > MAX_RW_COUNT))\n\t\tlen = MAX_RW_COUNT;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(len > MAX_RW_COUNT))\n\t\tlen = MAX_RW_COUNT;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pipe_info",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "625-668",
          "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int pipe_max_size = 1048576;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\tstruct user_struct *user = get_current_user();\n\tunsigned long user_bufs;\n\tunsigned int max_size = READ_ONCE(pipe_max_size);\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n\tif (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))\n\t\tpipe_bufs = max_size >> PAGE_SHIFT;\n\n\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\n\n\tif (too_many_pipe_buffers_soft(user_bufs) && is_unprivileged_user()) {\n\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, 1);\n\t\tpipe_bufs = 1;\n\t}\n\n\tif (too_many_pipe_buffers_hard(user_bufs) && is_unprivileged_user())\n\t\tgoto out_revert_acct;\n\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->buffers = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\nout_revert_acct:\n\t(void) account_pipe_buffers(user, pipe_bufs, 0);\n\tkfree(pipe);\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pipe"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!S_ISREG(i_mode) && !S_ISBLK(i_mode)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "i_mode"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "i_mode"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "in"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags, more;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\tmore = sd->flags & SPLICE_F_MORE;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * If more data is pending, set SPLICE_F_MORE\n\t\t * If this is the last data and SPLICE_F_MORE was not set\n\t\t * initially, clears it.\n\t\t */\n\t\tif (read_len < len)\n\t\t\tsd->flags |= SPLICE_F_MORE;\n\t\telse if (!more)\n\t\t\tsd->flags &= ~SPLICE_F_MORE;\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}"
  },
  {
    "function_name": "do_splice_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "857-881",
    "snippet": "static long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(len > MAX_RW_COUNT))\n\t\tlen = MAX_RW_COUNT;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_read",
          "args": [
            "in",
            "ppos",
            "pipe",
            "len",
            "flags"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "default_file_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "368-431",
          "snippet": "static ssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tstruct kvec *vec, __vec[PIPE_DEF_BUFFERS];\n\tstruct iov_iter to;\n\tstruct page **pages;\n\tunsigned int nr_pages;\n\tsize_t offset, base, copied = 0;\n\tssize_t res;\n\tint i;\n\n\tif (pipe->nrbufs == pipe->buffers)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Try to keep page boundaries matching to source pagecache ones -\n\t * it probably won't be much help, but...\n\t */\n\toffset = *ppos & ~PAGE_MASK;\n\n\tiov_iter_pipe(&to, READ, pipe, len + offset);\n\n\tres = iov_iter_get_pages_alloc(&to, &pages, len + offset, &base);\n\tif (res <= 0)\n\t\treturn -ENOMEM;\n\n\tnr_pages = DIV_ROUND_UP(res + base, PAGE_SIZE);\n\n\tvec = __vec;\n\tif (nr_pages > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc_array(nr_pages, sizeof(struct kvec), GFP_KERNEL);\n\t\tif (unlikely(!vec)) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpipe->bufs[to.idx].offset = offset;\n\tpipe->bufs[to.idx].len -= offset;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tsize_t this_len = min_t(size_t, len, PAGE_SIZE - offset);\n\t\tvec[i].iov_base = page_address(pages[i]) + offset;\n\t\tvec[i].iov_len = this_len;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, nr_pages, *ppos);\n\tif (res > 0) {\n\t\tcopied = res;\n\t\t*ppos += res;\n\t}\n\n\tif (vec != __vec)\n\t\tkfree(vec);\nout:\n\tfor (i = 0; i < nr_pages; i++)\n\t\tput_page(pages[i]);\n\tkvfree(pages);\n\tiov_iter_advance(&to, copied);\t/* truncates and discards */\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic ssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tstruct kvec *vec, __vec[PIPE_DEF_BUFFERS];\n\tstruct iov_iter to;\n\tstruct page **pages;\n\tunsigned int nr_pages;\n\tsize_t offset, base, copied = 0;\n\tssize_t res;\n\tint i;\n\n\tif (pipe->nrbufs == pipe->buffers)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Try to keep page boundaries matching to source pagecache ones -\n\t * it probably won't be much help, but...\n\t */\n\toffset = *ppos & ~PAGE_MASK;\n\n\tiov_iter_pipe(&to, READ, pipe, len + offset);\n\n\tres = iov_iter_get_pages_alloc(&to, &pages, len + offset, &base);\n\tif (res <= 0)\n\t\treturn -ENOMEM;\n\n\tnr_pages = DIV_ROUND_UP(res + base, PAGE_SIZE);\n\n\tvec = __vec;\n\tif (nr_pages > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc_array(nr_pages, sizeof(struct kvec), GFP_KERNEL);\n\t\tif (unlikely(!vec)) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpipe->bufs[to.idx].offset = offset;\n\tpipe->bufs[to.idx].len -= offset;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tsize_t this_len = min_t(size_t, len, PAGE_SIZE - offset);\n\t\tvec[i].iov_base = page_address(pages[i]) + offset;\n\t\tvec[i].iov_len = this_len;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, nr_pages, *ppos);\n\tif (res > 0) {\n\t\tcopied = res;\n\t\t*ppos += res;\n\t}\n\n\tif (vec != __vec)\n\t\tkfree(vec);\nout:\n\tfor (i = 0; i < nr_pages; i++)\n\t\tput_page(pages[i]);\n\tkvfree(pages);\n\tiov_iter_advance(&to, copied);\t/* truncates and discards */\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "len > MAX_RW_COUNT"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "READ",
            "in",
            "ppos",
            "len"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(in->f_mode & FMODE_READ)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (unlikely(len > MAX_RW_COUNT))\n\t\tlen = MAX_RW_COUNT;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}"
  },
  {
    "function_name": "do_splice_from",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "840-852",
    "snippet": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_write",
          "args": [
            "pipe",
            "out",
            "ppos",
            "len",
            "flags"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "default_file_splice_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "803-814",
          "snippet": "static ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}"
  },
  {
    "function_name": "generic_splice_sendpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "829-833",
    "snippet": "ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t\tloff_t *ppos, size_t len, unsigned int flags)\n{\n\treturn splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_sendpage);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_from_pipe",
          "args": [
            "pipe",
            "out",
            "ppos",
            "len",
            "flags",
            "pipe_to_sendpage"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "649-666",
          "snippet": "ssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t generic_splice_sendpage(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t\tloff_t *ppos, size_t len, unsigned int flags)\n{\n\treturn splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_sendpage);\n}"
  },
  {
    "function_name": "default_file_splice_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "803-814",
    "snippet": "static ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_from_pipe",
          "args": [
            "pipe",
            "out",
            "ppos",
            "len",
            "flags",
            "write_pipe_buf"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "649-666",
          "snippet": "ssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "write_pipe_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "789-801",
    "snippet": "static int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\t  struct splice_desc *sd)\n{\n\tint ret;\n\tvoid *data;\n\tloff_t tmp = sd->pos;\n\n\tdata = kmap(buf->page);\n\tret = __kernel_write(sd->u.file, data + buf->offset, sd->len, &tmp);\n\tkunmap(buf->page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "buf->page"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_write",
          "args": [
            "sd->u.file",
            "data + buf->offset",
            "sd->len",
            "&tmp"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "492-514",
          "snippet": "ssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tret = __vfs_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tret = __vfs_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "buf->page"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\t  struct splice_desc *sd)\n{\n\tint ret;\n\tvoid *data;\n\tloff_t tmp = sd->pos;\n\n\tdata = kmap(buf->page);\n\tret = __kernel_write(sd->u.file, data + buf->offset, sd->len, &tmp);\n\tkunmap(buf->page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iter_file_splice_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "682-785",
    "snippet": "ssize_t\niter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\tint nbufs = pipe->buffers;\n\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\tssize_t ret;\n\n\tif (unlikely(!array))\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\n\tsplice_from_pipe_begin(&sd);\n\twhile (sd.total_len) {\n\t\tstruct iov_iter from;\n\t\tsize_t left;\n\t\tint n, idx;\n\n\t\tret = splice_from_pipe_next(pipe, &sd);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (unlikely(nbufs < pipe->buffers)) {\n\t\t\tkfree(array);\n\t\t\tnbufs = pipe->buffers;\n\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!array) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* build the vector */\n\t\tleft = sd.total_len;\n\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n\t\t\tsize_t this_len = buf->len;\n\n\t\t\tif (this_len > left)\n\t\t\t\tthis_len = left;\n\n\t\t\tif (idx == pipe->buffers - 1)\n\t\t\t\tidx = -1;\n\n\t\t\tret = pipe_buf_confirm(pipe, buf);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == -ENODATA)\n\t\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tarray[n].bv_page = buf->page;\n\t\t\tarray[n].bv_len = this_len;\n\t\t\tarray[n].bv_offset = buf->offset;\n\t\t\tleft -= this_len;\n\t\t}\n\n\t\tiov_iter_bvec(&from, WRITE, array, n, sd.total_len - left);\n\t\tret = vfs_iter_write(out, &from, &sd.pos, 0);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tsd.num_spliced += ret;\n\t\tsd.total_len -= ret;\n\t\t*ppos = sd.pos;\n\n\t\t/* dismiss the fully eaten buffers, adjust the partial one */\n\t\twhile (ret) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\t\tif (ret >= buf->len) {\n\t\t\t\tret -= buf->len;\n\t\t\t\tbuf->len = 0;\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->nrbufs--;\n\t\t\t\tif (pipe->files)\n\t\t\t\t\tsd.need_wakeup = true;\n\t\t\t} else {\n\t\t\t\tbuf->offset += ret;\n\t\t\t\tbuf->len -= ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tkfree(array);\n\tsplice_from_pipe_end(pipe, &sd);\n\n\tpipe_unlock(pipe);\n\n\tif (sd.num_spliced)\n\t\tret = sd.num_spliced;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_end",
          "args": [
            "pipe",
            "&sd"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "598-602",
          "snippet": "static void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_buf_release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_pipe_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "91-96",
          "snippet": "static void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_iter_write",
          "args": [
            "out",
            "&from",
            "&sd.pos",
            "0"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_iter_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "967-973",
          "snippet": "ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_write(file, iter, ppos, flags);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,\n\t\trwf_t flags)\n{\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\treturn do_iter_write(file, iter, ppos, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_bvec",
          "args": [
            "&from",
            "WRITE",
            "array",
            "n",
            "sd.total_len - left"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_buf_confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_pipe_buf_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "102-138",
          "snippet": "static int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nbufs",
            "sizeof(struct bio_vec)",
            "GFP_KERNEL"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nbufs < pipe->buffers"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_next",
          "args": [
            "pipe",
            "&sd"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "540-571",
          "snippet": "static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\t/*\n\t * Check for signal early to make process killable when there are\n\t * always buffers available\n\t */\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\t/*\n\t * Check for signal early to make process killable when there are\n\t * always buffers available\n\t */\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_begin",
          "args": [
            "&sd"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "582-586",
          "snippet": "static void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!array"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nbufs",
            "sizeof(struct bio_vec)",
            "GFP_KERNEL"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t\niter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\tint nbufs = pipe->buffers;\n\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\tssize_t ret;\n\n\tif (unlikely(!array))\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\n\tsplice_from_pipe_begin(&sd);\n\twhile (sd.total_len) {\n\t\tstruct iov_iter from;\n\t\tsize_t left;\n\t\tint n, idx;\n\n\t\tret = splice_from_pipe_next(pipe, &sd);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (unlikely(nbufs < pipe->buffers)) {\n\t\t\tkfree(array);\n\t\t\tnbufs = pipe->buffers;\n\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!array) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* build the vector */\n\t\tleft = sd.total_len;\n\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n\t\t\tsize_t this_len = buf->len;\n\n\t\t\tif (this_len > left)\n\t\t\t\tthis_len = left;\n\n\t\t\tif (idx == pipe->buffers - 1)\n\t\t\t\tidx = -1;\n\n\t\t\tret = pipe_buf_confirm(pipe, buf);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == -ENODATA)\n\t\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tarray[n].bv_page = buf->page;\n\t\t\tarray[n].bv_len = this_len;\n\t\t\tarray[n].bv_offset = buf->offset;\n\t\t\tleft -= this_len;\n\t\t}\n\n\t\tiov_iter_bvec(&from, WRITE, array, n, sd.total_len - left);\n\t\tret = vfs_iter_write(out, &from, &sd.pos, 0);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tsd.num_spliced += ret;\n\t\tsd.total_len -= ret;\n\t\t*ppos = sd.pos;\n\n\t\t/* dismiss the fully eaten buffers, adjust the partial one */\n\t\twhile (ret) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\t\tif (ret >= buf->len) {\n\t\t\t\tret -= buf->len;\n\t\t\t\tbuf->len = 0;\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->nrbufs--;\n\t\t\t\tif (pipe->files)\n\t\t\t\t\tsd.need_wakeup = true;\n\t\t\t} else {\n\t\t\t\tbuf->offset += ret;\n\t\t\t\tbuf->len -= ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tkfree(array);\n\tsplice_from_pipe_end(pipe, &sd);\n\n\tpipe_unlock(pipe);\n\n\tif (sd.num_spliced)\n\t\tret = sd.num_spliced;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "splice_from_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "649-666",
    "snippet": "ssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__splice_from_pipe",
          "args": [
            "pipe",
            "&sd",
            "actor"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "__splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "617-632",
          "snippet": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tcond_resched();\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tcond_resched();\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__splice_from_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "617-632",
    "snippet": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tcond_resched();\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_from_pipe_end",
          "args": [
            "pipe",
            "sd"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "598-602",
          "snippet": "static void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_feed",
          "args": [
            "pipe",
            "sd",
            "actor"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_feed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "484-528",
          "snippet": "static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = pipe_buf_confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tpipe_buf_release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = pipe_buf_confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tpipe_buf_release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_next",
          "args": [
            "pipe",
            "sd"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "540-571",
          "snippet": "static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\t/*\n\t * Check for signal early to make process killable when there are\n\t * always buffers available\n\t */\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\t/*\n\t * Check for signal early to make process killable when there are\n\t * always buffers available\n\t */\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_begin",
          "args": [
            "sd"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "582-586",
          "snippet": "static void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tcond_resched();\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}"
  },
  {
    "function_name": "splice_from_pipe_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "598-602",
    "snippet": "static void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_pipe_writers",
          "args": [
            "pipe"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "456-462",
          "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}"
  },
  {
    "function_name": "splice_from_pipe_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "582-586",
    "snippet": "static void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}"
  },
  {
    "function_name": "splice_from_pipe_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "540-571",
    "snippet": "static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\t/*\n\t * Check for signal early to make process killable when there are\n\t * always buffers available\n\t */\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "106-119",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_pipe_writers",
          "args": [
            "pipe"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "456-462",
          "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\t/*\n\t * Check for signal early to make process killable when there are\n\t * always buffers available\n\t */\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "splice_from_pipe_feed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "484-528",
    "snippet": "static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = pipe_buf_confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tpipe_buf_release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_buf_release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_pipe_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "91-96",
          "snippet": "static void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "actor",
          "args": [
            "pipe",
            "buf",
            "sd"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "splice_direct_to_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "896-1010",
          "snippet": "ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags, more;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\tmore = sd->flags & SPLICE_F_MORE;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * If more data is pending, set SPLICE_F_MORE\n\t\t * If this is the last data and SPLICE_F_MORE was not set\n\t\t * initially, clears it.\n\t\t */\n\t\tif (read_len < len)\n\t\t\tsd->flags |= SPLICE_F_MORE;\n\t\telse if (!more)\n\t\t\tsd->flags &= ~SPLICE_F_MORE;\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags, more;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\tmore = sd->flags & SPLICE_F_MORE;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * If more data is pending, set SPLICE_F_MORE\n\t\t * If this is the last data and SPLICE_F_MORE was not set\n\t\t * initially, clears it.\n\t\t */\n\t\tif (read_len < len)\n\t\t\tsd->flags |= SPLICE_F_MORE;\n\t\telse if (!more)\n\t\t\tsd->flags &= ~SPLICE_F_MORE;\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_buf_confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_pipe_buf_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "102-138",
          "snippet": "static int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = pipe_buf_confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tpipe_buf_release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "wakeup_pipe_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "456-462",
    "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_writers",
            "SIGIO",
            "POLL_OUT"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "1014-1024",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pipe->wait"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
  },
  {
    "function_name": "pipe_to_sendpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "437-454",
    "snippet": "static int pipe_to_sendpage(struct pipe_inode_info *pipe,\n\t\t\t    struct pipe_buffer *buf, struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tloff_t pos = sd->pos;\n\tint more;\n\n\tif (!likely(file->f_op->sendpage))\n\t\treturn -EINVAL;\n\n\tmore = (sd->flags & SPLICE_F_MORE) ? MSG_MORE : 0;\n\n\tif (sd->len < sd->total_len && pipe->nrbufs > 1)\n\t\tmore |= MSG_SENDPAGE_NOTLAST;\n\n\treturn file->f_op->sendpage(file, buf->page, buf->offset,\n\t\t\t\t    sd->len, &pos, more);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file->f_op->sendpage",
          "args": [
            "file",
            "buf->page",
            "buf->offset",
            "sd->len",
            "&pos",
            "more"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "file->f_op->sendpage"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int pipe_to_sendpage(struct pipe_inode_info *pipe,\n\t\t\t    struct pipe_buffer *buf, struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tloff_t pos = sd->pos;\n\tint more;\n\n\tif (!likely(file->f_op->sendpage))\n\t\treturn -EINVAL;\n\n\tmore = (sd->flags & SPLICE_F_MORE) ? MSG_MORE : 0;\n\n\tif (sd->len < sd->total_len && pipe->nrbufs > 1)\n\t\tmore |= MSG_SENDPAGE_NOTLAST;\n\n\treturn file->f_op->sendpage(file, buf->page, buf->offset,\n\t\t\t\t    sd->len, &pos, more);\n}"
  },
  {
    "function_name": "default_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "368-431",
    "snippet": "static ssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tstruct kvec *vec, __vec[PIPE_DEF_BUFFERS];\n\tstruct iov_iter to;\n\tstruct page **pages;\n\tunsigned int nr_pages;\n\tsize_t offset, base, copied = 0;\n\tssize_t res;\n\tint i;\n\n\tif (pipe->nrbufs == pipe->buffers)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Try to keep page boundaries matching to source pagecache ones -\n\t * it probably won't be much help, but...\n\t */\n\toffset = *ppos & ~PAGE_MASK;\n\n\tiov_iter_pipe(&to, READ, pipe, len + offset);\n\n\tres = iov_iter_get_pages_alloc(&to, &pages, len + offset, &base);\n\tif (res <= 0)\n\t\treturn -ENOMEM;\n\n\tnr_pages = DIV_ROUND_UP(res + base, PAGE_SIZE);\n\n\tvec = __vec;\n\tif (nr_pages > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc_array(nr_pages, sizeof(struct kvec), GFP_KERNEL);\n\t\tif (unlikely(!vec)) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpipe->bufs[to.idx].offset = offset;\n\tpipe->bufs[to.idx].len -= offset;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tsize_t this_len = min_t(size_t, len, PAGE_SIZE - offset);\n\t\tvec[i].iov_base = page_address(pages[i]) + offset;\n\t\tvec[i].iov_len = this_len;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, nr_pages, *ppos);\n\tif (res > 0) {\n\t\tcopied = res;\n\t\t*ppos += res;\n\t}\n\n\tif (vec != __vec)\n\t\tkfree(vec);\nout:\n\tfor (i = 0; i < nr_pages; i++)\n\t\tput_page(pages[i]);\n\tkvfree(pages);\n\tiov_iter_advance(&to, copied);\t/* truncates and discards */\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "&to",
            "copied"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "pages"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vec"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_readv",
          "args": [
            "in",
            "vec",
            "nr_pages",
            "*ppos"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages[i]"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "len",
            "PAGE_SIZE - offset"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vec"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_pages",
            "sizeof(struct kvec)",
            "GFP_KERNEL"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "res + base",
            "PAGE_SIZE"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_get_pages_alloc",
          "args": [
            "&to",
            "&pages",
            "len + offset",
            "&base"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_pipe",
          "args": [
            "&to",
            "READ",
            "pipe",
            "len + offset"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic ssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tstruct kvec *vec, __vec[PIPE_DEF_BUFFERS];\n\tstruct iov_iter to;\n\tstruct page **pages;\n\tunsigned int nr_pages;\n\tsize_t offset, base, copied = 0;\n\tssize_t res;\n\tint i;\n\n\tif (pipe->nrbufs == pipe->buffers)\n\t\treturn -EAGAIN;\n\n\t/*\n\t * Try to keep page boundaries matching to source pagecache ones -\n\t * it probably won't be much help, but...\n\t */\n\toffset = *ppos & ~PAGE_MASK;\n\n\tiov_iter_pipe(&to, READ, pipe, len + offset);\n\n\tres = iov_iter_get_pages_alloc(&to, &pages, len + offset, &base);\n\tif (res <= 0)\n\t\treturn -ENOMEM;\n\n\tnr_pages = DIV_ROUND_UP(res + base, PAGE_SIZE);\n\n\tvec = __vec;\n\tif (nr_pages > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc_array(nr_pages, sizeof(struct kvec), GFP_KERNEL);\n\t\tif (unlikely(!vec)) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpipe->bufs[to.idx].offset = offset;\n\tpipe->bufs[to.idx].len -= offset;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tsize_t this_len = min_t(size_t, len, PAGE_SIZE - offset);\n\t\tvec[i].iov_base = page_address(pages[i]) + offset;\n\t\tvec[i].iov_len = this_len;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, nr_pages, *ppos);\n\tif (res > 0) {\n\t\tcopied = res;\n\t\t*ppos += res;\n\t}\n\n\tif (vec != __vec)\n\t\tkfree(vec);\nout:\n\tfor (i = 0; i < nr_pages; i++)\n\t\tput_page(pages[i]);\n\tkvfree(pages);\n\tiov_iter_advance(&to, copied);\t/* truncates and discards */\n\treturn res;\n}"
  },
  {
    "function_name": "kernel_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "352-366",
    "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_readv",
          "args": [
            "file",
            "(const struct iovec __user *)vec",
            "vlen",
            "&pos",
            "0"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "976-991",
          "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos, rwf_t flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (ret >= 0) {\n\t\tret = do_iter_read(file, &iter, pos, flags);\n\t\tkfree(iov);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
  },
  {
    "function_name": "generic_pipe_buf_nosteal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "336-340",
    "snippet": "static int generic_pipe_buf_nosteal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int generic_pipe_buf_nosteal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "generic_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "296-325",
    "snippet": "ssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tstruct iov_iter to;\n\tstruct kiocb kiocb;\n\tint idx, ret;\n\n\tiov_iter_pipe(&to, READ, pipe, len);\n\tidx = to.idx;\n\tinit_sync_kiocb(&kiocb, in);\n\tkiocb.ki_pos = *ppos;\n\tret = call_read_iter(in, &kiocb, &to);\n\tif (ret > 0) {\n\t\t*ppos = kiocb.ki_pos;\n\t\tfile_accessed(in);\n\t} else if (ret < 0) {\n\t\tto.idx = idx;\n\t\tto.iov_offset = 0;\n\t\tiov_iter_advance(&to, 0); /* to free what was emitted */\n\t\t/*\n\t\t * callers of ->splice_read() expect -EAGAIN on\n\t\t * \"can't put anything in there\", rather than -EFAULT.\n\t\t */\n\t\tif (ret == -EFAULT)\n\t\t\tret = -EAGAIN;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "&to",
            "0"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "in"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_file_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/file.c",
          "lines": "155-175",
          "snippet": "static void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/uio.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/uio.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic void ovl_file_accessed(struct file *file)\n{\n\tstruct inode *inode, *upperinode;\n\n\tif (file->f_flags & O_NOATIME)\n\t\treturn;\n\n\tinode = file_inode(file);\n\tupperinode = ovl_inode_upper(inode);\n\n\tif (!upperinode)\n\t\treturn;\n\n\tif ((!timespec64_equal(&inode->i_mtime, &upperinode->i_mtime) ||\n\t     !timespec64_equal(&inode->i_ctime, &upperinode->i_ctime))) {\n\t\tinode->i_mtime = upperinode->i_mtime;\n\t\tinode->i_ctime = upperinode->i_ctime;\n\t}\n\n\ttouch_atime(&file->f_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_read_iter",
          "args": [
            "in",
            "&kiocb",
            "&to"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "in"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_pipe",
          "args": [
            "&to",
            "READ",
            "pipe",
            "len"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tstruct iov_iter to;\n\tstruct kiocb kiocb;\n\tint idx, ret;\n\n\tiov_iter_pipe(&to, READ, pipe, len);\n\tidx = to.idx;\n\tinit_sync_kiocb(&kiocb, in);\n\tkiocb.ki_pos = *ppos;\n\tret = call_read_iter(in, &kiocb, &to);\n\tif (ret > 0) {\n\t\t*ppos = kiocb.ki_pos;\n\t\tfile_accessed(in);\n\t} else if (ret < 0) {\n\t\tto.idx = idx;\n\t\tto.iov_offset = 0;\n\t\tiov_iter_advance(&to, 0); /* to free what was emitted */\n\t\t/*\n\t\t * callers of ->splice_read() expect -EAGAIN on\n\t\t * \"can't put anything in there\", rather than -EFAULT.\n\t\t */\n\t\tif (ret == -EFAULT)\n\t\t\tret = -EAGAIN;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "splice_shrink_spd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "274-281",
    "snippet": "void splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spd->partial"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nvoid splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}"
  },
  {
    "function_name": "splice_grow_spd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "254-272",
    "snippet": "int splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = READ_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc_array(buffers, sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc_array(buffers, sizeof(struct partial_page),\n\t\t\t\t     GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spd->partial"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "buffers",
            "sizeof(struct partial_page)",
            "GFP_KERNEL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "buffers",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pipe->buffers"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nint splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = READ_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc_array(buffers, sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc_array(buffers, sizeof(struct partial_page),\n\t\t\t\t     GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "add_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "230-247",
    "snippet": "ssize_t add_to_pipe(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tint ret;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t} else if (pipe->nrbufs == pipe->buffers) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tpipe->bufs[newbuf] = *buf;\n\t\tpipe->nrbufs++;\n\t\treturn buf->len;\n\t}\n\tpipe_buf_release(pipe, buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_buf_release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_pipe_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "91-96",
          "snippet": "static void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pipe->readers"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nssize_t add_to_pipe(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tint ret;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t} else if (pipe->nrbufs == pipe->buffers) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tpipe->bufs[newbuf] = *buf;\n\t\tpipe->nrbufs++;\n\t\treturn buf->len;\n\t}\n\tpipe_buf_release(pipe, buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "splice_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "185-227",
    "snippet": "ssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret = 0, page_nr = 0;\n\n\tif (!spd_pages)\n\t\treturn 0;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\twhile (pipe->nrbufs < pipe->buffers) {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\tbuf->page = spd->pages[page_nr];\n\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\tbuf->len = spd->partial[page_nr].len;\n\t\tbuf->private = spd->partial[page_nr].private;\n\t\tbuf->ops = spd->ops;\n\t\tbuf->flags = 0;\n\n\t\tpipe->nrbufs++;\n\t\tpage_nr++;\n\t\tret += buf->len;\n\n\t\tif (!--spd->nr_pages)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tret = -EAGAIN;\n\nout:\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spd->spd_release",
          "args": [
            "spd",
            "page_nr++"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pipe->readers"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret = 0, page_nr = 0;\n\n\tif (!spd_pages)\n\t\treturn 0;\n\n\tif (unlikely(!pipe->readers)) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\twhile (pipe->nrbufs < pipe->buffers) {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\tbuf->page = spd->pages[page_nr];\n\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\tbuf->len = spd->partial[page_nr].len;\n\t\tbuf->private = spd->partial[page_nr].private;\n\t\tbuf->ops = spd->ops;\n\t\tbuf->flags = 0;\n\n\t\tpipe->nrbufs++;\n\t\tpage_nr++;\n\t\tret += buf->len;\n\n\t\tif (!--spd->nr_pages)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tret = -EAGAIN;\n\nout:\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_pipe_readers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "166-172",
    "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "1014-1024",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pipe->wait"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
  },
  {
    "function_name": "user_page_pipe_buf_steal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "148-156",
    "snippet": "static int user_page_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tif (!(buf->flags & PIPE_BUF_FLAG_GIFT))\n\t\treturn 1;\n\n\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\treturn generic_pipe_buf_steal(pipe, buf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_pipe_buf_steal",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_steal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "163-179",
          "snippet": "int generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int user_page_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tif (!(buf->flags & PIPE_BUF_FLAG_GIFT))\n\t\treturn 1;\n\n\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\treturn generic_pipe_buf_steal(pipe, buf);\n}"
  },
  {
    "function_name": "page_cache_pipe_buf_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "102-138",
    "snippet": "static int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "page_cache_pipe_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "91-96",
    "snippet": "static void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "buf->page"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tput_page(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}"
  },
  {
    "function_name": "page_cache_pipe_buf_steal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "46-89",
    "snippet": "static int page_cache_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t     struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tstruct address_space *mapping;\n\n\tlock_page(page);\n\n\tmapping = page_mapping(page);\n\tif (mapping) {\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\t/*\n\t\t * At least for ext2 with nobh option, we need to wait on\n\t\t * writeback completing on this page, since we'll remove it\n\t\t * from the pagecache.  Otherwise truncate wont wait on the\n\t\t * page, allowing the disk blocks to be reused by someone else\n\t\t * before we actually wrote our data to them. fs corruption\n\t\t * ensues.\n\t\t */\n\t\twait_on_page_writeback(page);\n\n\t\tif (page_has_private(page) &&\n\t\t    !try_to_release_page(page, GFP_KERNEL))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If we succeeded in removing the mapping, set LRU flag\n\t\t * and return good.\n\t\t */\n\t\tif (remove_mapping(mapping, page)) {\n\t\t\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Raced with truncate or failed to remove page from current\n\t * address space, unlock and return failure.\n\t */\nout_unlock:\n\tunlock_page(page);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_mapping",
          "args": [
            "mapping",
            "page"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "GFP_KERNEL"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int page_cache_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t     struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tstruct address_space *mapping;\n\n\tlock_page(page);\n\n\tmapping = page_mapping(page);\n\tif (mapping) {\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\t/*\n\t\t * At least for ext2 with nobh option, we need to wait on\n\t\t * writeback completing on this page, since we'll remove it\n\t\t * from the pagecache.  Otherwise truncate wont wait on the\n\t\t * page, allowing the disk blocks to be reused by someone else\n\t\t * before we actually wrote our data to them. fs corruption\n\t\t * ensues.\n\t\t */\n\t\twait_on_page_writeback(page);\n\n\t\tif (page_has_private(page) &&\n\t\t    !try_to_release_page(page, GFP_KERNEL))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If we succeeded in removing the mapping, set LRU flag\n\t\t * and return good.\n\t\t */\n\t\tif (remove_mapping(mapping, page)) {\n\t\t\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Raced with truncate or failed to remove page from current\n\t * address space, unlock and return failure.\n\t */\nout_unlock:\n\tunlock_page(page);\n\treturn 1;\n}"
  },
  {
    "function_name": "vmsplice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1342-1365",
    "snippet": "SYSCALL_DEFINE4(vmsplice, int, fd, const struct iovec __user *, uiov,\n\t\tunsigned long, nr_segs, unsigned int, flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tlong error;\n\tstruct fd f;\n\tint type;\n\n\tf = fdget(fd);\n\terror = vmsplice_type(f, &type);\n\tif (error)\n\t\treturn error;\n\n\terror = import_iovec(type, uiov, nr_segs,\n\t\t\t     ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (!error) {\n\t\terror = do_vmsplice(f.file, &iter, flags);\n\t\tkfree(iov);\n\t}\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nSYSCALL_DEFINE4(vmsplice, int, fd, const struct iovec __user *, uiov,\n\t\tunsigned long, nr_segs, unsigned int, flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tlong error;\n\tstruct fd f;\n\tint type;\n\n\tf = fdget(fd);\n\terror = vmsplice_type(f, &type);\n\tif (error)\n\t\treturn error;\n\n\terror = import_iovec(type, uiov, nr_segs,\n\t\t\t     ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (!error) {\n\t\terror = do_vmsplice(f.file, &iter, flags);\n\t\tkfree(iov);\n\t}\n\tfdput(f);\n\treturn error;\n}"
  },
  {
    "function_name": "vmsplice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1368-1391",
    "snippet": "SYSCALL_DEFINE4(vmsplice, int, fd, const struct compat_iovec __user *, iov32,\n\t\t    unsigned int, nr_segs, unsigned int, flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tlong error;\n\tstruct fd f;\n\tint type;\n\n\tf = fdget(fd);\n\terror = vmsplice_type(f, &type);\n\tif (error)\n\t\treturn error;\n\n\terror = compat_import_iovec(type, iov32, nr_segs,\n\t\t\t     ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (!error) {\n\t\terror = do_vmsplice(f.file, &iter, flags);\n\t\tkfree(iov);\n\t}\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nSYSCALL_DEFINE4(vmsplice, int, fd, const struct compat_iovec __user *, iov32,\n\t\t    unsigned int, nr_segs, unsigned int, flags)\n{\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tlong error;\n\tstruct fd f;\n\tint type;\n\n\tf = fdget(fd);\n\terror = vmsplice_type(f, &type);\n\tif (error)\n\t\treturn error;\n\n\terror = compat_import_iovec(type, iov32, nr_segs,\n\t\t\t     ARRAY_SIZE(iovstack), &iov, &iter);\n\tif (!error) {\n\t\terror = do_vmsplice(f.file, &iter, flags);\n\t\tkfree(iov);\n\t}\n\tfdput(f);\n\treturn error;\n}"
  },
  {
    "function_name": "splice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1394-1423",
    "snippet": "SYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,\n\t\tint, fd_out, loff_t __user *, off_out,\n\t\tsize_t, len, unsigned int, flags)\n{\n\tstruct fd in, out;\n\tlong error;\n\n\tif (unlikely(!len))\n\t\treturn 0;\n\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\terror = -EBADF;\n\tin = fdget(fd_in);\n\tif (in.file) {\n\t\tif (in.file->f_mode & FMODE_READ) {\n\t\t\tout = fdget(fd_out);\n\t\t\tif (out.file) {\n\t\t\t\tif (out.file->f_mode & FMODE_WRITE)\n\t\t\t\t\terror = do_splice(in.file, off_in,\n\t\t\t\t\t\t\t  out.file, off_out,\n\t\t\t\t\t\t\t  len, flags);\n\t\t\t\tfdput(out);\n\t\t\t}\n\t\t}\n\t\tfdput(in);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nSYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,\n\t\tint, fd_out, loff_t __user *, off_out,\n\t\tsize_t, len, unsigned int, flags)\n{\n\tstruct fd in, out;\n\tlong error;\n\n\tif (unlikely(!len))\n\t\treturn 0;\n\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\terror = -EBADF;\n\tin = fdget(fd_in);\n\tif (in.file) {\n\t\tif (in.file->f_mode & FMODE_READ) {\n\t\t\tout = fdget(fd_out);\n\t\t\tif (out.file) {\n\t\t\t\tif (out.file->f_mode & FMODE_WRITE)\n\t\t\t\t\terror = do_splice(in.file, off_in,\n\t\t\t\t\t\t\t  out.file, off_out,\n\t\t\t\t\t\t\t  len, flags);\n\t\t\t\tfdput(out);\n\t\t\t}\n\t\t}\n\t\tfdput(in);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "tee",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
    "lines": "1730-1757",
    "snippet": "SYSCALL_DEFINE4(tee, int, fdin, int, fdout, size_t, len, unsigned int, flags)\n{\n\tstruct fd in;\n\tint error;\n\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!len))\n\t\treturn 0;\n\n\terror = -EBADF;\n\tin = fdget(fdin);\n\tif (in.file) {\n\t\tif (in.file->f_mode & FMODE_READ) {\n\t\t\tstruct fd out = fdget(fdout);\n\t\t\tif (out.file) {\n\t\t\t\tif (out.file->f_mode & FMODE_WRITE)\n\t\t\t\t\terror = do_tee(in.file, out.file,\n\t\t\t\t\t\t\tlen, flags);\n\t\t\t\tfdput(out);\n\t\t\t}\n\t\t}\n \t\tfdput(in);\n \t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/bvec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nSYSCALL_DEFINE4(tee, int, fdin, int, fdout, size_t, len, unsigned int, flags)\n{\n\tstruct fd in;\n\tint error;\n\n\tif (unlikely(flags & ~SPLICE_F_ALL))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!len))\n\t\treturn 0;\n\n\terror = -EBADF;\n\tin = fdget(fdin);\n\tif (in.file) {\n\t\tif (in.file->f_mode & FMODE_READ) {\n\t\t\tstruct fd out = fdget(fdout);\n\t\t\tif (out.file) {\n\t\t\t\tif (out.file->f_mode & FMODE_WRITE)\n\t\t\t\t\terror = do_tee(in.file, out.file,\n\t\t\t\t\t\t\tlen, flags);\n\t\t\t\tfdput(out);\n\t\t\t}\n\t\t}\n \t\tfdput(in);\n \t}\n\n\treturn error;\n}"
  }
]