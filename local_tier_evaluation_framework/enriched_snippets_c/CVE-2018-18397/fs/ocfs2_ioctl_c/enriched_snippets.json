[
  {
    "function_name": "ocfs2_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "960-1002",
    "snippet": "long ocfs2_compat_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tbool preserve;\n\tstruct reflink_arguments args;\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_info info;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC32_GETFLAGS:\n\t\tcmd = OCFS2_IOC_GETFLAGS;\n\t\tbreak;\n\tcase OCFS2_IOC32_SETFLAGS:\n\t\tcmd = OCFS2_IOC_SETFLAGS;\n\t\tbreak;\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t\tbreak;\n\tcase OCFS2_IOC_REFLINK:\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, compat_ptr(args.old_path),\n\t\t\t\t\t   compat_ptr(args.new_path), preserve);\n\tcase OCFS2_IOC_INFO:\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 1);\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn ocfs2_ioctl(file, cmd, arg);\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_ioctl",
          "args": [
            "file",
            "cmd",
            "arg"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "843-957",
          "snippet": "long ocfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint new_clusters;\n\tint status;\n\tstruct ocfs2_space_resv sr;\n\tstruct ocfs2_new_group_input input;\n\tstruct reflink_arguments args;\n\tconst char __user *old_path;\n\tconst char __user *new_path;\n\tbool preserve;\n\tstruct ocfs2_info info;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC_GETFLAGS:\n\t\tstatus = ocfs2_get_inode_attr(inode, &flags);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tflags &= OCFS2_FL_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase OCFS2_IOC_SETFLAGS:\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_set_inode_attr(inode, flags,\n\t\t\tOCFS2_FL_MODIFIABLE);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tif (copy_from_user(&sr, (int __user *) arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_change_file_space(filp, cmd, &sr);\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(new_clusters, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_extend(inode, new_clusters);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&input, (int __user *) arg, sizeof(input)))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_add(inode, &input);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_REFLINK:\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\told_path = (const char __user *)(unsigned long)args.old_path;\n\t\tnew_path = (const char __user *)(unsigned long)args.new_path;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, old_path, new_path, preserve);\n\tcase OCFS2_IOC_INFO:\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 0);\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(u64, q->limits.discard_granularity,\n\t\t\t\t     range.minlen);\n\t\tret = ocfs2_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\treturn ocfs2_ioctl_move_extents(filp, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nlong ocfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint new_clusters;\n\tint status;\n\tstruct ocfs2_space_resv sr;\n\tstruct ocfs2_new_group_input input;\n\tstruct reflink_arguments args;\n\tconst char __user *old_path;\n\tconst char __user *new_path;\n\tbool preserve;\n\tstruct ocfs2_info info;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC_GETFLAGS:\n\t\tstatus = ocfs2_get_inode_attr(inode, &flags);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tflags &= OCFS2_FL_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase OCFS2_IOC_SETFLAGS:\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_set_inode_attr(inode, flags,\n\t\t\tOCFS2_FL_MODIFIABLE);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tif (copy_from_user(&sr, (int __user *) arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_change_file_space(filp, cmd, &sr);\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(new_clusters, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_extend(inode, new_clusters);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&input, (int __user *) arg, sizeof(input)))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_add(inode, &input);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_REFLINK:\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\told_path = (const char __user *)(unsigned long)args.old_path;\n\t\tnew_path = (const char __user *)(unsigned long)args.new_path;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, old_path, new_path, preserve);\n\tcase OCFS2_IOC_INFO:\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 0);\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(u64, q->limits.discard_granularity,\n\t\t\t\t     range.minlen);\n\t\tret = ocfs2_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\treturn ocfs2_ioctl_move_extents(filp, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle",
          "args": [
            "inode",
            "&info",
            "1"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "809-841",
          "snippet": "static int ocfs2_info_handle(struct inode *inode, struct ocfs2_info *info,\n\t\t\t     int compat_flag)\n{\n\tint i, status = 0;\n\tu64 req_addr;\n\tstruct ocfs2_info_request __user *reqp;\n\n\tif ((info->oi_count > OCFS2_INFO_MAX_REQUEST) ||\n\t    (!info->oi_requests)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < info->oi_count; i++) {\n\n\t\tstatus = ocfs2_get_request_ptr(info, i, &req_addr, compat_flag);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\treqp = (struct ocfs2_info_request __user *)(unsigned long)req_addr;\n\t\tif (!reqp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_info_handle_request(inode, reqp);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle(struct inode *inode, struct ocfs2_info *info,\n\t\t\t     int compat_flag)\n{\n\tint i, status = 0;\n\tu64 req_addr;\n\tstruct ocfs2_info_request __user *reqp;\n\n\tif ((info->oi_count > OCFS2_INFO_MAX_REQUEST) ||\n\t    (!info->oi_requests)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < info->oi_count; i++) {\n\n\t\tstatus = ocfs2_get_request_ptr(info, i, &req_addr, compat_flag);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\treqp = (struct ocfs2_info_request __user *)(unsigned long)req_addr;\n\t\tif (!reqp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_info_handle_request(inode, reqp);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "argp",
            "sizeof(struct ocfs2_info)"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_ioctl",
          "args": [
            "inode",
            "compat_ptr(args.old_path)",
            "compat_ptr(args.new_path)",
            "preserve"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "4426-4466",
          "snippet": "int ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  d_inode(new_path.dentry),\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  d_inode(new_path.dentry),\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "args.new_path"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "args.old_path"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nlong ocfs2_compat_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tbool preserve;\n\tstruct reflink_arguments args;\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_info info;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC32_GETFLAGS:\n\t\tcmd = OCFS2_IOC_GETFLAGS;\n\t\tbreak;\n\tcase OCFS2_IOC32_SETFLAGS:\n\t\tcmd = OCFS2_IOC_SETFLAGS;\n\t\tbreak;\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t\tbreak;\n\tcase OCFS2_IOC_REFLINK:\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, compat_ptr(args.old_path),\n\t\t\t\t\t   compat_ptr(args.new_path), preserve);\n\tcase OCFS2_IOC_INFO:\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 1);\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn ocfs2_ioctl(file, cmd, arg);\n}"
  },
  {
    "function_name": "ocfs2_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "843-957",
    "snippet": "long ocfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint new_clusters;\n\tint status;\n\tstruct ocfs2_space_resv sr;\n\tstruct ocfs2_new_group_input input;\n\tstruct reflink_arguments args;\n\tconst char __user *old_path;\n\tconst char __user *new_path;\n\tbool preserve;\n\tstruct ocfs2_info info;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC_GETFLAGS:\n\t\tstatus = ocfs2_get_inode_attr(inode, &flags);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tflags &= OCFS2_FL_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase OCFS2_IOC_SETFLAGS:\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_set_inode_attr(inode, flags,\n\t\t\tOCFS2_FL_MODIFIABLE);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tif (copy_from_user(&sr, (int __user *) arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_change_file_space(filp, cmd, &sr);\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(new_clusters, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_extend(inode, new_clusters);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&input, (int __user *) arg, sizeof(input)))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_add(inode, &input);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_REFLINK:\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\told_path = (const char __user *)(unsigned long)args.old_path;\n\t\tnew_path = (const char __user *)(unsigned long)args.new_path;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, old_path, new_path, preserve);\n\tcase OCFS2_IOC_INFO:\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 0);\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(u64, q->limits.discard_granularity,\n\t\t\t\t     range.minlen);\n\t\tret = ocfs2_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\treturn ocfs2_ioctl_move_extents(filp, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_ioctl_move_extents",
          "args": [
            "filp",
            "argp"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_ioctl_move_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/move_extents.c",
          "lines": "993-1089",
          "snippet": "int ocfs2_ioctl_move_extents(struct file *filp, void __user *argp)\n{\n\tint status;\n\n\tstruct inode *inode = file_inode(filp);\n\tstruct ocfs2_move_extents range;\n\tstruct ocfs2_move_extents_context *context;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tstatus = mnt_want_write_file(filp);\n\tif (status)\n\t\treturn status;\n\n\tif ((!S_ISREG(inode->i_mode)) || !(filp->f_mode & FMODE_WRITE)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tcontext = kzalloc(sizeof(struct ocfs2_move_extents_context), GFP_NOFS);\n\tif (!context) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_drop;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->file = filp;\n\n\tif (copy_from_user(&range, argp, sizeof(range))) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start > i_size_read(inode)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start + range.me_len > i_size_read(inode))\n\t\t\trange.me_len = i_size_read(inode) - range.me_start;\n\n\tcontext->range = &range;\n\n\tif (range.me_flags & OCFS2_MOVE_EXT_FL_AUTO_DEFRAG) {\n\t\tcontext->auto_defrag = 1;\n\t\t/*\n\t\t * ok, the default theshold for the defragmentation\n\t\t * is 1M, since our maximum clustersize was 1M also.\n\t\t * any thought?\n\t\t */\n\t\tif (!range.me_threshold)\n\t\t\trange.me_threshold = 1024 * 1024;\n\n\t\tif (range.me_threshold > i_size_read(inode))\n\t\t\trange.me_threshold = i_size_read(inode);\n\n\t\tif (range.me_flags & OCFS2_MOVE_EXT_FL_PART_DEFRAG)\n\t\t\tcontext->partial = 1;\n\t} else {\n\t\t/*\n\t\t * first best-effort attempt to validate and adjust the goal\n\t\t * (physical address in block), while it can't guarantee later\n\t\t * operation can succeed all the time since global_bitmap may\n\t\t * change a bit over time.\n\t\t */\n\n\t\tstatus = ocfs2_validate_and_adjust_move_goal(inode, &range);\n\t\tif (status)\n\t\t\tgoto out_copy;\n\t}\n\n\tstatus = ocfs2_move_extents(context);\n\tif (status)\n\t\tmlog_errno(status);\nout_copy:\n\t/*\n\t * movement/defragmentation may end up being partially completed,\n\t * that's the reason why we need to return userspace the finished\n\t * length and new_offset even if failure happens somewhere.\n\t */\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\tstatus = -EFAULT;\n\nout_free:\n\tkfree(context);\nout_drop:\n\tmnt_drop_write_file(filp);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"localalloc.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"localalloc.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_ioctl_move_extents(struct file *filp, void __user *argp)\n{\n\tint status;\n\n\tstruct inode *inode = file_inode(filp);\n\tstruct ocfs2_move_extents range;\n\tstruct ocfs2_move_extents_context *context;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tstatus = mnt_want_write_file(filp);\n\tif (status)\n\t\treturn status;\n\n\tif ((!S_ISREG(inode->i_mode)) || !(filp->f_mode & FMODE_WRITE)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tcontext = kzalloc(sizeof(struct ocfs2_move_extents_context), GFP_NOFS);\n\tif (!context) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_drop;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->file = filp;\n\n\tif (copy_from_user(&range, argp, sizeof(range))) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start > i_size_read(inode)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start + range.me_len > i_size_read(inode))\n\t\t\trange.me_len = i_size_read(inode) - range.me_start;\n\n\tcontext->range = &range;\n\n\tif (range.me_flags & OCFS2_MOVE_EXT_FL_AUTO_DEFRAG) {\n\t\tcontext->auto_defrag = 1;\n\t\t/*\n\t\t * ok, the default theshold for the defragmentation\n\t\t * is 1M, since our maximum clustersize was 1M also.\n\t\t * any thought?\n\t\t */\n\t\tif (!range.me_threshold)\n\t\t\trange.me_threshold = 1024 * 1024;\n\n\t\tif (range.me_threshold > i_size_read(inode))\n\t\t\trange.me_threshold = i_size_read(inode);\n\n\t\tif (range.me_flags & OCFS2_MOVE_EXT_FL_PART_DEFRAG)\n\t\t\tcontext->partial = 1;\n\t} else {\n\t\t/*\n\t\t * first best-effort attempt to validate and adjust the goal\n\t\t * (physical address in block), while it can't guarantee later\n\t\t * operation can succeed all the time since global_bitmap may\n\t\t * change a bit over time.\n\t\t */\n\n\t\tstatus = ocfs2_validate_and_adjust_move_goal(inode, &range);\n\t\tif (status)\n\t\t\tgoto out_copy;\n\t}\n\n\tstatus = ocfs2_move_extents(context);\n\tif (status)\n\t\tmlog_errno(status);\nout_copy:\n\t/*\n\t * movement/defragmentation may end up being partially completed,\n\t * that's the reason why we need to return userspace the finished\n\t * length and new_offset even if failure happens somewhere.\n\t */\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\tstatus = -EFAULT;\n\nout_free:\n\tkfree(context);\nout_drop:\n\tmnt_drop_write_file(filp);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&range",
            "sizeof(range)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_trim_fs",
          "args": [
            "sb",
            "&range"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trim_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/alloc.c",
          "lines": "7535-7679",
          "snippet": "int ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 start, len, trimmed, first_group, last_group, group;\n\tint ret, cnt;\n\tu32 first_bit, last_bit, minlen;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_dinode *main_bm;\n\tstruct ocfs2_group_desc *gd = NULL;\n\tstruct ocfs2_trim_fs_info info, *pinfo = NULL;\n\n\tstart = range->start >> osb->s_clustersize_bits;\n\tlen = range->len >> osb->s_clustersize_bits;\n\tminlen = range->minlen >> osb->s_clustersize_bits;\n\n\tif (minlen >= osb->bitmap_cpg || range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\tmain_bm = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (start >= le32_to_cpu(main_bm->i_clusters)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = range->len >> osb->s_clustersize_bits;\n\tif (start + len > le32_to_cpu(main_bm->i_clusters))\n\t\tlen = le32_to_cpu(main_bm->i_clusters) - start;\n\n\ttrace_ocfs2_trim_fs(start, len, minlen);\n\n\tocfs2_trim_fs_lock_res_init(osb);\n\tret = ocfs2_trim_fs_lock(osb, NULL, 1);\n\tif (ret < 0) {\n\t\tif (ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmlog(ML_NOTICE, \"Wait for trim on device (%s) to \"\n\t\t     \"finish, which is running from another node.\\n\",\n\t\t     osb->dev_str);\n\t\tret = ocfs2_trim_fs_lock(osb, &info, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (info.tf_valid && info.tf_success &&\n\t\t    info.tf_start == start && info.tf_len == len &&\n\t\t    info.tf_minlen == minlen) {\n\t\t\t/* Avoid sending duplicated trim to a shared device */\n\t\t\tmlog(ML_NOTICE, \"The same trim on device (%s) was \"\n\t\t\t     \"just done from node (%u), return.\\n\",\n\t\t\t     osb->dev_str, info.tf_nodenum);\n\t\t\trange->len = info.tf_trimlen;\n\t\t\tgoto out_trimunlock;\n\t\t}\n\t}\n\n\tinfo.tf_nodenum = osb->node_num;\n\tinfo.tf_start = start;\n\tinfo.tf_len = len;\n\tinfo.tf_minlen = minlen;\n\n\t/* Determine first and last group to examine based on start and len */\n\tfirst_group = ocfs2_which_cluster_group(main_bm_inode, start);\n\tif (first_group == osb->first_cluster_group_blkno)\n\t\tfirst_bit = start;\n\telse\n\t\tfirst_bit = start - ocfs2_blocks_to_clusters(sb, first_group);\n\tlast_group = ocfs2_which_cluster_group(main_bm_inode, start + len - 1);\n\tlast_bit = osb->bitmap_cpg;\n\n\ttrimmed = 0;\n\tfor (group = first_group; group <= last_group;) {\n\t\tif (first_bit + len >= osb->bitmap_cpg)\n\t\t\tlast_bit = osb->bitmap_cpg;\n\t\telse\n\t\t\tlast_bit = first_bit + len;\n\n\t\tret = ocfs2_read_group_descriptor(main_bm_inode,\n\t\t\t\t\t\t  main_bm, group,\n\t\t\t\t\t\t  &gd_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\t\tcnt = ocfs2_trim_group(sb, gd, group,\n\t\t\t\t       first_bit, last_bit, minlen);\n\t\tbrelse(gd_bh);\n\t\tgd_bh = NULL;\n\t\tif (cnt < 0) {\n\t\t\tret = cnt;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrimmed += cnt;\n\t\tlen -= osb->bitmap_cpg - first_bit;\n\t\tfirst_bit = 0;\n\t\tif (group == osb->first_cluster_group_blkno)\n\t\t\tgroup = ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t\telse\n\t\t\tgroup += ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t}\n\trange->len = trimmed * sb->s_blocksize;\n\n\tinfo.tf_trimlen = range->len;\n\tinfo.tf_success = (ret ? 0 : 1);\n\tpinfo = &info;\nout_trimunlock:\n\tocfs2_trim_fs_unlock(osb, pinfo);\n\tocfs2_trim_fs_lock_res_uninit(osb);\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 0);\n\tbrelse(main_bm_bh);\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu64 start, len, trimmed, first_group, last_group, group;\n\tint ret, cnt;\n\tu32 first_bit, last_bit, minlen;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_dinode *main_bm;\n\tstruct ocfs2_group_desc *gd = NULL;\n\tstruct ocfs2_trim_fs_info info, *pinfo = NULL;\n\n\tstart = range->start >> osb->s_clustersize_bits;\n\tlen = range->len >> osb->s_clustersize_bits;\n\tminlen = range->minlen >> osb->s_clustersize_bits;\n\n\tif (minlen >= osb->bitmap_cpg || range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\tmain_bm = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (start >= le32_to_cpu(main_bm->i_clusters)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = range->len >> osb->s_clustersize_bits;\n\tif (start + len > le32_to_cpu(main_bm->i_clusters))\n\t\tlen = le32_to_cpu(main_bm->i_clusters) - start;\n\n\ttrace_ocfs2_trim_fs(start, len, minlen);\n\n\tocfs2_trim_fs_lock_res_init(osb);\n\tret = ocfs2_trim_fs_lock(osb, NULL, 1);\n\tif (ret < 0) {\n\t\tif (ret != -EAGAIN) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmlog(ML_NOTICE, \"Wait for trim on device (%s) to \"\n\t\t     \"finish, which is running from another node.\\n\",\n\t\t     osb->dev_str);\n\t\tret = ocfs2_trim_fs_lock(osb, &info, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tocfs2_trim_fs_lock_res_uninit(osb);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (info.tf_valid && info.tf_success &&\n\t\t    info.tf_start == start && info.tf_len == len &&\n\t\t    info.tf_minlen == minlen) {\n\t\t\t/* Avoid sending duplicated trim to a shared device */\n\t\t\tmlog(ML_NOTICE, \"The same trim on device (%s) was \"\n\t\t\t     \"just done from node (%u), return.\\n\",\n\t\t\t     osb->dev_str, info.tf_nodenum);\n\t\t\trange->len = info.tf_trimlen;\n\t\t\tgoto out_trimunlock;\n\t\t}\n\t}\n\n\tinfo.tf_nodenum = osb->node_num;\n\tinfo.tf_start = start;\n\tinfo.tf_len = len;\n\tinfo.tf_minlen = minlen;\n\n\t/* Determine first and last group to examine based on start and len */\n\tfirst_group = ocfs2_which_cluster_group(main_bm_inode, start);\n\tif (first_group == osb->first_cluster_group_blkno)\n\t\tfirst_bit = start;\n\telse\n\t\tfirst_bit = start - ocfs2_blocks_to_clusters(sb, first_group);\n\tlast_group = ocfs2_which_cluster_group(main_bm_inode, start + len - 1);\n\tlast_bit = osb->bitmap_cpg;\n\n\ttrimmed = 0;\n\tfor (group = first_group; group <= last_group;) {\n\t\tif (first_bit + len >= osb->bitmap_cpg)\n\t\t\tlast_bit = osb->bitmap_cpg;\n\t\telse\n\t\t\tlast_bit = first_bit + len;\n\n\t\tret = ocfs2_read_group_descriptor(main_bm_inode,\n\t\t\t\t\t\t  main_bm, group,\n\t\t\t\t\t\t  &gd_bh);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\t\tcnt = ocfs2_trim_group(sb, gd, group,\n\t\t\t\t       first_bit, last_bit, minlen);\n\t\tbrelse(gd_bh);\n\t\tgd_bh = NULL;\n\t\tif (cnt < 0) {\n\t\t\tret = cnt;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrimmed += cnt;\n\t\tlen -= osb->bitmap_cpg - first_bit;\n\t\tfirst_bit = 0;\n\t\tif (group == osb->first_cluster_group_blkno)\n\t\t\tgroup = ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t\telse\n\t\t\tgroup += ocfs2_clusters_to_blocks(sb, osb->bitmap_cpg);\n\t}\n\trange->len = trimmed * sb->s_blocksize;\n\n\tinfo.tf_trimlen = range->len;\n\tinfo.tf_success = (ret ? 0 : 1);\n\tpinfo = &info;\nout_trimunlock:\n\tocfs2_trim_fs_unlock(osb, pinfo);\n\tocfs2_trim_fs_lock_res_uninit(osb);\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 0);\n\tbrelse(main_bm_bh);\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "q->limits.discard_granularity",
            "range.minlen"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "argp",
            "sizeof(range)"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle",
          "args": [
            "inode",
            "&info",
            "0"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "809-841",
          "snippet": "static int ocfs2_info_handle(struct inode *inode, struct ocfs2_info *info,\n\t\t\t     int compat_flag)\n{\n\tint i, status = 0;\n\tu64 req_addr;\n\tstruct ocfs2_info_request __user *reqp;\n\n\tif ((info->oi_count > OCFS2_INFO_MAX_REQUEST) ||\n\t    (!info->oi_requests)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < info->oi_count; i++) {\n\n\t\tstatus = ocfs2_get_request_ptr(info, i, &req_addr, compat_flag);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\treqp = (struct ocfs2_info_request __user *)(unsigned long)req_addr;\n\t\tif (!reqp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_info_handle_request(inode, reqp);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle(struct inode *inode, struct ocfs2_info *info,\n\t\t\t     int compat_flag)\n{\n\tint i, status = 0;\n\tu64 req_addr;\n\tstruct ocfs2_info_request __user *reqp;\n\n\tif ((info->oi_count > OCFS2_INFO_MAX_REQUEST) ||\n\t    (!info->oi_requests)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < info->oi_count; i++) {\n\n\t\tstatus = ocfs2_get_request_ptr(info, i, &req_addr, compat_flag);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\treqp = (struct ocfs2_info_request __user *)(unsigned long)req_addr;\n\t\tif (!reqp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_info_handle_request(inode, reqp);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_ioctl",
          "args": [
            "inode",
            "old_path",
            "new_path",
            "preserve"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/refcounttree.c",
          "lines": "4426-4466",
          "snippet": "int ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  d_inode(new_path.dentry),\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"file.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"file.h\"\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  d_inode(new_path.dentry),\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_group_add",
          "args": [
            "inode",
            "&input"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/resize.c",
          "lines": "462-598",
          "snippet": "int ocfs2_group_add(struct inode *inode, struct ocfs2_new_group_input *input)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *cr;\n\tu16 cl_bpc;\n\tu64 bg_ptr;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small.\"\n\t\t     \" Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, input->group, 1, &group_bh);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Can't read the group descriptor # %llu \"\n\t\t     \"from the device.\", (unsigned long long)input->group);\n\t\tgoto out_unlock;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), group_bh);\n\n\tret = ocfs2_verify_group_and_input(main_bm_inode, fe, input, group_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_free_group_bh;\n\t}\n\n\ttrace_ocfs2_group_add((unsigned long long)input->group,\n\t\t\t       input->chain, input->clusters, input->frees);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_ADD_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_free_group_bh;\n\t}\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tcl = &fe->id2.i_chain;\n\tcr = &cl->cl_recs[input->chain];\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\tbg_ptr = le64_to_cpu(group->bg_next_group);\n\tgroup->bg_next_group = cr->c_blkno;\n\tocfs2_journal_dirty(handle, group_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      main_bm_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tgroup->bg_next_group = cpu_to_le64(bg_ptr);\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (input->chain == le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\t\tmemset(cr, 0, sizeof(struct ocfs2_chain_rec));\n\t}\n\n\tcr->c_blkno = cpu_to_le64(input->group);\n\tle32_add_cpu(&cr->c_total, input->clusters * cl_bpc);\n\tle32_add_cpu(&cr->c_free, input->frees * cl_bpc);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, input->clusters *cl_bpc);\n\tle32_add_cpu(&fe->id1.bitmap1.i_used,\n\t\t     (input->clusters - input->frees) * cl_bpc);\n\tle32_add_cpu(&fe->i_clusters, input->clusters);\n\n\tocfs2_journal_dirty(handle, main_bm_bh);\n\n\tspin_lock(&OCFS2_I(main_bm_inode)->ip_lock);\n\tOCFS2_I(main_bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)input->clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(main_bm_inode)->ip_lock);\n\ti_size_write(main_bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_update_super_and_backups(main_bm_inode, input->clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_free_group_bh:\n\tbrelse(group_bh);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_group_add(struct inode *inode, struct ocfs2_new_group_input *input)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *cr;\n\tu16 cl_bpc;\n\tu64 bg_ptr;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small.\"\n\t\t     \" Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, input->group, 1, &group_bh);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Can't read the group descriptor # %llu \"\n\t\t     \"from the device.\", (unsigned long long)input->group);\n\t\tgoto out_unlock;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), group_bh);\n\n\tret = ocfs2_verify_group_and_input(main_bm_inode, fe, input, group_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_free_group_bh;\n\t}\n\n\ttrace_ocfs2_group_add((unsigned long long)input->group,\n\t\t\t       input->chain, input->clusters, input->frees);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_ADD_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_free_group_bh;\n\t}\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tcl = &fe->id2.i_chain;\n\tcr = &cl->cl_recs[input->chain];\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\tbg_ptr = le64_to_cpu(group->bg_next_group);\n\tgroup->bg_next_group = cr->c_blkno;\n\tocfs2_journal_dirty(handle, group_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      main_bm_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tgroup->bg_next_group = cpu_to_le64(bg_ptr);\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (input->chain == le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\t\tmemset(cr, 0, sizeof(struct ocfs2_chain_rec));\n\t}\n\n\tcr->c_blkno = cpu_to_le64(input->group);\n\tle32_add_cpu(&cr->c_total, input->clusters * cl_bpc);\n\tle32_add_cpu(&cr->c_free, input->frees * cl_bpc);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, input->clusters *cl_bpc);\n\tle32_add_cpu(&fe->id1.bitmap1.i_used,\n\t\t     (input->clusters - input->frees) * cl_bpc);\n\tle32_add_cpu(&fe->i_clusters, input->clusters);\n\n\tocfs2_journal_dirty(handle, main_bm_bh);\n\n\tspin_lock(&OCFS2_I(main_bm_inode)->ip_lock);\n\tOCFS2_I(main_bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)input->clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(main_bm_inode)->ip_lock);\n\ti_size_write(main_bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_update_super_and_backups(main_bm_inode, input->clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_free_group_bh:\n\tbrelse(group_bh);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_group_extend",
          "args": [
            "inode",
            "new_clusters"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/resize.c",
          "lines": "273-383",
          "snippet": "int ocfs2_group_extend(struct inode * inode, int new_clusters)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 cl_bpc;\n\tu32 first_new_cluster;\n\tu64 lgd_blkno;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (new_clusters < 0)\n\t\treturn -EINVAL;\n\telse if (new_clusters == 0)\n\t\treturn 0;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\t/* main_bm_bh is validated by inode read inside ocfs2_inode_lock(),\n\t * so any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small. \"\n\t\t     \"Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tfirst_new_cluster = le32_to_cpu(fe->i_clusters);\n\tlgd_blkno = ocfs2_which_cluster_group(main_bm_inode,\n\t\t\t\t\t      first_new_cluster - 1);\n\n\tret = ocfs2_read_group_descriptor(main_bm_inode, fe, lgd_blkno,\n\t\t\t\t\t  &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(group->bg_bits) / cl_bpc + new_clusters >\n\t\tle16_to_cpu(fe->id2.i_chain.cl_cpg)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\n\ttrace_ocfs2_group_extend(\n\t     (unsigned long long)le64_to_cpu(group->bg_blkno), new_clusters);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_EXTEND_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* update the last group descriptor and inode. */\n\tret = ocfs2_update_last_group_and_inode(handle, main_bm_inode,\n\t\t\t\t\t\tmain_bm_bh, group_bh,\n\t\t\t\t\t\tfirst_new_cluster,\n\t\t\t\t\t\tnew_clusters);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_update_super_and_backups(main_bm_inode, new_clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tbrelse(group_bh);\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_group_extend(struct inode * inode, int new_clusters)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 cl_bpc;\n\tu32 first_new_cluster;\n\tu64 lgd_blkno;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (new_clusters < 0)\n\t\treturn -EINVAL;\n\telse if (new_clusters == 0)\n\t\treturn 0;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tinode_lock(main_bm_inode);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\t/* main_bm_bh is validated by inode read inside ocfs2_inode_lock(),\n\t * so any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small. \"\n\t\t     \"Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tfirst_new_cluster = le32_to_cpu(fe->i_clusters);\n\tlgd_blkno = ocfs2_which_cluster_group(main_bm_inode,\n\t\t\t\t\t      first_new_cluster - 1);\n\n\tret = ocfs2_read_group_descriptor(main_bm_inode, fe, lgd_blkno,\n\t\t\t\t\t  &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(group->bg_bits) / cl_bpc + new_clusters >\n\t\tle16_to_cpu(fe->id2.i_chain.cl_cpg)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\n\ttrace_ocfs2_group_extend(\n\t     (unsigned long long)le64_to_cpu(group->bg_blkno), new_clusters);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_EXTEND_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* update the last group descriptor and inode. */\n\tret = ocfs2_update_last_group_and_inode(handle, main_bm_inode,\n\t\t\t\t\t\tmain_bm_bh, group_bh,\n\t\t\t\t\t\tfirst_new_cluster,\n\t\t\t\t\t\tnew_clusters);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_update_super_and_backups(main_bm_inode, new_clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tbrelse(group_bh);\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tinode_unlock(main_bm_inode);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "new_clusters",
            "(int __user *)arg"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_change_file_space",
          "args": [
            "filp",
            "cmd",
            "&sr"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/file.c",
          "lines": "2004-2030",
          "snippet": "int ocfs2_change_file_space(struct file *file, unsigned int cmd,\n\t\t\t    struct ocfs2_space_resv *sr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret;\n\n\tif ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&\n\t    !ocfs2_writes_unwritten_extents(osb))\n\t\treturn -ENOTTY;\n\telse if ((cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) &&\n\t\t !ocfs2_sparse_alloc(osb))\n\t\treturn -ENOTTY;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tret = __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_change_file_space(struct file *file, unsigned int cmd,\n\t\t\t    struct ocfs2_space_resv *sr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret;\n\n\tif ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&\n\t    !ocfs2_writes_unwritten_extents(osb))\n\t\treturn -ENOTTY;\n\telse if ((cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) &&\n\t\t !ocfs2_sparse_alloc(osb))\n\t\treturn -ENOTTY;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tret = __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_inode_attr",
          "args": [
            "inode",
            "flags",
            "OCFS2_FL_MODIFIABLE"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "80-144",
          "snippet": "static int ocfs2_set_inode_attr(struct inode *inode, unsigned flags,\n\t\t\t\tunsigned mask)\n{\n\tstruct ocfs2_inode_info *ocfs2_inode = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh = NULL;\n\tunsigned oldflags;\n\tint status;\n\n\tinode_lock(inode);\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto bail_unlock;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\tflags &= ~OCFS2_DIRSYNC_FL;\n\n\toldflags = ocfs2_inode->ip_attr;\n\tflags = flags & mask;\n\tflags |= oldflags & ~mask;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tstatus = -EPERM;\n\tif ((oldflags & OCFS2_IMMUTABLE_FL) || ((flags ^ oldflags) &\n\t\t(OCFS2_APPEND_FL | OCFS2_IMMUTABLE_FL))) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\tgoto bail_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tocfs2_inode->ip_attr = flags;\n\tocfs2_set_inode_flags(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock:\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tinode_unlock(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_set_inode_attr(struct inode *inode, unsigned flags,\n\t\t\t\tunsigned mask)\n{\n\tstruct ocfs2_inode_info *ocfs2_inode = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh = NULL;\n\tunsigned oldflags;\n\tint status;\n\n\tinode_lock(inode);\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto bail_unlock;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\tflags &= ~OCFS2_DIRSYNC_FL;\n\n\toldflags = ocfs2_inode->ip_attr;\n\tflags = flags & mask;\n\tflags |= oldflags & ~mask;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tstatus = -EPERM;\n\tif ((oldflags & OCFS2_IMMUTABLE_FL) || ((flags ^ oldflags) &\n\t\t(OCFS2_APPEND_FL | OCFS2_IMMUTABLE_FL))) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\tgoto bail_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tocfs2_inode->ip_attr = flags;\n\tocfs2_set_inode_flags(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock:\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tinode_unlock(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *) arg"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_inode_attr",
          "args": [
            "inode",
            "&flags"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "64-78",
          "snippet": "static int ocfs2_get_inode_attr(struct inode *inode, unsigned *flags)\n{\n\tint status;\n\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\t*flags = OCFS2_I(inode)->ip_attr;\n\tocfs2_inode_unlock(inode, 0);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_inode_attr(struct inode *inode, unsigned *flags)\n{\n\tint status;\n\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\t*flags = OCFS2_I(inode)->ip_attr;\n\tocfs2_inode_unlock(inode, 0);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nlong ocfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tunsigned int flags;\n\tint new_clusters;\n\tint status;\n\tstruct ocfs2_space_resv sr;\n\tstruct ocfs2_new_group_input input;\n\tstruct reflink_arguments args;\n\tconst char __user *old_path;\n\tconst char __user *new_path;\n\tbool preserve;\n\tstruct ocfs2_info info;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase OCFS2_IOC_GETFLAGS:\n\t\tstatus = ocfs2_get_inode_attr(inode, &flags);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tflags &= OCFS2_FL_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase OCFS2_IOC_SETFLAGS:\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_set_inode_attr(inode, flags,\n\t\t\tOCFS2_FL_MODIFIABLE);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tif (copy_from_user(&sr, (int __user *) arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_change_file_space(filp, cmd, &sr);\n\tcase OCFS2_IOC_GROUP_EXTEND:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(new_clusters, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_extend(inode, new_clusters);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_GROUP_ADD:\n\tcase OCFS2_IOC_GROUP_ADD64:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&input, (int __user *) arg, sizeof(input)))\n\t\t\treturn -EFAULT;\n\n\t\tstatus = mnt_want_write_file(filp);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = ocfs2_group_add(inode, &input);\n\t\tmnt_drop_write_file(filp);\n\t\treturn status;\n\tcase OCFS2_IOC_REFLINK:\n\t\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\t\treturn -EFAULT;\n\t\told_path = (const char __user *)(unsigned long)args.old_path;\n\t\tnew_path = (const char __user *)(unsigned long)args.new_path;\n\t\tpreserve = (args.preserve != 0);\n\n\t\treturn ocfs2_reflink_ioctl(inode, old_path, new_path, preserve);\n\tcase OCFS2_IOC_INFO:\n\t\tif (copy_from_user(&info, argp, sizeof(struct ocfs2_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ocfs2_info_handle(inode, &info, 0);\n\tcase FITRIM:\n\t{\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!blk_queue_discard(q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (copy_from_user(&range, argp, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\trange.minlen = max_t(u64, q->limits.discard_granularity,\n\t\t\t\t     range.minlen);\n\t\tret = ocfs2_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase OCFS2_IOC_MOVE_EXT:\n\t\treturn ocfs2_ioctl_move_extents(filp, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_info_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "809-841",
    "snippet": "static int ocfs2_info_handle(struct inode *inode, struct ocfs2_info *info,\n\t\t\t     int compat_flag)\n{\n\tint i, status = 0;\n\tu64 req_addr;\n\tstruct ocfs2_info_request __user *reqp;\n\n\tif ((info->oi_count > OCFS2_INFO_MAX_REQUEST) ||\n\t    (!info->oi_requests)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < info->oi_count; i++) {\n\n\t\tstatus = ocfs2_get_request_ptr(info, i, &req_addr, compat_flag);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\treqp = (struct ocfs2_info_request __user *)(unsigned long)req_addr;\n\t\tif (!reqp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_info_handle_request(inode, reqp);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_info_handle_request",
          "args": [
            "inode",
            "reqp"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "712-769",
          "snippet": "static int ocfs2_info_handle_request(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tint status = -EFAULT;\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\tgoto bail;\n\n\tstatus = -EINVAL;\n\tif (oir.ir_magic != OCFS2_INFO_MAGIC)\n\t\tgoto bail;\n\n\tswitch (oir.ir_code) {\n\tcase OCFS2_INFO_BLOCKSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_blocksize))\n\t\t\tstatus = ocfs2_info_handle_blocksize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_CLUSTERSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_clustersize))\n\t\t\tstatus = ocfs2_info_handle_clustersize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_MAXSLOTS:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_maxslots))\n\t\t\tstatus = ocfs2_info_handle_maxslots(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_LABEL:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_label))\n\t\t\tstatus = ocfs2_info_handle_label(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_UUID:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_uuid))\n\t\t\tstatus = ocfs2_info_handle_uuid(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FS_FEATURES:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_fs_features))\n\t\t\tstatus = ocfs2_info_handle_fs_features(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_JOURNAL_SIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_journal_size))\n\t\t\tstatus = ocfs2_info_handle_journal_size(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEINODE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freeinode))\n\t\t\tstatus = ocfs2_info_handle_freeinode(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEFRAG:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freefrag))\n\t\t\tstatus = ocfs2_info_handle_freefrag(inode, req);\n\t\tbreak;\n\tdefault:\n\t\tstatus = ocfs2_info_handle_unknown(inode, req);\n\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_request(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tint status = -EFAULT;\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\tgoto bail;\n\n\tstatus = -EINVAL;\n\tif (oir.ir_magic != OCFS2_INFO_MAGIC)\n\t\tgoto bail;\n\n\tswitch (oir.ir_code) {\n\tcase OCFS2_INFO_BLOCKSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_blocksize))\n\t\t\tstatus = ocfs2_info_handle_blocksize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_CLUSTERSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_clustersize))\n\t\t\tstatus = ocfs2_info_handle_clustersize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_MAXSLOTS:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_maxslots))\n\t\t\tstatus = ocfs2_info_handle_maxslots(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_LABEL:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_label))\n\t\t\tstatus = ocfs2_info_handle_label(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_UUID:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_uuid))\n\t\t\tstatus = ocfs2_info_handle_uuid(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FS_FEATURES:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_fs_features))\n\t\t\tstatus = ocfs2_info_handle_fs_features(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_JOURNAL_SIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_journal_size))\n\t\t\tstatus = ocfs2_info_handle_journal_size(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEINODE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freeinode))\n\t\t\tstatus = ocfs2_info_handle_freeinode(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEFRAG:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freefrag))\n\t\t\tstatus = ocfs2_info_handle_freefrag(inode, req);\n\t\tbreak;\n\tdefault:\n\t\tstatus = ocfs2_info_handle_unknown(inode, req);\n\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_request_ptr",
          "args": [
            "info",
            "i",
            "&req_addr",
            "compat_flag"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_request_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "771-796",
          "snippet": "static int ocfs2_get_request_ptr(struct ocfs2_info *info, int idx,\n\t\t\t\t u64 *req_addr, int compat_flag)\n{\n\tint status = -EFAULT;\n\tu64 __user *bp = NULL;\n\n\tif (compat_flag) {\n#ifdef CONFIG_COMPAT\n\t\t/*\n\t\t * pointer bp stores the base address of a pointers array,\n\t\t * which collects all addresses of separate request.\n\t\t */\n\t\tbp = (u64 __user *)(unsigned long)compat_ptr(info->oi_requests);\n#else\n\t\tBUG();\n#endif\n\t} else\n\t\tbp = (u64 __user *)(unsigned long)(info->oi_requests);\n\n\tif (o2info_from_user(*req_addr, bp + idx))\n\t\tgoto bail;\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_request_ptr(struct ocfs2_info *info, int idx,\n\t\t\t\t u64 *req_addr, int compat_flag)\n{\n\tint status = -EFAULT;\n\tu64 __user *bp = NULL;\n\n\tif (compat_flag) {\n#ifdef CONFIG_COMPAT\n\t\t/*\n\t\t * pointer bp stores the base address of a pointers array,\n\t\t * which collects all addresses of separate request.\n\t\t */\n\t\tbp = (u64 __user *)(unsigned long)compat_ptr(info->oi_requests);\n#else\n\t\tBUG();\n#endif\n\t} else\n\t\tbp = (u64 __user *)(unsigned long)(info->oi_requests);\n\n\tif (o2info_from_user(*req_addr, bp + idx))\n\t\tgoto bail;\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle(struct inode *inode, struct ocfs2_info *info,\n\t\t\t     int compat_flag)\n{\n\tint i, status = 0;\n\tu64 req_addr;\n\tstruct ocfs2_info_request __user *reqp;\n\n\tif ((info->oi_count > OCFS2_INFO_MAX_REQUEST) ||\n\t    (!info->oi_requests)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < info->oi_count; i++) {\n\n\t\tstatus = ocfs2_get_request_ptr(info, i, &req_addr, compat_flag);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\treqp = (struct ocfs2_info_request __user *)(unsigned long)req_addr;\n\t\tif (!reqp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tstatus = ocfs2_info_handle_request(inode, reqp);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_request_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "771-796",
    "snippet": "static int ocfs2_get_request_ptr(struct ocfs2_info *info, int idx,\n\t\t\t\t u64 *req_addr, int compat_flag)\n{\n\tint status = -EFAULT;\n\tu64 __user *bp = NULL;\n\n\tif (compat_flag) {\n#ifdef CONFIG_COMPAT\n\t\t/*\n\t\t * pointer bp stores the base address of a pointers array,\n\t\t * which collects all addresses of separate request.\n\t\t */\n\t\tbp = (u64 __user *)(unsigned long)compat_ptr(info->oi_requests);\n#else\n\t\tBUG();\n#endif\n\t} else\n\t\tbp = (u64 __user *)(unsigned long)(info->oi_requests);\n\n\tif (o2info_from_user(*req_addr, bp + idx))\n\t\tgoto bail;\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "*req_addr",
            "bp + idx"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "info->oi_requests"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_request_ptr(struct ocfs2_info *info, int idx,\n\t\t\t\t u64 *req_addr, int compat_flag)\n{\n\tint status = -EFAULT;\n\tu64 __user *bp = NULL;\n\n\tif (compat_flag) {\n#ifdef CONFIG_COMPAT\n\t\t/*\n\t\t * pointer bp stores the base address of a pointers array,\n\t\t * which collects all addresses of separate request.\n\t\t */\n\t\tbp = (u64 __user *)(unsigned long)compat_ptr(info->oi_requests);\n#else\n\t\tBUG();\n#endif\n\t} else\n\t\tbp = (u64 __user *)(unsigned long)(info->oi_requests);\n\n\tif (o2info_from_user(*req_addr, bp + idx))\n\t\tgoto bail;\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "712-769",
    "snippet": "static int ocfs2_info_handle_request(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tint status = -EFAULT;\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\tgoto bail;\n\n\tstatus = -EINVAL;\n\tif (oir.ir_magic != OCFS2_INFO_MAGIC)\n\t\tgoto bail;\n\n\tswitch (oir.ir_code) {\n\tcase OCFS2_INFO_BLOCKSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_blocksize))\n\t\t\tstatus = ocfs2_info_handle_blocksize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_CLUSTERSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_clustersize))\n\t\t\tstatus = ocfs2_info_handle_clustersize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_MAXSLOTS:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_maxslots))\n\t\t\tstatus = ocfs2_info_handle_maxslots(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_LABEL:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_label))\n\t\t\tstatus = ocfs2_info_handle_label(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_UUID:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_uuid))\n\t\t\tstatus = ocfs2_info_handle_uuid(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FS_FEATURES:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_fs_features))\n\t\t\tstatus = ocfs2_info_handle_fs_features(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_JOURNAL_SIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_journal_size))\n\t\t\tstatus = ocfs2_info_handle_journal_size(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEINODE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freeinode))\n\t\t\tstatus = ocfs2_info_handle_freeinode(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEFRAG:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freefrag))\n\t\t\tstatus = ocfs2_info_handle_freefrag(inode, req);\n\t\tbreak;\n\tdefault:\n\t\tstatus = ocfs2_info_handle_unknown(inode, req);\n\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_info_handle_unknown",
          "args": [
            "inode",
            "req"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_unknown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "689-703",
          "snippet": "static int ocfs2_info_handle_unknown(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\treturn -EFAULT;\n\n\to2info_clear_request_filled(&oir);\n\n\tif (o2info_to_user(oir, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_unknown(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\treturn -EFAULT;\n\n\to2info_clear_request_filled(&oir);\n\n\tif (o2info_to_user(oir, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_freefrag",
          "args": [
            "inode",
            "req"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_freefrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "616-687",
          "snippet": "static int ocfs2_info_handle_freefrag(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = GLOBAL_BITMAP_SYSTEM_INODE;\n\n\tstruct ocfs2_info_freefrag *oiff;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *gb_inode = NULL;\n\n\toiff = kzalloc(sizeof(struct ocfs2_info_freefrag), GFP_KERNEL);\n\tif (!oiff) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\t/*\n\t * chunksize from userspace should be power of 2.\n\t */\n\tif ((oiff->iff_chunksize & (oiff->iff_chunksize - 1)) ||\n\t    (!oiff->iff_chunksize)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (o2info_coherent(&oiff->iff_req)) {\n\t\tgb_inode = ocfs2_get_system_file_inode(osb, type,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\t\tif (!gb_inode) {\n\t\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type,\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t    &blkno);\n\t\tif (status < 0) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_info_freefrag_scan_bitmap(osb, gb_inode, blkno, oiff);\n\tif (status < 0)\n\t\tgoto bail;\n\n\to2info_set_request_filled(&oiff->iff_req);\n\n\tif (o2info_to_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oiff->iff_req, req);\nout_free:\n\tkfree(oiff);\nout_err:\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_freefrag(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = GLOBAL_BITMAP_SYSTEM_INODE;\n\n\tstruct ocfs2_info_freefrag *oiff;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *gb_inode = NULL;\n\n\toiff = kzalloc(sizeof(struct ocfs2_info_freefrag), GFP_KERNEL);\n\tif (!oiff) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\t/*\n\t * chunksize from userspace should be power of 2.\n\t */\n\tif ((oiff->iff_chunksize & (oiff->iff_chunksize - 1)) ||\n\t    (!oiff->iff_chunksize)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (o2info_coherent(&oiff->iff_req)) {\n\t\tgb_inode = ocfs2_get_system_file_inode(osb, type,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\t\tif (!gb_inode) {\n\t\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type,\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t    &blkno);\n\t\tif (status < 0) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_info_freefrag_scan_bitmap(osb, gb_inode, blkno, oiff);\n\tif (status < 0)\n\t\tgoto bail;\n\n\to2info_set_request_filled(&oiff->iff_req);\n\n\tif (o2info_to_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oiff->iff_req, req);\nout_free:\n\tkfree(oiff);\nout_err:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_freeinode",
          "args": [
            "inode",
            "req"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_freeinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "328-400",
          "snippet": "static int ocfs2_info_handle_freeinode(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tu32 i;\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = INODE_ALLOC_SYSTEM_INODE;\n\tstruct ocfs2_info_freeinode *oifi = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *inode_alloc = NULL;\n\n\toifi = kzalloc(sizeof(struct ocfs2_info_freeinode), GFP_KERNEL);\n\tif (!oifi) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\toifi->ifi_slotnum = osb->max_slots;\n\n\tfor (i = 0; i < oifi->ifi_slotnum; i++) {\n\t\tif (o2info_coherent(&oifi->ifi_req)) {\n\t\t\tinode_alloc = ocfs2_get_system_file_inode(osb, type, i);\n\t\t\tif (!inode_alloc) {\n\t\t\t\tmlog(ML_ERROR, \"unable to get alloc inode in \"\n\t\t\t\t    \"slot %u\\n\", i);\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else {\n\t\t\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\t\t\ttype, i);\n\t\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t\t    &blkno);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOENT;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_info_scan_inode_alloc(osb, inode_alloc, blkno, oifi, i);\n\n\t\tiput(inode_alloc);\n\t\tinode_alloc = NULL;\n\n\t\tif (status < 0)\n\t\t\tgoto bail;\n\t}\n\n\to2info_set_request_filled(&oifi->ifi_req);\n\n\tif (o2info_to_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oifi->ifi_req, req);\nout_free:\n\tkfree(oifi);\nout_err:\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_freeinode(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tu32 i;\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = INODE_ALLOC_SYSTEM_INODE;\n\tstruct ocfs2_info_freeinode *oifi = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *inode_alloc = NULL;\n\n\toifi = kzalloc(sizeof(struct ocfs2_info_freeinode), GFP_KERNEL);\n\tif (!oifi) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\toifi->ifi_slotnum = osb->max_slots;\n\n\tfor (i = 0; i < oifi->ifi_slotnum; i++) {\n\t\tif (o2info_coherent(&oifi->ifi_req)) {\n\t\t\tinode_alloc = ocfs2_get_system_file_inode(osb, type, i);\n\t\t\tif (!inode_alloc) {\n\t\t\t\tmlog(ML_ERROR, \"unable to get alloc inode in \"\n\t\t\t\t    \"slot %u\\n\", i);\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else {\n\t\t\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\t\t\ttype, i);\n\t\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t\t    &blkno);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOENT;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_info_scan_inode_alloc(osb, inode_alloc, blkno, oifi, i);\n\n\t\tiput(inode_alloc);\n\t\tinode_alloc = NULL;\n\n\t\tif (status < 0)\n\t\t\tgoto bail;\n\t}\n\n\to2info_set_request_filled(&oifi->ifi_req);\n\n\tif (o2info_to_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oifi->ifi_req, req);\nout_free:\n\tkfree(oifi);\nout_err:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_journal_size",
          "args": [
            "inode",
            "req"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_journal_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "261-278",
          "snippet": "static int ocfs2_info_handle_journal_size(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_journal_size oij;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oij, req))\n\t\treturn -EFAULT;\n\n\toij.ij_journal_size = i_size_read(osb->journal->j_inode);\n\n\to2info_set_request_filled(&oij.ij_req);\n\n\tif (o2info_to_user(oij, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_journal_size(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_journal_size oij;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oij, req))\n\t\treturn -EFAULT;\n\n\toij.ij_journal_size = i_size_read(osb->journal->j_inode);\n\n\to2info_set_request_filled(&oij.ij_req);\n\n\tif (o2info_to_user(oij, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_fs_features",
          "args": [
            "inode",
            "req"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_fs_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "240-259",
          "snippet": "static int ocfs2_info_handle_fs_features(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_fs_features oif;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oif, req))\n\t\treturn -EFAULT;\n\n\toif.if_compat_features = osb->s_feature_compat;\n\toif.if_incompat_features = osb->s_feature_incompat;\n\toif.if_ro_compat_features = osb->s_feature_ro_compat;\n\n\to2info_set_request_filled(&oif.if_req);\n\n\tif (o2info_to_user(oif, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_fs_features(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_fs_features oif;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oif, req))\n\t\treturn -EFAULT;\n\n\toif.if_compat_features = osb->s_feature_compat;\n\toif.if_incompat_features = osb->s_feature_incompat;\n\toif.if_ro_compat_features = osb->s_feature_ro_compat;\n\n\to2info_set_request_filled(&oif.if_req);\n\n\tif (o2info_to_user(oif, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_uuid",
          "args": [
            "inode",
            "req"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "221-238",
          "snippet": "static int ocfs2_info_handle_uuid(struct inode *inode,\n\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_uuid oiu;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oiu, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oiu.iu_uuid_str, osb->uuid_str, OCFS2_TEXT_UUID_LEN + 1);\n\n\to2info_set_request_filled(&oiu.iu_req);\n\n\tif (o2info_to_user(oiu, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_uuid(struct inode *inode,\n\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_uuid oiu;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oiu, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oiu.iu_uuid_str, osb->uuid_str, OCFS2_TEXT_UUID_LEN + 1);\n\n\to2info_set_request_filled(&oiu.iu_req);\n\n\tif (o2info_to_user(oiu, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_label",
          "args": [
            "inode",
            "req"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "202-219",
          "snippet": "static int ocfs2_info_handle_label(struct inode *inode,\n\t\t\t\t   struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_label oil;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oil, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oil.il_label, osb->vol_label, OCFS2_MAX_VOL_LABEL_LEN);\n\n\to2info_set_request_filled(&oil.il_req);\n\n\tif (o2info_to_user(oil, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_label(struct inode *inode,\n\t\t\t\t   struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_label oil;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oil, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oil.il_label, osb->vol_label, OCFS2_MAX_VOL_LABEL_LEN);\n\n\to2info_set_request_filled(&oil.il_req);\n\n\tif (o2info_to_user(oil, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_maxslots",
          "args": [
            "inode",
            "req"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_maxslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "183-200",
          "snippet": "static int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_clustersize",
          "args": [
            "inode",
            "req"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_clustersize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "164-181",
          "snippet": "static int ocfs2_info_handle_clustersize(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_clustersize oic;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oic, req))\n\t\treturn -EFAULT;\n\n\toic.ic_clustersize = osb->s_clustersize;\n\n\to2info_set_request_filled(&oic.ic_req);\n\n\tif (o2info_to_user(oic, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_clustersize(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_clustersize oic;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oic, req))\n\t\treturn -EFAULT;\n\n\toic.ic_clustersize = osb->s_clustersize;\n\n\to2info_set_request_filled(&oic.ic_req);\n\n\tif (o2info_to_user(oic, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_handle_blocksize",
          "args": [
            "inode",
            "req"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "146-162",
          "snippet": "static int ocfs2_info_handle_blocksize(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_blocksize oib;\n\n\tif (o2info_from_user(oib, req))\n\t\treturn -EFAULT;\n\n\toib.ib_blocksize = inode->i_sb->s_blocksize;\n\n\to2info_set_request_filled(&oib.ib_req);\n\n\tif (o2info_to_user(oib, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_blocksize(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_blocksize oib;\n\n\tif (o2info_from_user(oib, req))\n\t\treturn -EFAULT;\n\n\toib.ib_blocksize = inode->i_sb->s_blocksize;\n\n\to2info_set_request_filled(&oib.ib_req);\n\n\tif (o2info_to_user(oib, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oir",
            "req"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_request(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tint status = -EFAULT;\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\tgoto bail;\n\n\tstatus = -EINVAL;\n\tif (oir.ir_magic != OCFS2_INFO_MAGIC)\n\t\tgoto bail;\n\n\tswitch (oir.ir_code) {\n\tcase OCFS2_INFO_BLOCKSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_blocksize))\n\t\t\tstatus = ocfs2_info_handle_blocksize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_CLUSTERSIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_clustersize))\n\t\t\tstatus = ocfs2_info_handle_clustersize(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_MAXSLOTS:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_maxslots))\n\t\t\tstatus = ocfs2_info_handle_maxslots(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_LABEL:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_label))\n\t\t\tstatus = ocfs2_info_handle_label(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_UUID:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_uuid))\n\t\t\tstatus = ocfs2_info_handle_uuid(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FS_FEATURES:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_fs_features))\n\t\t\tstatus = ocfs2_info_handle_fs_features(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_JOURNAL_SIZE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_journal_size))\n\t\t\tstatus = ocfs2_info_handle_journal_size(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEINODE:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freeinode))\n\t\t\tstatus = ocfs2_info_handle_freeinode(inode, req);\n\t\tbreak;\n\tcase OCFS2_INFO_FREEFRAG:\n\t\tif (oir.ir_size == sizeof(struct ocfs2_info_freefrag))\n\t\t\tstatus = ocfs2_info_handle_freefrag(inode, req);\n\t\tbreak;\n\tdefault:\n\t\tstatus = ocfs2_info_handle_unknown(inode, req);\n\t\tbreak;\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_unknown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "689-703",
    "snippet": "static int ocfs2_info_handle_unknown(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\treturn -EFAULT;\n\n\to2info_clear_request_filled(&oir);\n\n\tif (o2info_to_user(oir, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oir",
            "req"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_clear_request_filled",
          "args": [
            "&oir"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_clear_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "54-57",
          "snippet": "static inline void o2info_clear_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags &= ~OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_clear_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags &= ~OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oir",
            "req"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_unknown(struct inode *inode,\n\t\t\t\t     struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_request oir;\n\n\tif (o2info_from_user(oir, req))\n\t\treturn -EFAULT;\n\n\to2info_clear_request_filled(&oir);\n\n\tif (o2info_to_user(oir, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_freefrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "616-687",
    "snippet": "static int ocfs2_info_handle_freefrag(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = GLOBAL_BITMAP_SYSTEM_INODE;\n\n\tstruct ocfs2_info_freefrag *oiff;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *gb_inode = NULL;\n\n\toiff = kzalloc(sizeof(struct ocfs2_info_freefrag), GFP_KERNEL);\n\tif (!oiff) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\t/*\n\t * chunksize from userspace should be power of 2.\n\t */\n\tif ((oiff->iff_chunksize & (oiff->iff_chunksize - 1)) ||\n\t    (!oiff->iff_chunksize)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (o2info_coherent(&oiff->iff_req)) {\n\t\tgb_inode = ocfs2_get_system_file_inode(osb, type,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\t\tif (!gb_inode) {\n\t\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type,\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t    &blkno);\n\t\tif (status < 0) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_info_freefrag_scan_bitmap(osb, gb_inode, blkno, oiff);\n\tif (status < 0)\n\t\tgoto bail;\n\n\to2info_set_request_filled(&oiff->iff_req);\n\n\tif (o2info_to_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oiff->iff_req, req);\nout_free:\n\tkfree(oiff);\nout_err:\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oiff"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_set_request_error",
          "args": [
            "&oiff->iff_req",
            "req"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "42-47",
          "snippet": "static inline void o2info_set_request_error(struct ocfs2_info_request *kreq,\n\t\t\t\t\tstruct ocfs2_info_request __user *req)\n{\n\tkreq->ir_flags |= OCFS2_INFO_FL_ERROR;\n\t(void)put_user(kreq->ir_flags, (__u32 __user *)&(req->ir_flags));\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_error(struct ocfs2_info_request *kreq,\n\t\t\t\t\tstruct ocfs2_info_request __user *req)\n{\n\tkreq->ir_flags |= OCFS2_INFO_FL_ERROR;\n\t(void)put_user(kreq->ir_flags, (__u32 __user *)&(req->ir_flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "*oiff",
            "req"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oiff->iff_req"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_freefrag_scan_bitmap",
          "args": [
            "osb",
            "gb_inode",
            "blkno",
            "oiff"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_freefrag_scan_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "538-614",
          "snippet": "static int ocfs2_info_freefrag_scan_bitmap(struct ocfs2_super *osb,\n\t\t\t\t\t   struct inode *gb_inode, u64 blkno,\n\t\t\t\t\t   struct ocfs2_info_freefrag *ffg)\n{\n\tu32 chunks_in_group;\n\tint status = 0, unlock = 0, i;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_chain_list *cl = NULL;\n\tstruct ocfs2_chain_rec *rec = NULL;\n\tstruct ocfs2_dinode *gb_dinode = NULL;\n\n\tif (gb_inode)\n\t\tinode_lock(gb_inode);\n\n\tif (o2info_coherent(&ffg->iff_req)) {\n\t\tstatus = ocfs2_inode_lock(gb_inode, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tgb_dinode = (struct ocfs2_dinode *)bh->b_data;\n\tcl = &(gb_dinode->id2.i_chain);\n\n\t/*\n\t * Chunksize(in) clusters from userspace should be\n\t * less than clusters in a group.\n\t */\n\tif (ffg->iff_chunksize > le16_to_cpu(cl->cl_cpg)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmemset(&ffg->iff_ffs, 0, sizeof(struct ocfs2_info_freefrag_stats));\n\n\tffg->iff_ffs.ffs_min = ~0U;\n\tffg->iff_ffs.ffs_clusters =\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_total);\n\tffg->iff_ffs.ffs_free_clusters = ffg->iff_ffs.ffs_clusters -\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_used);\n\n\tchunks_in_group = le16_to_cpu(cl->cl_cpg) / ffg->iff_chunksize + 1;\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\t\trec = &(cl->cl_recs[i]);\n\t\tstatus = ocfs2_info_freefrag_scan_chain(osb, gb_inode,\n\t\t\t\t\t\t\tgb_dinode,\n\t\t\t\t\t\t\trec, ffg,\n\t\t\t\t\t\t\tchunks_in_group);\n\t\tif (status)\n\t\t\tgoto bail;\n\t}\n\n\tif (ffg->iff_ffs.ffs_free_chunks_real)\n\t\tffg->iff_ffs.ffs_avg = (ffg->iff_ffs.ffs_avg /\n\t\t\t\t\tffg->iff_ffs.ffs_free_chunks_real);\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(gb_inode, 0);\n\n\tif (gb_inode)\n\t\tinode_unlock(gb_inode);\n\n\tiput(gb_inode);\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_freefrag_scan_bitmap(struct ocfs2_super *osb,\n\t\t\t\t\t   struct inode *gb_inode, u64 blkno,\n\t\t\t\t\t   struct ocfs2_info_freefrag *ffg)\n{\n\tu32 chunks_in_group;\n\tint status = 0, unlock = 0, i;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_chain_list *cl = NULL;\n\tstruct ocfs2_chain_rec *rec = NULL;\n\tstruct ocfs2_dinode *gb_dinode = NULL;\n\n\tif (gb_inode)\n\t\tinode_lock(gb_inode);\n\n\tif (o2info_coherent(&ffg->iff_req)) {\n\t\tstatus = ocfs2_inode_lock(gb_inode, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tgb_dinode = (struct ocfs2_dinode *)bh->b_data;\n\tcl = &(gb_dinode->id2.i_chain);\n\n\t/*\n\t * Chunksize(in) clusters from userspace should be\n\t * less than clusters in a group.\n\t */\n\tif (ffg->iff_chunksize > le16_to_cpu(cl->cl_cpg)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmemset(&ffg->iff_ffs, 0, sizeof(struct ocfs2_info_freefrag_stats));\n\n\tffg->iff_ffs.ffs_min = ~0U;\n\tffg->iff_ffs.ffs_clusters =\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_total);\n\tffg->iff_ffs.ffs_free_clusters = ffg->iff_ffs.ffs_clusters -\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_used);\n\n\tchunks_in_group = le16_to_cpu(cl->cl_cpg) / ffg->iff_chunksize + 1;\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\t\trec = &(cl->cl_recs[i]);\n\t\tstatus = ocfs2_info_freefrag_scan_chain(osb, gb_inode,\n\t\t\t\t\t\t\tgb_dinode,\n\t\t\t\t\t\t\trec, ffg,\n\t\t\t\t\t\t\tchunks_in_group);\n\t\tif (status)\n\t\t\tgoto bail;\n\t}\n\n\tif (ffg->iff_ffs.ffs_free_chunks_real)\n\t\tffg->iff_ffs.ffs_avg = (ffg->iff_ffs.ffs_avg /\n\t\t\t\t\tffg->iff_ffs.ffs_free_chunks_real);\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(gb_inode, 0);\n\n\tif (gb_inode)\n\t\tinode_unlock(gb_inode);\n\n\tiput(gb_inode);\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "osb->sys_root_inode",
            "namebuf",
            "strlen(namebuf)",
            "&blkno"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2017-2027",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "namebuf"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sprintf_system_inode_name",
          "args": [
            "namebuf",
            "sizeof(namebuf)",
            "type",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1608-1627",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\nstatic inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unable to get global_bitmap inode\\n\""
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "type",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/sysfile.c",
          "lines": "139-182",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_coherent",
          "args": [
            "&oiff->iff_req"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "59-62",
          "snippet": "static inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "*oiff",
            "req"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_info_freefrag)",
            "GFP_KERNEL"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_freefrag(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = GLOBAL_BITMAP_SYSTEM_INODE;\n\n\tstruct ocfs2_info_freefrag *oiff;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *gb_inode = NULL;\n\n\toiff = kzalloc(sizeof(struct ocfs2_info_freefrag), GFP_KERNEL);\n\tif (!oiff) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\t/*\n\t * chunksize from userspace should be power of 2.\n\t */\n\tif ((oiff->iff_chunksize & (oiff->iff_chunksize - 1)) ||\n\t    (!oiff->iff_chunksize)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (o2info_coherent(&oiff->iff_req)) {\n\t\tgb_inode = ocfs2_get_system_file_inode(osb, type,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\t\tif (!gb_inode) {\n\t\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type,\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t    &blkno);\n\t\tif (status < 0) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_info_freefrag_scan_bitmap(osb, gb_inode, blkno, oiff);\n\tif (status < 0)\n\t\tgoto bail;\n\n\to2info_set_request_filled(&oiff->iff_req);\n\n\tif (o2info_to_user(*oiff, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oiff->iff_req, req);\nout_free:\n\tkfree(oiff);\nout_err:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_info_freefrag_scan_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "538-614",
    "snippet": "static int ocfs2_info_freefrag_scan_bitmap(struct ocfs2_super *osb,\n\t\t\t\t\t   struct inode *gb_inode, u64 blkno,\n\t\t\t\t\t   struct ocfs2_info_freefrag *ffg)\n{\n\tu32 chunks_in_group;\n\tint status = 0, unlock = 0, i;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_chain_list *cl = NULL;\n\tstruct ocfs2_chain_rec *rec = NULL;\n\tstruct ocfs2_dinode *gb_dinode = NULL;\n\n\tif (gb_inode)\n\t\tinode_lock(gb_inode);\n\n\tif (o2info_coherent(&ffg->iff_req)) {\n\t\tstatus = ocfs2_inode_lock(gb_inode, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tgb_dinode = (struct ocfs2_dinode *)bh->b_data;\n\tcl = &(gb_dinode->id2.i_chain);\n\n\t/*\n\t * Chunksize(in) clusters from userspace should be\n\t * less than clusters in a group.\n\t */\n\tif (ffg->iff_chunksize > le16_to_cpu(cl->cl_cpg)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmemset(&ffg->iff_ffs, 0, sizeof(struct ocfs2_info_freefrag_stats));\n\n\tffg->iff_ffs.ffs_min = ~0U;\n\tffg->iff_ffs.ffs_clusters =\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_total);\n\tffg->iff_ffs.ffs_free_clusters = ffg->iff_ffs.ffs_clusters -\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_used);\n\n\tchunks_in_group = le16_to_cpu(cl->cl_cpg) / ffg->iff_chunksize + 1;\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\t\trec = &(cl->cl_recs[i]);\n\t\tstatus = ocfs2_info_freefrag_scan_chain(osb, gb_inode,\n\t\t\t\t\t\t\tgb_dinode,\n\t\t\t\t\t\t\trec, ffg,\n\t\t\t\t\t\t\tchunks_in_group);\n\t\tif (status)\n\t\t\tgoto bail;\n\t}\n\n\tif (ffg->iff_ffs.ffs_free_chunks_real)\n\t\tffg->iff_ffs.ffs_avg = (ffg->iff_ffs.ffs_avg /\n\t\t\t\t\tffg->iff_ffs.ffs_free_chunks_real);\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(gb_inode, 0);\n\n\tif (gb_inode)\n\t\tinode_unlock(gb_inode);\n\n\tiput(gb_inode);\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "gb_inode"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "gb_inode"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "gb_inode",
            "0"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2589-2603",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_freefrag_scan_chain",
          "args": [
            "osb",
            "gb_inode",
            "gb_dinode",
            "rec",
            "ffg",
            "chunks_in_group"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_freefrag_scan_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "435-536",
          "snippet": "static int ocfs2_info_freefrag_scan_chain(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *gb_inode,\n\t\t\t\t\t  struct ocfs2_dinode *gb_dinode,\n\t\t\t\t\t  struct ocfs2_chain_rec *rec,\n\t\t\t\t\t  struct ocfs2_info_freefrag *ffg,\n\t\t\t\t\t  u32 chunks_in_group)\n{\n\tint status = 0, used;\n\tu64 blkno;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_group_desc *bg = NULL;\n\n\tunsigned int max_bits, num_clusters;\n\tunsigned int offset = 0, cluster, chunk;\n\tunsigned int chunk_free, last_chunksize = 0;\n\n\tif (!le32_to_cpu(rec->c_free))\n\t\tgoto bail;\n\n\tdo {\n\t\tif (!bg)\n\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\telse\n\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\tif (bh) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tif (o2info_coherent(&ffg->iff_req))\n\t\t\tstatus = ocfs2_read_group_descriptor(gb_inode,\n\t\t\t\t\t\t\t     gb_dinode,\n\t\t\t\t\t\t\t     blkno, &bh);\n\t\telse\n\t\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\", (unsigned long long)blkno);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbg = (struct ocfs2_group_desc *)bh->b_data;\n\n\t\tif (!le16_to_cpu(bg->bg_free_bits_count))\n\t\t\tcontinue;\n\n\t\tmax_bits = le16_to_cpu(bg->bg_bits);\n\t\toffset = 0;\n\n\t\tfor (chunk = 0; chunk < chunks_in_group; chunk++) {\n\t\t\t/*\n\t\t\t * last chunk may be not an entire one.\n\t\t\t */\n\t\t\tif ((offset + ffg->iff_chunksize) > max_bits)\n\t\t\t\tnum_clusters = max_bits - offset;\n\t\t\telse\n\t\t\t\tnum_clusters = ffg->iff_chunksize;\n\n\t\t\tchunk_free = 0;\n\t\t\tfor (cluster = 0; cluster < num_clusters; cluster++) {\n\t\t\t\tused = ocfs2_test_bit(offset,\n\t\t\t\t\t\t(unsigned long *)bg->bg_bitmap);\n\t\t\t\t/*\n\t\t\t\t * - chunk_free counts free clusters in #N chunk.\n\t\t\t\t * - last_chunksize records the size(in) clusters\n\t\t\t\t *   for the last real free chunk being counted.\n\t\t\t\t */\n\t\t\t\tif (!used) {\n\t\t\t\t\tlast_chunksize++;\n\t\t\t\t\tchunk_free++;\n\t\t\t\t}\n\n\t\t\t\tif (used && last_chunksize) {\n\t\t\t\t\tocfs2_info_update_ffg(ffg,\n\t\t\t\t\t\t\t      last_chunksize);\n\t\t\t\t\tlast_chunksize = 0;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (chunk_free == ffg->iff_chunksize)\n\t\t\t\tffg->iff_ffs.ffs_free_chunks++;\n\t\t}\n\n\t\t/*\n\t\t * need to update the info for last free chunk.\n\t\t */\n\t\tif (last_chunksize)\n\t\t\tocfs2_info_update_ffg(ffg, last_chunksize);\n\n\t} while (le64_to_cpu(bg->bg_next_group));\n\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_freefrag_scan_chain(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *gb_inode,\n\t\t\t\t\t  struct ocfs2_dinode *gb_dinode,\n\t\t\t\t\t  struct ocfs2_chain_rec *rec,\n\t\t\t\t\t  struct ocfs2_info_freefrag *ffg,\n\t\t\t\t\t  u32 chunks_in_group)\n{\n\tint status = 0, used;\n\tu64 blkno;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_group_desc *bg = NULL;\n\n\tunsigned int max_bits, num_clusters;\n\tunsigned int offset = 0, cluster, chunk;\n\tunsigned int chunk_free, last_chunksize = 0;\n\n\tif (!le32_to_cpu(rec->c_free))\n\t\tgoto bail;\n\n\tdo {\n\t\tif (!bg)\n\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\telse\n\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\tif (bh) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tif (o2info_coherent(&ffg->iff_req))\n\t\t\tstatus = ocfs2_read_group_descriptor(gb_inode,\n\t\t\t\t\t\t\t     gb_dinode,\n\t\t\t\t\t\t\t     blkno, &bh);\n\t\telse\n\t\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\", (unsigned long long)blkno);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbg = (struct ocfs2_group_desc *)bh->b_data;\n\n\t\tif (!le16_to_cpu(bg->bg_free_bits_count))\n\t\t\tcontinue;\n\n\t\tmax_bits = le16_to_cpu(bg->bg_bits);\n\t\toffset = 0;\n\n\t\tfor (chunk = 0; chunk < chunks_in_group; chunk++) {\n\t\t\t/*\n\t\t\t * last chunk may be not an entire one.\n\t\t\t */\n\t\t\tif ((offset + ffg->iff_chunksize) > max_bits)\n\t\t\t\tnum_clusters = max_bits - offset;\n\t\t\telse\n\t\t\t\tnum_clusters = ffg->iff_chunksize;\n\n\t\t\tchunk_free = 0;\n\t\t\tfor (cluster = 0; cluster < num_clusters; cluster++) {\n\t\t\t\tused = ocfs2_test_bit(offset,\n\t\t\t\t\t\t(unsigned long *)bg->bg_bitmap);\n\t\t\t\t/*\n\t\t\t\t * - chunk_free counts free clusters in #N chunk.\n\t\t\t\t * - last_chunksize records the size(in) clusters\n\t\t\t\t *   for the last real free chunk being counted.\n\t\t\t\t */\n\t\t\t\tif (!used) {\n\t\t\t\t\tlast_chunksize++;\n\t\t\t\t\tchunk_free++;\n\t\t\t\t}\n\n\t\t\t\tif (used && last_chunksize) {\n\t\t\t\t\tocfs2_info_update_ffg(ffg,\n\t\t\t\t\t\t\t      last_chunksize);\n\t\t\t\t\tlast_chunksize = 0;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (chunk_free == ffg->iff_chunksize)\n\t\t\t\tffg->iff_ffs.ffs_free_chunks++;\n\t\t}\n\n\t\t/*\n\t\t * need to update the info for last free chunk.\n\t\t */\n\t\tif (last_chunksize)\n\t\t\tocfs2_info_update_ffg(ffg, last_chunksize);\n\n\t} while (le64_to_cpu(bg->bg_next_group));\n\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_next_free_rec"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gb_dinode->id1.bitmap1.i_used"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ffg->iff_ffs",
            "0",
            "sizeof(struct ocfs2_info_freefrag_stats)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "blkno",
            "1",
            "&bh"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "105-205",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bio.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bio.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "gb_inode",
            "&bh",
            "0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_coherent",
          "args": [
            "&ffg->iff_req"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "59-62",
          "snippet": "static inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "gb_inode"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_freefrag_scan_bitmap(struct ocfs2_super *osb,\n\t\t\t\t\t   struct inode *gb_inode, u64 blkno,\n\t\t\t\t\t   struct ocfs2_info_freefrag *ffg)\n{\n\tu32 chunks_in_group;\n\tint status = 0, unlock = 0, i;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_chain_list *cl = NULL;\n\tstruct ocfs2_chain_rec *rec = NULL;\n\tstruct ocfs2_dinode *gb_dinode = NULL;\n\n\tif (gb_inode)\n\t\tinode_lock(gb_inode);\n\n\tif (o2info_coherent(&ffg->iff_req)) {\n\t\tstatus = ocfs2_inode_lock(gb_inode, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tgb_dinode = (struct ocfs2_dinode *)bh->b_data;\n\tcl = &(gb_dinode->id2.i_chain);\n\n\t/*\n\t * Chunksize(in) clusters from userspace should be\n\t * less than clusters in a group.\n\t */\n\tif (ffg->iff_chunksize > le16_to_cpu(cl->cl_cpg)) {\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmemset(&ffg->iff_ffs, 0, sizeof(struct ocfs2_info_freefrag_stats));\n\n\tffg->iff_ffs.ffs_min = ~0U;\n\tffg->iff_ffs.ffs_clusters =\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_total);\n\tffg->iff_ffs.ffs_free_clusters = ffg->iff_ffs.ffs_clusters -\n\t\t\tle32_to_cpu(gb_dinode->id1.bitmap1.i_used);\n\n\tchunks_in_group = le16_to_cpu(cl->cl_cpg) / ffg->iff_chunksize + 1;\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\t\trec = &(cl->cl_recs[i]);\n\t\tstatus = ocfs2_info_freefrag_scan_chain(osb, gb_inode,\n\t\t\t\t\t\t\tgb_dinode,\n\t\t\t\t\t\t\trec, ffg,\n\t\t\t\t\t\t\tchunks_in_group);\n\t\tif (status)\n\t\t\tgoto bail;\n\t}\n\n\tif (ffg->iff_ffs.ffs_free_chunks_real)\n\t\tffg->iff_ffs.ffs_avg = (ffg->iff_ffs.ffs_avg /\n\t\t\t\t\tffg->iff_ffs.ffs_free_chunks_real);\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(gb_inode, 0);\n\n\tif (gb_inode)\n\t\tinode_unlock(gb_inode);\n\n\tiput(gb_inode);\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_info_freefrag_scan_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "435-536",
    "snippet": "static int ocfs2_info_freefrag_scan_chain(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *gb_inode,\n\t\t\t\t\t  struct ocfs2_dinode *gb_dinode,\n\t\t\t\t\t  struct ocfs2_chain_rec *rec,\n\t\t\t\t\t  struct ocfs2_info_freefrag *ffg,\n\t\t\t\t\t  u32 chunks_in_group)\n{\n\tint status = 0, used;\n\tu64 blkno;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_group_desc *bg = NULL;\n\n\tunsigned int max_bits, num_clusters;\n\tunsigned int offset = 0, cluster, chunk;\n\tunsigned int chunk_free, last_chunksize = 0;\n\n\tif (!le32_to_cpu(rec->c_free))\n\t\tgoto bail;\n\n\tdo {\n\t\tif (!bg)\n\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\telse\n\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\tif (bh) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tif (o2info_coherent(&ffg->iff_req))\n\t\t\tstatus = ocfs2_read_group_descriptor(gb_inode,\n\t\t\t\t\t\t\t     gb_dinode,\n\t\t\t\t\t\t\t     blkno, &bh);\n\t\telse\n\t\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\", (unsigned long long)blkno);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbg = (struct ocfs2_group_desc *)bh->b_data;\n\n\t\tif (!le16_to_cpu(bg->bg_free_bits_count))\n\t\t\tcontinue;\n\n\t\tmax_bits = le16_to_cpu(bg->bg_bits);\n\t\toffset = 0;\n\n\t\tfor (chunk = 0; chunk < chunks_in_group; chunk++) {\n\t\t\t/*\n\t\t\t * last chunk may be not an entire one.\n\t\t\t */\n\t\t\tif ((offset + ffg->iff_chunksize) > max_bits)\n\t\t\t\tnum_clusters = max_bits - offset;\n\t\t\telse\n\t\t\t\tnum_clusters = ffg->iff_chunksize;\n\n\t\t\tchunk_free = 0;\n\t\t\tfor (cluster = 0; cluster < num_clusters; cluster++) {\n\t\t\t\tused = ocfs2_test_bit(offset,\n\t\t\t\t\t\t(unsigned long *)bg->bg_bitmap);\n\t\t\t\t/*\n\t\t\t\t * - chunk_free counts free clusters in #N chunk.\n\t\t\t\t * - last_chunksize records the size(in) clusters\n\t\t\t\t *   for the last real free chunk being counted.\n\t\t\t\t */\n\t\t\t\tif (!used) {\n\t\t\t\t\tlast_chunksize++;\n\t\t\t\t\tchunk_free++;\n\t\t\t\t}\n\n\t\t\t\tif (used && last_chunksize) {\n\t\t\t\t\tocfs2_info_update_ffg(ffg,\n\t\t\t\t\t\t\t      last_chunksize);\n\t\t\t\t\tlast_chunksize = 0;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (chunk_free == ffg->iff_chunksize)\n\t\t\t\tffg->iff_ffs.ffs_free_chunks++;\n\t\t}\n\n\t\t/*\n\t\t * need to update the info for last free chunk.\n\t\t */\n\t\tif (last_chunksize)\n\t\t\tocfs2_info_update_ffg(ffg, last_chunksize);\n\n\t} while (le64_to_cpu(bg->bg_next_group));\n\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "bg->bg_next_group"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_update_ffg",
          "args": [
            "ffg",
            "last_chunksize"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_update_ffg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "428-433",
          "snippet": "static void ocfs2_info_update_ffg(struct ocfs2_info_freefrag *ffg,\n\t\t\t\t  unsigned int chunksize)\n{\n\to2ffg_update_histogram(&(ffg->iff_ffs.ffs_fc_hist), chunksize);\n\to2ffg_update_stats(&(ffg->iff_ffs), chunksize);\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_info_update_ffg(struct ocfs2_info_freefrag *ffg,\n\t\t\t\t  unsigned int chunksize)\n{\n\to2ffg_update_histogram(&(ffg->iff_ffs.ffs_fc_hist), chunksize);\n\to2ffg_update_stats(&(ffg->iff_ffs), chunksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit",
          "args": [
            "offset",
            "(unsigned long *)bg->bg_bitmap"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_bits"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\"",
            "(unsigned long long)blkno"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "141-147",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "blkno",
            "1",
            "&bh"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "105-205",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bio.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bio.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "gb_inode",
            "gb_dinode",
            "blkno",
            "&bh"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/suballoc.c",
          "lines": "309-332",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_coherent",
          "args": [
            "&ffg->iff_req"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "59-62",
          "snippet": "static inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->c_free"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_freefrag_scan_chain(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *gb_inode,\n\t\t\t\t\t  struct ocfs2_dinode *gb_dinode,\n\t\t\t\t\t  struct ocfs2_chain_rec *rec,\n\t\t\t\t\t  struct ocfs2_info_freefrag *ffg,\n\t\t\t\t\t  u32 chunks_in_group)\n{\n\tint status = 0, used;\n\tu64 blkno;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_group_desc *bg = NULL;\n\n\tunsigned int max_bits, num_clusters;\n\tunsigned int offset = 0, cluster, chunk;\n\tunsigned int chunk_free, last_chunksize = 0;\n\n\tif (!le32_to_cpu(rec->c_free))\n\t\tgoto bail;\n\n\tdo {\n\t\tif (!bg)\n\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\telse\n\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\tif (bh) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t}\n\n\t\tif (o2info_coherent(&ffg->iff_req))\n\t\t\tstatus = ocfs2_read_group_descriptor(gb_inode,\n\t\t\t\t\t\t\t     gb_dinode,\n\t\t\t\t\t\t\t     blkno, &bh);\n\t\telse\n\t\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"Can't read the group descriptor # \"\n\t\t\t     \"%llu from device.\", (unsigned long long)blkno);\n\t\t\tstatus = -EIO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\tbg = (struct ocfs2_group_desc *)bh->b_data;\n\n\t\tif (!le16_to_cpu(bg->bg_free_bits_count))\n\t\t\tcontinue;\n\n\t\tmax_bits = le16_to_cpu(bg->bg_bits);\n\t\toffset = 0;\n\n\t\tfor (chunk = 0; chunk < chunks_in_group; chunk++) {\n\t\t\t/*\n\t\t\t * last chunk may be not an entire one.\n\t\t\t */\n\t\t\tif ((offset + ffg->iff_chunksize) > max_bits)\n\t\t\t\tnum_clusters = max_bits - offset;\n\t\t\telse\n\t\t\t\tnum_clusters = ffg->iff_chunksize;\n\n\t\t\tchunk_free = 0;\n\t\t\tfor (cluster = 0; cluster < num_clusters; cluster++) {\n\t\t\t\tused = ocfs2_test_bit(offset,\n\t\t\t\t\t\t(unsigned long *)bg->bg_bitmap);\n\t\t\t\t/*\n\t\t\t\t * - chunk_free counts free clusters in #N chunk.\n\t\t\t\t * - last_chunksize records the size(in) clusters\n\t\t\t\t *   for the last real free chunk being counted.\n\t\t\t\t */\n\t\t\t\tif (!used) {\n\t\t\t\t\tlast_chunksize++;\n\t\t\t\t\tchunk_free++;\n\t\t\t\t}\n\n\t\t\t\tif (used && last_chunksize) {\n\t\t\t\t\tocfs2_info_update_ffg(ffg,\n\t\t\t\t\t\t\t      last_chunksize);\n\t\t\t\t\tlast_chunksize = 0;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (chunk_free == ffg->iff_chunksize)\n\t\t\t\tffg->iff_ffs.ffs_free_chunks++;\n\t\t}\n\n\t\t/*\n\t\t * need to update the info for last free chunk.\n\t\t */\n\t\tif (last_chunksize)\n\t\t\tocfs2_info_update_ffg(ffg, last_chunksize);\n\n\t} while (le64_to_cpu(bg->bg_next_group));\n\nbail:\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_info_update_ffg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "428-433",
    "snippet": "static void ocfs2_info_update_ffg(struct ocfs2_info_freefrag *ffg,\n\t\t\t\t  unsigned int chunksize)\n{\n\to2ffg_update_histogram(&(ffg->iff_ffs.ffs_fc_hist), chunksize);\n\to2ffg_update_stats(&(ffg->iff_ffs), chunksize);\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2ffg_update_stats",
          "args": [
            "&(ffg->iff_ffs)",
            "chunksize"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "o2ffg_update_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "415-426",
          "snippet": "static void o2ffg_update_stats(struct ocfs2_info_freefrag_stats *stats,\n\t\t\t       unsigned int chunksize)\n{\n\tif (chunksize > stats->ffs_max)\n\t\tstats->ffs_max = chunksize;\n\n\tif (chunksize < stats->ffs_min)\n\t\tstats->ffs_min = chunksize;\n\n\tstats->ffs_avg += chunksize;\n\tstats->ffs_free_chunks_real++;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void o2ffg_update_stats(struct ocfs2_info_freefrag_stats *stats,\n\t\t\t       unsigned int chunksize)\n{\n\tif (chunksize > stats->ffs_max)\n\t\tstats->ffs_max = chunksize;\n\n\tif (chunksize < stats->ffs_min)\n\t\tstats->ffs_min = chunksize;\n\n\tstats->ffs_avg += chunksize;\n\tstats->ffs_free_chunks_real++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2ffg_update_histogram",
          "args": [
            "&(ffg->iff_ffs.ffs_fc_hist)",
            "chunksize"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "o2ffg_update_histogram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "402-413",
          "snippet": "static void o2ffg_update_histogram(struct ocfs2_info_free_chunk_list *hist,\n\t\t\t\t   unsigned int chunksize)\n{\n\tu32 index;\n\n\tindex = __ilog2_u32(chunksize);\n\tif (index >= OCFS2_INFO_MAX_HIST)\n\t\tindex = OCFS2_INFO_MAX_HIST - 1;\n\n\thist->fc_chunks[index]++;\n\thist->fc_clusters[index] += chunksize;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void o2ffg_update_histogram(struct ocfs2_info_free_chunk_list *hist,\n\t\t\t\t   unsigned int chunksize)\n{\n\tu32 index;\n\n\tindex = __ilog2_u32(chunksize);\n\tif (index >= OCFS2_INFO_MAX_HIST)\n\t\tindex = OCFS2_INFO_MAX_HIST - 1;\n\n\thist->fc_chunks[index]++;\n\thist->fc_clusters[index] += chunksize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_info_update_ffg(struct ocfs2_info_freefrag *ffg,\n\t\t\t\t  unsigned int chunksize)\n{\n\to2ffg_update_histogram(&(ffg->iff_ffs.ffs_fc_hist), chunksize);\n\to2ffg_update_stats(&(ffg->iff_ffs), chunksize);\n}"
  },
  {
    "function_name": "o2ffg_update_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "415-426",
    "snippet": "static void o2ffg_update_stats(struct ocfs2_info_freefrag_stats *stats,\n\t\t\t       unsigned int chunksize)\n{\n\tif (chunksize > stats->ffs_max)\n\t\tstats->ffs_max = chunksize;\n\n\tif (chunksize < stats->ffs_min)\n\t\tstats->ffs_min = chunksize;\n\n\tstats->ffs_avg += chunksize;\n\tstats->ffs_free_chunks_real++;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void o2ffg_update_stats(struct ocfs2_info_freefrag_stats *stats,\n\t\t\t       unsigned int chunksize)\n{\n\tif (chunksize > stats->ffs_max)\n\t\tstats->ffs_max = chunksize;\n\n\tif (chunksize < stats->ffs_min)\n\t\tstats->ffs_min = chunksize;\n\n\tstats->ffs_avg += chunksize;\n\tstats->ffs_free_chunks_real++;\n}"
  },
  {
    "function_name": "o2ffg_update_histogram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "402-413",
    "snippet": "static void o2ffg_update_histogram(struct ocfs2_info_free_chunk_list *hist,\n\t\t\t\t   unsigned int chunksize)\n{\n\tu32 index;\n\n\tindex = __ilog2_u32(chunksize);\n\tif (index >= OCFS2_INFO_MAX_HIST)\n\t\tindex = OCFS2_INFO_MAX_HIST - 1;\n\n\thist->fc_chunks[index]++;\n\thist->fc_clusters[index] += chunksize;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ilog2_u32",
          "args": [
            "chunksize"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void o2ffg_update_histogram(struct ocfs2_info_free_chunk_list *hist,\n\t\t\t\t   unsigned int chunksize)\n{\n\tu32 index;\n\n\tindex = __ilog2_u32(chunksize);\n\tif (index >= OCFS2_INFO_MAX_HIST)\n\t\tindex = OCFS2_INFO_MAX_HIST - 1;\n\n\thist->fc_chunks[index]++;\n\thist->fc_clusters[index] += chunksize;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_freeinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "328-400",
    "snippet": "static int ocfs2_info_handle_freeinode(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tu32 i;\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = INODE_ALLOC_SYSTEM_INODE;\n\tstruct ocfs2_info_freeinode *oifi = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *inode_alloc = NULL;\n\n\toifi = kzalloc(sizeof(struct ocfs2_info_freeinode), GFP_KERNEL);\n\tif (!oifi) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\toifi->ifi_slotnum = osb->max_slots;\n\n\tfor (i = 0; i < oifi->ifi_slotnum; i++) {\n\t\tif (o2info_coherent(&oifi->ifi_req)) {\n\t\t\tinode_alloc = ocfs2_get_system_file_inode(osb, type, i);\n\t\t\tif (!inode_alloc) {\n\t\t\t\tmlog(ML_ERROR, \"unable to get alloc inode in \"\n\t\t\t\t    \"slot %u\\n\", i);\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else {\n\t\t\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\t\t\ttype, i);\n\t\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t\t    &blkno);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOENT;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_info_scan_inode_alloc(osb, inode_alloc, blkno, oifi, i);\n\n\t\tiput(inode_alloc);\n\t\tinode_alloc = NULL;\n\n\t\tif (status < 0)\n\t\t\tgoto bail;\n\t}\n\n\to2info_set_request_filled(&oifi->ifi_req);\n\n\tif (o2info_to_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oifi->ifi_req, req);\nout_free:\n\tkfree(oifi);\nout_err:\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oifi"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_set_request_error",
          "args": [
            "&oifi->ifi_req",
            "req"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "42-47",
          "snippet": "static inline void o2info_set_request_error(struct ocfs2_info_request *kreq,\n\t\t\t\t\tstruct ocfs2_info_request __user *req)\n{\n\tkreq->ir_flags |= OCFS2_INFO_FL_ERROR;\n\t(void)put_user(kreq->ir_flags, (__u32 __user *)&(req->ir_flags));\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_error(struct ocfs2_info_request *kreq,\n\t\t\t\t\tstruct ocfs2_info_request __user *req)\n{\n\tkreq->ir_flags |= OCFS2_INFO_FL_ERROR;\n\t(void)put_user(kreq->ir_flags, (__u32 __user *)&(req->ir_flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "*oifi",
            "req"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oifi->ifi_req"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode_alloc"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_info_scan_inode_alloc",
          "args": [
            "osb",
            "inode_alloc",
            "blkno",
            "oifi",
            "i"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_scan_inode_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "280-326",
          "snippet": "static int ocfs2_info_scan_inode_alloc(struct ocfs2_super *osb,\n\t\t\t\t       struct inode *inode_alloc, u64 blkno,\n\t\t\t\t       struct ocfs2_info_freeinode *fi,\n\t\t\t\t       u32 slot)\n{\n\tint status = 0, unlock = 0;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *dinode_alloc = NULL;\n\n\tif (inode_alloc)\n\t\tinode_lock(inode_alloc);\n\n\tif (o2info_coherent(&fi->ifi_req)) {\n\t\tstatus = ocfs2_inode_lock(inode_alloc, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdinode_alloc = (struct ocfs2_dinode *)bh->b_data;\n\n\tfi->ifi_stat[slot].lfi_total =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total);\n\tfi->ifi_stat[slot].lfi_free =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_used);\n\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(inode_alloc, 0);\n\n\tif (inode_alloc)\n\t\tinode_unlock(inode_alloc);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_scan_inode_alloc(struct ocfs2_super *osb,\n\t\t\t\t       struct inode *inode_alloc, u64 blkno,\n\t\t\t\t       struct ocfs2_info_freeinode *fi,\n\t\t\t\t       u32 slot)\n{\n\tint status = 0, unlock = 0;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *dinode_alloc = NULL;\n\n\tif (inode_alloc)\n\t\tinode_lock(inode_alloc);\n\n\tif (o2info_coherent(&fi->ifi_req)) {\n\t\tstatus = ocfs2_inode_lock(inode_alloc, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdinode_alloc = (struct ocfs2_dinode *)bh->b_data;\n\n\tfi->ifi_stat[slot].lfi_total =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total);\n\tfi->ifi_stat[slot].lfi_free =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_used);\n\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(inode_alloc, 0);\n\n\tif (inode_alloc)\n\t\tinode_unlock(inode_alloc);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "osb->sys_root_inode",
            "namebuf",
            "strlen(namebuf)",
            "&blkno"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2017-2027",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "namebuf"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sprintf_system_inode_name",
          "args": [
            "namebuf",
            "sizeof(namebuf)",
            "type",
            "i"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1608-1627",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n\nstatic inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unable to get alloc inode in \"\n\t\t\t\t    \"slot %u\\n\"",
            "i"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "141-147",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "type",
            "i"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/sysfile.c",
          "lines": "139-182",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_coherent",
          "args": [
            "&oifi->ifi_req"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "59-62",
          "snippet": "static inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "*oifi",
            "req"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_info_freeinode)",
            "GFP_KERNEL"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_freeinode(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tu32 i;\n\tu64 blkno = -1;\n\tchar namebuf[40];\n\tint status, type = INODE_ALLOC_SYSTEM_INODE;\n\tstruct ocfs2_info_freeinode *oifi = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *inode_alloc = NULL;\n\n\toifi = kzalloc(sizeof(struct ocfs2_info_freeinode), GFP_KERNEL);\n\tif (!oifi) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tif (o2info_from_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\toifi->ifi_slotnum = osb->max_slots;\n\n\tfor (i = 0; i < oifi->ifi_slotnum; i++) {\n\t\tif (o2info_coherent(&oifi->ifi_req)) {\n\t\t\tinode_alloc = ocfs2_get_system_file_inode(osb, type, i);\n\t\t\tif (!inode_alloc) {\n\t\t\t\tmlog(ML_ERROR, \"unable to get alloc inode in \"\n\t\t\t\t    \"slot %u\\n\", i);\n\t\t\t\tstatus = -EIO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else {\n\t\t\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\t\t\ttype, i);\n\t\t\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode,\n\t\t\t\t\t\t\t    namebuf,\n\t\t\t\t\t\t\t    strlen(namebuf),\n\t\t\t\t\t\t\t    &blkno);\n\t\t\tif (status < 0) {\n\t\t\t\tstatus = -ENOENT;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ocfs2_info_scan_inode_alloc(osb, inode_alloc, blkno, oifi, i);\n\n\t\tiput(inode_alloc);\n\t\tinode_alloc = NULL;\n\n\t\tif (status < 0)\n\t\t\tgoto bail;\n\t}\n\n\to2info_set_request_filled(&oifi->ifi_req);\n\n\tif (o2info_to_user(*oifi, req)) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tstatus = 0;\nbail:\n\tif (status)\n\t\to2info_set_request_error(&oifi->ifi_req, req);\nout_free:\n\tkfree(oifi);\nout_err:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_info_scan_inode_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "280-326",
    "snippet": "static int ocfs2_info_scan_inode_alloc(struct ocfs2_super *osb,\n\t\t\t\t       struct inode *inode_alloc, u64 blkno,\n\t\t\t\t       struct ocfs2_info_freeinode *fi,\n\t\t\t\t       u32 slot)\n{\n\tint status = 0, unlock = 0;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *dinode_alloc = NULL;\n\n\tif (inode_alloc)\n\t\tinode_lock(inode_alloc);\n\n\tif (o2info_coherent(&fi->ifi_req)) {\n\t\tstatus = ocfs2_inode_lock(inode_alloc, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdinode_alloc = (struct ocfs2_dinode *)bh->b_data;\n\n\tfi->ifi_stat[slot].lfi_total =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total);\n\tfi->ifi_stat[slot].lfi_free =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_used);\n\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(inode_alloc, 0);\n\n\tif (inode_alloc)\n\t\tinode_unlock(inode_alloc);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode_alloc"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode_alloc",
            "0"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2589-2603",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dinode_alloc->id1.bitmap1.i_used"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "blkno",
            "1",
            "&bh"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "105-205",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bio.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bio.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\tint new_bh = 0;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\t/* Don't put buffer head and re-assign it to NULL if it is allocated\n\t * outside since the caller can't be aware of this alternation!\n\t */\n\tnew_bh = (bhs[0] == NULL);\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n#else\n\t\t\tunlock_buffer(bh);\n\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, 0, bh);\n\t}\n\nread_failure:\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\tif (unlikely(status)) {\n\t\t\tif (new_bh && bh) {\n\t\t\t\t/* If middle bh fails, let previous bh\n\t\t\t\t * finish its read and then put it to\n\t\t\t\t * aovoid bh leak\n\t\t\t\t */\n\t\t\t\tif (!buffer_jbd(bh))\n\t\t\t\t\twait_on_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i - 1] = NULL;\n\t\t\t} else if (bh && buffer_uptodate(bh)) {\n\t\t\t\tclear_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tgoto read_failure;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode_alloc",
            "&bh",
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_coherent",
          "args": [
            "&fi->ifi_req"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "59-62",
          "snippet": "static inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode_alloc"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_scan_inode_alloc(struct ocfs2_super *osb,\n\t\t\t\t       struct inode *inode_alloc, u64 blkno,\n\t\t\t\t       struct ocfs2_info_freeinode *fi,\n\t\t\t\t       u32 slot)\n{\n\tint status = 0, unlock = 0;\n\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *dinode_alloc = NULL;\n\n\tif (inode_alloc)\n\t\tinode_lock(inode_alloc);\n\n\tif (o2info_coherent(&fi->ifi_req)) {\n\t\tstatus = ocfs2_inode_lock(inode_alloc, &bh, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tunlock = 1;\n\t} else {\n\t\tstatus = ocfs2_read_blocks_sync(osb, blkno, 1, &bh);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tdinode_alloc = (struct ocfs2_dinode *)bh->b_data;\n\n\tfi->ifi_stat[slot].lfi_total =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total);\n\tfi->ifi_stat[slot].lfi_free =\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(dinode_alloc->id1.bitmap1.i_used);\n\nbail:\n\tif (unlock)\n\t\tocfs2_inode_unlock(inode_alloc, 0);\n\n\tif (inode_alloc)\n\t\tinode_unlock(inode_alloc);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_journal_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "261-278",
    "snippet": "static int ocfs2_info_handle_journal_size(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_journal_size oij;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oij, req))\n\t\treturn -EFAULT;\n\n\toij.ij_journal_size = i_size_read(osb->journal->j_inode);\n\n\to2info_set_request_filled(&oij.ij_req);\n\n\tif (o2info_to_user(oij, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oij",
            "req"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oij.ij_req"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "osb->journal->j_inode"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oij",
            "req"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_journal_size(struct inode *inode,\n\t\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_journal_size oij;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oij, req))\n\t\treturn -EFAULT;\n\n\toij.ij_journal_size = i_size_read(osb->journal->j_inode);\n\n\to2info_set_request_filled(&oij.ij_req);\n\n\tif (o2info_to_user(oij, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_fs_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "240-259",
    "snippet": "static int ocfs2_info_handle_fs_features(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_fs_features oif;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oif, req))\n\t\treturn -EFAULT;\n\n\toif.if_compat_features = osb->s_feature_compat;\n\toif.if_incompat_features = osb->s_feature_incompat;\n\toif.if_ro_compat_features = osb->s_feature_ro_compat;\n\n\to2info_set_request_filled(&oif.if_req);\n\n\tif (o2info_to_user(oif, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oif",
            "req"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oif.if_req"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oif",
            "req"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_fs_features(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_fs_features oif;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oif, req))\n\t\treturn -EFAULT;\n\n\toif.if_compat_features = osb->s_feature_compat;\n\toif.if_incompat_features = osb->s_feature_incompat;\n\toif.if_ro_compat_features = osb->s_feature_ro_compat;\n\n\to2info_set_request_filled(&oif.if_req);\n\n\tif (o2info_to_user(oif, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "221-238",
    "snippet": "static int ocfs2_info_handle_uuid(struct inode *inode,\n\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_uuid oiu;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oiu, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oiu.iu_uuid_str, osb->uuid_str, OCFS2_TEXT_UUID_LEN + 1);\n\n\to2info_set_request_filled(&oiu.iu_req);\n\n\tif (o2info_to_user(oiu, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oiu",
            "req"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oiu.iu_req"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "oiu.iu_uuid_str",
            "osb->uuid_str",
            "OCFS2_TEXT_UUID_LEN + 1"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oiu",
            "req"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_uuid(struct inode *inode,\n\t\t\t\t  struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_uuid oiu;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oiu, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oiu.iu_uuid_str, osb->uuid_str, OCFS2_TEXT_UUID_LEN + 1);\n\n\to2info_set_request_filled(&oiu.iu_req);\n\n\tif (o2info_to_user(oiu, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "202-219",
    "snippet": "static int ocfs2_info_handle_label(struct inode *inode,\n\t\t\t\t   struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_label oil;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oil, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oil.il_label, osb->vol_label, OCFS2_MAX_VOL_LABEL_LEN);\n\n\to2info_set_request_filled(&oil.il_req);\n\n\tif (o2info_to_user(oil, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oil",
            "req"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oil.il_req"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "oil.il_label",
            "osb->vol_label",
            "OCFS2_MAX_VOL_LABEL_LEN"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oil",
            "req"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_label(struct inode *inode,\n\t\t\t\t   struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_label oil;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oil, req))\n\t\treturn -EFAULT;\n\n\tmemcpy(oil.il_label, osb->vol_label, OCFS2_MAX_VOL_LABEL_LEN);\n\n\to2info_set_request_filled(&oil.il_req);\n\n\tif (o2info_to_user(oil, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_maxslots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "183-200",
    "snippet": "static int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oim",
            "req"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oim.im_req"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oim",
            "req"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_clustersize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "164-181",
    "snippet": "static int ocfs2_info_handle_clustersize(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_clustersize oic;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oic, req))\n\t\treturn -EFAULT;\n\n\toic.ic_clustersize = osb->s_clustersize;\n\n\to2info_set_request_filled(&oic.ic_req);\n\n\tif (o2info_to_user(oic, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oic",
            "req"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oic.ic_req"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oic",
            "req"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_clustersize(struct inode *inode,\n\t\t\t\t\t struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_clustersize oic;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oic, req))\n\t\treturn -EFAULT;\n\n\toic.ic_clustersize = osb->s_clustersize;\n\n\to2info_set_request_filled(&oic.ic_req);\n\n\tif (o2info_to_user(oic, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_info_handle_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "146-162",
    "snippet": "static int ocfs2_info_handle_blocksize(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_blocksize oib;\n\n\tif (o2info_from_user(oib, req))\n\t\treturn -EFAULT;\n\n\toib.ib_blocksize = inode->i_sb->s_blocksize;\n\n\to2info_set_request_filled(&oib.ib_req);\n\n\tif (o2info_to_user(oib, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2info_to_user",
          "args": [
            "oib",
            "req"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2info_set_request_filled",
          "args": [
            "&oib.ib_req"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "o2info_set_request_filled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
          "lines": "49-52",
          "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2info_from_user",
          "args": [
            "oib",
            "req"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_blocksize(struct inode *inode,\n\t\t\t\t       struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_blocksize oib;\n\n\tif (o2info_from_user(oib, req))\n\t\treturn -EFAULT;\n\n\toib.ib_blocksize = inode->i_sb->s_blocksize;\n\n\to2info_set_request_filled(&oib.ib_req);\n\n\tif (o2info_to_user(oib, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_set_inode_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "80-144",
    "snippet": "static int ocfs2_set_inode_attr(struct inode *inode, unsigned flags,\n\t\t\t\tunsigned mask)\n{\n\tstruct ocfs2_inode_info *ocfs2_inode = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh = NULL;\n\tunsigned oldflags;\n\tint status;\n\n\tinode_lock(inode);\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto bail_unlock;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\tflags &= ~OCFS2_DIRSYNC_FL;\n\n\toldflags = ocfs2_inode->ip_attr;\n\tflags = flags & mask;\n\tflags |= oldflags & ~mask;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tstatus = -EPERM;\n\tif ((oldflags & OCFS2_IMMUTABLE_FL) || ((flags ^ oldflags) &\n\t\t(OCFS2_APPEND_FL | OCFS2_IMMUTABLE_FL))) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\tgoto bail_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tocfs2_inode->ip_attr = flags;\n\tocfs2_set_inode_flags(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock:\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tinode_unlock(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1137-1144",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2589-2603",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.c",
          "lines": "1303-1342",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"filecheck.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/iversion.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_filecheck_validate_inode_block(struct super_block *sb,\n\t\t\t\t\t\tstruct buffer_head *bh);",
            "static int ocfs2_filecheck_repair_inode_block(struct super_block *sb,\n\t\t\t\t\t      struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"filecheck.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/iversion.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_filecheck_validate_inode_block(struct super_block *sb,\n\t\t\t\t\t\tstruct buffer_head *bh);\nstatic int ocfs2_filecheck_repair_inode_block(struct super_block *sb,\n\t\t\t\t\t      struct buffer_head *bh);\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.c",
          "lines": "87-105",
          "snippet": "void ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"filecheck.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/iversion.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"filecheck.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/iversion.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = OCFS2_I(inode)->ip_attr;\n\n\tinode->i_flags &= ~(S_IMMUTABLE |\n\t\tS_SYNC | S_APPEND | S_NOATIME | S_DIRSYNC);\n\n\tif (flags & OCFS2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\n\tif (flags & OCFS2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & OCFS2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & OCFS2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & OCFS2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\\n\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&bh",
            "1"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_drop_inode_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "3520-3549",
          "snippet": "int ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_drop_inode_locks(struct inode *inode)\n{\n\tint status, err;\n\n\t/* No need to call ocfs2_mark_lockres_freeing here -\n\t * ocfs2_clear_inode has done it for us. */\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_open_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\n\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_inode_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\terr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\n\t\t\t      &OCFS2_I(inode)->ip_rw_lockres);\n\tif (err < 0)\n\t\tmlog_errno(err);\n\tif (err < 0 && !status)\n\t\tstatus = err;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_set_inode_attr(struct inode *inode, unsigned flags,\n\t\t\t\tunsigned mask)\n{\n\tstruct ocfs2_inode_info *ocfs2_inode = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tstruct buffer_head *bh = NULL;\n\tunsigned oldflags;\n\tint status;\n\n\tinode_lock(inode);\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = -EACCES;\n\tif (!inode_owner_or_capable(inode))\n\t\tgoto bail_unlock;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\tflags &= ~OCFS2_DIRSYNC_FL;\n\n\toldflags = ocfs2_inode->ip_attr;\n\tflags = flags & mask;\n\tflags |= oldflags & ~mask;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tstatus = -EPERM;\n\tif ((oldflags & OCFS2_IMMUTABLE_FL) || ((flags ^ oldflags) &\n\t\t(OCFS2_APPEND_FL | OCFS2_IMMUTABLE_FL))) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\tgoto bail_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock;\n\t}\n\n\tocfs2_inode->ip_attr = flags;\n\tocfs2_set_inode_flags(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock:\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tinode_unlock(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_inode_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "64-78",
    "snippet": "static int ocfs2_get_inode_attr(struct inode *inode, unsigned *flags)\n{\n\tint status;\n\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\t*flags = OCFS2_I(inode)->ip_attr;\n\tocfs2_inode_unlock(inode, 0);\n\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlmglue.c",
          "lines": "2589-2603",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sched/signal.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(osb) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_inode_flags",
          "args": [
            "OCFS2_I(inode)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/inode.c",
          "lines": "108-124",
          "snippet": "void ocfs2_get_inode_flags(struct ocfs2_inode_info *oi)\n{\n\tunsigned int flags = oi->vfs_inode.i_flags;\n\n\toi->ip_attr &= ~(OCFS2_SYNC_FL|OCFS2_APPEND_FL|\n\t\t\tOCFS2_IMMUTABLE_FL|OCFS2_NOATIME_FL|OCFS2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\toi->ip_attr |= OCFS2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\toi->ip_attr |= OCFS2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\toi->ip_attr |= OCFS2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\toi->ip_attr |= OCFS2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\toi->ip_attr |= OCFS2_DIRSYNC_FL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"filecheck.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/iversion.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"filecheck.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/iversion.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_get_inode_flags(struct ocfs2_inode_info *oi)\n{\n\tunsigned int flags = oi->vfs_inode.i_flags;\n\n\toi->ip_attr &= ~(OCFS2_SYNC_FL|OCFS2_APPEND_FL|\n\t\t\tOCFS2_IMMUTABLE_FL|OCFS2_NOATIME_FL|OCFS2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\toi->ip_attr |= OCFS2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\toi->ip_attr |= OCFS2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\toi->ip_attr |= OCFS2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\toi->ip_attr |= OCFS2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\toi->ip_attr |= OCFS2_DIRSYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_get_inode_attr(struct inode *inode, unsigned *flags)\n{\n\tint status;\n\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\t*flags = OCFS2_I(inode)->ip_attr;\n\tocfs2_inode_unlock(inode, 0);\n\n\treturn status;\n}"
  },
  {
    "function_name": "o2info_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "59-62",
    "snippet": "static inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline int o2info_coherent(struct ocfs2_info_request *req)\n{\n\treturn (!(req->ir_flags & OCFS2_INFO_FL_NON_COHERENT));\n}"
  },
  {
    "function_name": "o2info_clear_request_filled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "54-57",
    "snippet": "static inline void o2info_clear_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags &= ~OCFS2_INFO_FL_FILLED;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_clear_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags &= ~OCFS2_INFO_FL_FILLED;\n}"
  },
  {
    "function_name": "o2info_set_request_filled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "49-52",
    "snippet": "static inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_filled(struct ocfs2_info_request *req)\n{\n\treq->ir_flags |= OCFS2_INFO_FL_FILLED;\n}"
  },
  {
    "function_name": "o2info_set_request_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ioctl.c",
    "lines": "42-47",
    "snippet": "static inline void o2info_set_request_error(struct ocfs2_info_request *kreq,\n\t\t\t\t\tstruct ocfs2_info_request __user *req)\n{\n\tkreq->ir_flags |= OCFS2_INFO_FL_ERROR;\n\t(void)put_user(kreq->ir_flags, (__u32 __user *)&(req->ir_flags));\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"resize.h\"",
      "#include \"ioctl.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "kreq->ir_flags",
            "(__u32 __user *)&(req->ir_flags)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic inline void o2info_set_request_error(struct ocfs2_info_request *kreq,\n\t\t\t\t\tstruct ocfs2_info_request __user *req)\n{\n\tkreq->ir_flags |= OCFS2_INFO_FL_ERROR;\n\t(void)put_user(kreq->ir_flags, (__u32 __user *)&(req->ir_flags));\n}"
  }
]