[
  {
    "function_name": "exit_elf_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2420-2424",
    "snippet": "static void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_binfmt",
          "args": [
            "&elf_format"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}"
  },
  {
    "function_name": "init_elf_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2414-2418",
    "snippet": "static int __init init_elf_binfmt(void)\n{\n\tregister_binfmt(&elf_format);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_binfmt",
          "args": [
            "&elf_format"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic int __init init_elf_binfmt(void)\n{\n\tregister_binfmt(&elf_format);\n\treturn 0;\n}"
  },
  {
    "function_name": "elf_core_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2212-2410",
    "snippet": "static int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs, i;\n\tsize_t vma_data_size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff;\n\tstruct elf_note_info info = { };\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\telf_addr_t *vma_filesz = NULL;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto out;\n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(elf, e_phnum, &info, cprm->siginfo, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\tif (segs - 1 > ULONG_MAX / sizeof(*vma_filesz))\n\t\tgoto end_coredump;\n\tvma_filesz = kvmalloc(array_size(sizeof(*vma_filesz), (segs - 1)),\n\t\t\t      GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(vma_filesz))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long dump_size;\n\n\t\tdump_size = vma_dump_size(vma, cprm->mm_flags);\n\t\tvma_filesz[i++] = dump_size;\n\t\tvma_data_size += dump_size;\n\t}\n\n\toffset += vma_data_size;\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_filesz[i++];\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_skip(cprm, dataoff - cprm->pos))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_filesz[i++];\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = !dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_skip(cprm, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\tdump_truncate(cprm);\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkvfree(vma_filesz);\n\tkfree(phdr4note);\n\tkfree(elf);\nout:\n\treturn has_dumped;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define elf_core_dump\tNULL"
    ],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "vma_filesz"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_note_info",
          "args": [
            "&info"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "free_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2140-2159",
          "snippet": "static void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tkvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tkvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "shdr4extnum",
            "sizeof(*shdr4extnum)"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "dump_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "783-802",
          "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_write_extra_data",
          "args": [
            "cprm"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_truncate",
          "args": [
            "cprm"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "dump_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "840-850",
          "snippet": "void dump_truncate(struct coredump_params *cprm)\n{\n\tstruct file *file = cprm->file;\n\tloff_t offset;\n\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\toffset = file->f_op->llseek(file, 0, SEEK_CUR);\n\t\tif (i_size_read(file->f_mapping->host) < offset)\n\t\t\tdo_truncate(file->f_path.dentry, offset, 0, file);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid dump_truncate(struct coredump_params *cprm)\n{\n\tstruct file *file = cprm->file;\n\tloff_t offset;\n\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\toffset = file->f_op->llseek(file, 0, SEEK_CUR);\n\t\tif (i_size_read(file->f_mapping->host) < offset)\n\t\t\tdo_truncate(file->f_path.dentry, offset, 0, file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_skip",
          "args": [
            "cprm",
            "PAGE_SIZE"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "dump_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "805-823",
          "snippet": "int dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dump_page",
          "args": [
            "addr"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_vma",
          "args": [
            "vma",
            "gate_vma"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "next_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2176-2187",
          "snippet": "static struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_vma",
          "args": [
            "current",
            "gate_vma"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "first_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2163-2171",
          "snippet": "static struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_coredump_extra_notes_write",
          "args": [
            "cprm"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_note_info",
          "args": [
            "&info",
            "cprm"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "write_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2117-2138",
          "snippet": "static int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_write_extra_phdrs",
          "args": [
            "cprm",
            "offset"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_extnum_info",
          "args": [
            "elf",
            "shdr4extnum",
            "e_shoff",
            "segs"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "fill_extnum_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2189-2203",
          "snippet": "static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*shdr4extnum)",
            "GFP_KERNEL"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_extra_data_size",
          "args": [],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_dump_size",
          "args": [
            "vma",
            "cprm->mm_flags"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "vma_dump_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1320-1411",
          "snippet": "static unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(DAX_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(DAX_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define elf_core_dump\tNULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define elf_core_dump\tNULL\n\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(DAX_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(DAX_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "vma_filesz"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "array_size(sizeof(*vma_filesz), (segs - 1))",
            "GFP_KERNEL"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "183-191",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "sizeof(*vma_filesz)",
            "(segs - 1)"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "offset",
            "ELF_EXEC_PAGESIZE"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_linux.h",
          "lines": "210-215",
          "snippet": "static inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/rhashtable.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/uuid.h>\n#include <linux/types.h>\n\nstatic inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_elf_note_phdr",
          "args": [
            "phdr4note",
            "sz",
            "offset"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_note_phdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1468-1479",
          "snippet": "static void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_coredump_extra_notes_size",
          "args": [],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_note_info_size",
          "args": [
            "&info"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "get_note_info_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2104-2115",
          "snippet": "static size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_note_info",
          "args": [
            "elf",
            "e_phnum",
            "&info",
            "cprm->siginfo",
            "cprm->regs"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "current->mm"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_extra_phdrs",
          "args": [],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define elf_core_dump\tNULL\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs, i;\n\tsize_t vma_data_size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff;\n\tstruct elf_note_info info = { };\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\telf_addr_t *vma_filesz = NULL;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto out;\n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(elf, e_phnum, &info, cprm->siginfo, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\tif (segs - 1 > ULONG_MAX / sizeof(*vma_filesz))\n\t\tgoto end_coredump;\n\tvma_filesz = kvmalloc(array_size(sizeof(*vma_filesz), (segs - 1)),\n\t\t\t      GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(vma_filesz))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long dump_size;\n\n\t\tdump_size = vma_dump_size(vma, cprm->mm_flags);\n\t\tvma_filesz[i++] = dump_size;\n\t\tvma_data_size += dump_size;\n\t}\n\n\toffset += vma_data_size;\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_filesz[i++];\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_skip(cprm, dataoff - cprm->pos))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_filesz[i++];\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = !dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_skip(cprm, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\tdump_truncate(cprm);\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkvfree(vma_filesz);\n\tkfree(phdr4note);\n\tkfree(elf);\nout:\n\treturn has_dumped;\n}"
  },
  {
    "function_name": "fill_extnum_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2189-2203",
    "snippet": "static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "shdr4extnum",
            "0",
            "sizeof(*shdr4extnum)"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}"
  },
  {
    "function_name": "next_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2176-2187",
    "snippet": "static struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}"
  },
  {
    "function_name": "first_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2163-2171",
    "snippet": "static struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}"
  },
  {
    "function_name": "free_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2140-2159",
    "snippet": "static void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tkvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->xfpu"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "info->notes_files->data"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "tmp"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&info->thread_list"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tkvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}"
  },
  {
    "function_name": "write_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2117-2138",
    "snippet": "static int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writenote",
          "args": [
            "&tmp->notes[i]",
            "cprm"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "writenote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1433-1443",
          "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "t",
            "structelf_thread_status",
            "list"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "t",
            "&info->thread_list"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_note_info_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2104-2115",
    "snippet": "static size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "info->notes + i"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1422-1431",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}"
  },
  {
    "function_name": "fill_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2032-2102",
    "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_CORE_EFLAGS\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "info->notes + info->numnote++",
            "\"LINUX\"",
            "ELF_CORE_XFPREG_TYPE",
            "sizeof(*info->xfpu)",
            "info->xfpu"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_xfpregs",
          "args": [
            "current",
            "info->xfpu"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_fpregs",
          "args": [
            "current",
            "regs",
            "info->fpu"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_files_note",
          "args": [
            "info->notes + info->numnote"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "fill_files_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1604-1679",
          "snippet": "static int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAX_FILE_NOTE_SIZE (4*1024*1024)",
            "#define user_long_t long"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n#define user_long_t long\n\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_auxv_note",
          "args": [
            "info->notes + 3",
            "current->mm"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "fill_auxv_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1572-1580",
          "snippet": "static void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_siginfo_note",
          "args": [
            "info->notes + 2",
            "&info->csigdata",
            "siginfo"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "fill_siginfo_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1582-1590",
          "snippet": "static void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define user_siginfo_t siginfo_t"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define user_siginfo_t siginfo_t\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_psinfo",
          "args": [
            "info->psinfo",
            "current->group_leader",
            "current->mm"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "fill_psinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1529-1570",
          "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_elf_header",
          "args": [
            "elf",
            "phdrs",
            "ELF_ARCH",
            "ELF_CORE_EFLAGS"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1445-1466",
          "snippet": "static void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_regs",
          "args": [
            "&info->prstatus->pr_reg",
            "regs"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "info->prstatus",
            "current",
            "siginfo->si_signo"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1495-1527",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info->prstatus",
            "0",
            "sizeof(*info->prstatus)"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_dump_thread_status",
          "args": [
            "siginfo->si_signo",
            "ets"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "elf_dump_thread_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1958-1989",
          "snippet": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "t",
            "structelf_thread_status",
            "list"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "t",
            "&info->thread_list"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ets->list",
            "&info->thread_list"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ets)",
            "GFP_KERNEL"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_note_info_init",
          "args": [
            "info"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "elf_note_info_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2006-2030",
          "snippet": "static int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc_array(8, sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc_array(8, sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
  },
  {
    "function_name": "elf_note_info_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "2006-2030",
    "snippet": "static int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc_array(8, sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*info->xfpu)",
            "GFP_KERNEL"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "8",
            "sizeof(struct memelfnote)",
            "GFP_KERNEL"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&info->thread_list"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc_array(8, sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "elf_dump_thread_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1958-1989",
    "snippet": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "&t->notes[2]"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1422-1431",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "&t->notes[2]",
            "\"LINUX\"",
            "ELF_CORE_XFPREG_TYPE",
            "sizeof(t->xfpu)",
            "&t->xfpu"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_xfpregs",
          "args": [
            "p",
            "&t->xfpu"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_fpregs",
          "args": [
            "p",
            "NULL",
            "&t->fpu"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_regs",
          "args": [
            "p",
            "&t->prstatus.pr_reg"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "&t->prstatus",
            "p",
            "signr"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1495-1527",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}"
  },
  {
    "function_name": "free_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1921-1935",
    "snippet": "static void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tkvfree(info->files.data);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "info->files.data"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->psinfo.data"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "t->notes[0].data && t->notes[0].data != &t->prstatus"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tkvfree(info->files.data);\n}"
  },
  {
    "function_name": "write_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1887-1919",
    "snippet": "static int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tbool first = true;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], cprm))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->signote, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, cprm))\n\t\t\treturn 0;\n\t\tif (first && info->files.data &&\n\t\t\t\t!writenote(&info->files, cprm))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], cprm))\n\t\t\t\treturn 0;\n\n\t\tfirst = false;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writenote",
          "args": [
            "&t->notes[i]",
            "cprm"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "writenote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1433-1443",
          "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tbool first = true;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], cprm))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->signote, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, cprm))\n\t\t\treturn 0;\n\t\tif (first && info->files.data &&\n\t\t\t\t!writenote(&info->files, cprm))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], cprm))\n\t\t\t\treturn 0;\n\n\t\tfirst = false;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_note_info_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1878-1881",
    "snippet": "static size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}"
  },
  {
    "function_name": "fill_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1783-1876",
    "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL) {\n\t\tinfo->psinfo.data = NULL; /* So we don't free this wrongly */\n\t\treturn 0;\n\t}\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, siginfo->si_signo, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_siginfo_note(&info->signote, &info->csigdata, siginfo);\n\tinfo->size += notesize(&info->signote);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\tif (fill_files_note(&info->files) == 0)\n\t\tinfo->size += notesize(&info->files);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "&info->files"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1422-1431",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_files_note",
          "args": [
            "&info->files"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "fill_files_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1604-1679",
          "snippet": "static int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAX_FILE_NOTE_SIZE (4*1024*1024)",
            "#define user_long_t long"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n#define user_long_t long\n\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_auxv_note",
          "args": [
            "&info->auxv",
            "current->mm"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "fill_auxv_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1572-1580",
          "snippet": "static void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_siginfo_note",
          "args": [
            "&info->signote",
            "&info->csigdata",
            "siginfo"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "fill_siginfo_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1582-1590",
          "snippet": "static void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define user_siginfo_t siginfo_t"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define user_siginfo_t siginfo_t\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_psinfo",
          "args": [
            "psinfo",
            "dump_task->group_leader",
            "dump_task->mm"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "fill_psinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1529-1570",
          "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_thread_core_info",
          "args": [
            "t",
            "view",
            "siginfo->si_signo",
            "&info->size"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "fill_thread_core_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1722-1781",
          "snippet": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tunsigned int regset0_size = regset_size(t->task, &view->regsets[0]);\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset) > 0)) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset_size(t->task, regset);\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus,\n\t\t\t\t\t\t\t1, regset0_size);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tunsigned int regset0_size = regset_size(t->task, &view->regsets[0]);\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset) > 0)) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset_size(t->task, regset);\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus,\n\t\t\t\t\t\t\t1, regset0_size);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!t"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_elf_header",
          "args": [
            "elf",
            "phdrs",
            "view->e_machine",
            "view->e_flags"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1445-1466",
          "snippet": "static void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "view->regsets[0].core_note_type != NT_PRSTATUS"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "info->thread_notes == 0"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "&info->psinfo",
            "\"CORE\"",
            "NT_PRPSINFO",
            "sizeof(*psinfo)",
            "psinfo"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*psinfo)",
            "GFP_KERNEL"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_user_regset_view",
          "args": [
            "dump_task"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL) {\n\t\tinfo->psinfo.data = NULL; /* So we don't free this wrongly */\n\t\treturn 0;\n\t}\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, siginfo->si_signo, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_siginfo_note(&info->signote, &info->csigdata, siginfo);\n\tinfo->size += notesize(&info->signote);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\tif (fill_files_note(&info->files) == 0)\n\t\tinfo->size += notesize(&info->files);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "fill_thread_core_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1722-1781",
    "snippet": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tunsigned int regset0_size = regset_size(t->task, &view->regsets[0]);\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset) > 0)) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset_size(t->task, regset);\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus,\n\t\t\t\t\t\t\t1, regset0_size);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "&t->notes[i]"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1422-1431",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "&t->notes[i]",
            "\"CORE\"",
            "NT_PRFPREG",
            "size",
            "data"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_PR_FPVALID",
          "args": [
            "&t->prstatus",
            "1",
            "regset0_size"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regset->get",
          "args": [
            "t->task",
            "regset",
            "0",
            "size",
            "data",
            "NULL"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regset_size",
          "args": [
            "t->task",
            "regset"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regset->active",
          "args": [
            "t->task",
            "regset"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_thread_regset_writeback",
          "args": [
            "t->task",
            "regset"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "do_thread_regset_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1707-1712",
          "snippet": "static void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRSTATUS_SIZE",
          "args": [
            "t->prstatus",
            "regset0_size"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "view->regsets[0].get",
          "args": [
            "t->task",
            "&view->regsets[0]",
            "0",
            "regset0_size",
            "&t->prstatus.pr_reg",
            "NULL"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "&t->prstatus",
            "t->task",
            "signr"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1495-1527",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regset_size",
          "args": [
            "t->task",
            "&view->regsets[0]"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tunsigned int regset0_size = regset_size(t->task, &view->regsets[0]);\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset) > 0)) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset_size(t->task, regset);\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus,\n\t\t\t\t\t\t\t1, regset0_size);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "do_thread_regset_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1707-1712",
    "snippet": "static void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regset->writeback",
          "args": [
            "task",
            "regset",
            "1"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}"
  },
  {
    "function_name": "fill_files_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1604-1679",
    "snippet": "static int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAX_FILE_NOTE_SIZE (4*1024*1024)",
      "#define user_long_t long"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "note",
            "\"CORE\"",
            "NT_FILE",
            "size",
            "data"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "name_base - shift_bytes",
            "name_base",
            "name_curpos - name_base"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "name_curpos",
            "filename",
            "n"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "data"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filename"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filename"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_path",
          "args": [
            "file",
            "name_curpos",
            "remaining"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "seq_file_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "480-483",
          "snippet": "int seq_file_path(struct seq_file *m, struct file *file, const char *esc)\n{\n\treturn seq_path(m, &file->f_path, esc);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_file_path(struct seq_file *m, struct file *file, const char *esc)\n{\n\treturn seq_path(m, &file->f_path, esc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "data"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "183-191",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_round_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fuse/file.c",
          "lines": "2849-2852",
          "snippet": "static inline loff_t fuse_round_up(struct fuse_conn *fc, loff_t off)\n{\n\treturn round_up(off, fc->max_pages << PAGE_SHIFT);\n}",
          "includes": [
            "#include <linux/uio.h>",
            "#include <linux/falloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uio.h>\n#include <linux/falloc.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline loff_t fuse_round_up(struct fuse_conn *fc, loff_t off)\n{\n\treturn round_up(off, fc->max_pages << PAGE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n#define user_long_t long\n\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_siginfo_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1582-1590",
    "snippet": "static void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define user_siginfo_t siginfo_t"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "note",
            "\"CORE\"",
            "NT_SIGINFO",
            "sizeof(*csigdata)",
            "csigdata"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define user_siginfo_t siginfo_t\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}"
  },
  {
    "function_name": "fill_auxv_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1572-1580",
    "snippet": "static void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "note",
            "\"CORE\"",
            "NT_AUXV",
            "i * sizeof(elf_addr_t)",
            "auxv"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "2032-2102",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}"
  },
  {
    "function_name": "fill_psinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1529-1570",
    "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "psinfo->pr_fname",
            "p->comm",
            "sizeof(psinfo->pr_fname)"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_GID",
          "args": [
            "psinfo->pr_gid",
            "from_kgid_munged(cred->user_ns, cred->gid)"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->gid"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_UID",
          "args": [
            "psinfo->pr_uid",
            "from_kuid_munged(cred->user_ns, cred->uid)"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->uid"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~p->state"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session_vnr",
          "args": [
            "p"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_vnr",
          "args": [
            "p"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "rcu_dereference(p->real_parent)"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "p->real_parent"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&psinfo->pr_psargs",
            "(const char __user *)mm->arg_start",
            "len"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "psinfo",
            "0",
            "sizeof(struct elf_prpsinfo)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_prstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1495-1527",
    "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "p->signal->cstime"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "p->signal->cutime"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "stime"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "utime"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&utime",
            "&stime"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "cputime.stime"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "cputime.utime"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session_vnr",
          "args": [
            "p"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_vnr",
          "args": [
            "p"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "rcu_dereference(p->real_parent)"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "p->real_parent"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_timeval(p->signal->cstime);\n}"
  },
  {
    "function_name": "fill_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1481-1489",
    "snippet": "static void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}"
  },
  {
    "function_name": "fill_elf_note_phdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1468-1479",
    "snippet": "static void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}"
  },
  {
    "function_name": "fill_elf_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1445-1466",
    "snippet": "static void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "elf->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elf",
            "0",
            "sizeof(*elf)"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}"
  },
  {
    "function_name": "writenote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1433-1443",
    "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_align",
          "args": [
            "cprm",
            "4"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "dump_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "826-832",
          "snippet": "int dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->pos & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->pos & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "men->data",
            "men->datasz"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "dump_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "783-802",
          "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "men->name"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
  },
  {
    "function_name": "notesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1422-1431",
    "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "en->datasz",
            "4"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_linux.h",
          "lines": "210-215",
          "snippet": "static inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/rhashtable.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/uuid.h>\n#include <linux/types.h>\n\nstatic inline uint64_t roundup_64(uint64_t x, uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "en->name"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
  },
  {
    "function_name": "vma_dump_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1320-1411",
    "snippet": "static unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(DAX_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(DAX_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define elf_core_dump\tNULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reset_fsync_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/node.c",
          "lines": "344-351",
          "snippet": "void f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_reset_fsync_node_info(struct f2fs_sb_info *sbi)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sbi->fsync_node_lock, flags);\n\tsbi->fsync_seg_id = 0;\n\tspin_unlock_irqrestore(&sbi->fsync_node_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "get_user(word, header)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "word",
            "header"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "SELFMAG != sizeof word"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/volumes.c",
          "lines": "234-237",
          "snippet": "struct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/uuid.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/list_sort.h>\n#include <linux/uuid.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct list_head *btrfs_get_fs_uuids(void)\n{\n\treturn &fs_uuids;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "ELF_HEADERS"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "MAPPED_PRIVATE"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "ANON_PRIVATE"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "MAPPED_SHARED"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "ANON_SHARED"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "HUGETLB_PRIVATE"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "HUGETLB_SHARED"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "DAX_PRIVATE"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "DAX_SHARED"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "always_dump_vma",
          "args": [
            "vma"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "always_dump_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "1294-1315",
          "snippet": "static bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define elf_core_dump\tNULL\n\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(DAX_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(DAX_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}"
  },
  {
    "function_name": "always_dump_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1294-1315",
    "snippet": "static bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_vma_name",
          "args": [
            "vma"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->name",
          "args": [
            "vma"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "vma->vm_mm"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "load_elf_library",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "1194-1275",
    "snippet": "static int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\tloff_t pos = 0;\n\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, &elf_ex, sizeof(elf_ex), &pos);\n\tif (retval != sizeof(elf_ex))\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op->mmap)\n\t\tgoto out;\n\tif (elf_check_fdpic(&elf_ex))\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tpos =  elf_ex.e_phoff;\n\tretval = kernel_read(file, eppnt, j, &pos);\n\tif (retval != j)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED_NOREPLACE | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGEALIGN(eppnt->p_filesz + eppnt->p_vaddr);\n\tbss = ELF_PAGEALIGN(eppnt->p_memsz + eppnt->p_vaddr);\n\tif (bss > len) {\n\t\terror = vm_brk(len, bss - len);\n\t\tif (error)\n\t\t\tgoto out_free_ph;\n\t}\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE",
      "#define load_elf_library NULL"
    ],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_phdata"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "len",
            "bss - len"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "eppnt->p_memsz + eppnt->p_vaddr"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "eppnt->p_filesz + eppnt->p_vaddr"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padzero",
          "args": [
            "elf_bss"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "padzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "127-138",
          "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "file",
            "ELF_PAGESTART(eppnt->p_vaddr)",
            "(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr))",
            "PROT_READ | PROT_WRITE | PROT_EXEC",
            "MAP_FIXED_NOREPLACE | MAP_PRIVATE | MAP_DENYWRITE",
            "(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr))"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "eppnt",
            "j",
            "&pos"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "j",
            "GFP_KERNEL"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_fdpic",
          "args": [
            "&elf_ex"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&elf_ex"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "elf_ex.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n#define load_elf_library NULL\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\tloff_t pos = 0;\n\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, &elf_ex, sizeof(elf_ex), &pos);\n\tif (retval != sizeof(elf_ex))\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op->mmap)\n\t\tgoto out;\n\tif (elf_check_fdpic(&elf_ex))\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tpos =  elf_ex.e_phoff;\n\tretval = kernel_read(file, eppnt, j, &pos);\n\tif (retval != j)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED_NOREPLACE | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGEALIGN(eppnt->p_filesz + eppnt->p_vaddr);\n\tbss = ELF_PAGEALIGN(eppnt->p_memsz + eppnt->p_vaddr);\n\tif (bss > len) {\n\t\terror = vm_brk(len, bss - len);\n\t\tif (error)\n\t\t\tgoto out_free_ph;\n\t}\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "load_elf_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "690-1189",
    "snippet": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint bss_prot = 0;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\tloff_t pos;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (elf_check_fdpic(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tpos = elf_ppnt->p_offset;\n\t\t\tretval = kernel_read(bprm->file, elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz, &pos);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\t/* Get the exec headers */\n\t\t\tpos = 0;\n\t\t\tretval = kernel_read(interpreter, &loc->interp_elf_ex,\n\t\t\t\t\t     sizeof(loc->interp_elf_ex), &pos);\n\t\t\tif (retval != sizeof(loc->interp_elf_ex)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex) ||\n\t\t    elf_check_fdpic(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex,\n\t\t\t\t!!interpreter, &loc->interp_elf_ex,\n\t\t\t\t&arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\tinstall_exec_creds(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags, elf_fixed = MAP_FIXED_NOREPLACE;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias,\n\t\t\t\t\t bss_prot);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Some binaries have overlapping elf segments and then\n\t\t\t * we have to forcefully map over an existing mapping\n\t\t\t * e.g. over this newly established brk mapping.\n\t\t\t */\n\t\t\telf_fixed = MAP_FIXED;\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\t/*\n\t\t * If we are loading ET_EXEC or we have already performed\n\t\t * the ET_DYN load_addr calculations, proceed normally.\n\t\t */\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= elf_fixed;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/*\n\t\t\t * This logic is run once for the first LOAD Program\n\t\t\t * Header for ET_DYN binaries to calculate the\n\t\t\t * randomization (load_bias) for all the LOAD\n\t\t\t * Program Headers, and to calculate the entire\n\t\t\t * size of the ELF mapping (total_size). (Note that\n\t\t\t * load_addr_set is set to true later once the\n\t\t\t * initial mapping is performed.)\n\t\t\t *\n\t\t\t * There are effectively two types of ET_DYN\n\t\t\t * binaries: programs (i.e. PIE: ET_DYN with INTERP)\n\t\t\t * and loaders (ET_DYN without INTERP, since they\n\t\t\t * _are_ the ELF interpreter). The loaders must\n\t\t\t * be loaded away from programs since the program\n\t\t\t * may otherwise collide with the loader (especially\n\t\t\t * for ET_EXEC which does not have a randomized\n\t\t\t * position). For example to handle invocations of\n\t\t\t * \"./ld.so someprog\" to test out a new version of\n\t\t\t * the loader, the subsequent program that the\n\t\t\t * loader loads must avoid the loader itself, so\n\t\t\t * they cannot share the same load range. Sufficient\n\t\t\t * room for the brk must be allocated with the\n\t\t\t * loader as well, since brk must be available with\n\t\t\t * the loader.\n\t\t\t *\n\t\t\t * Therefore, programs are loaded offset from\n\t\t\t * ELF_ET_DYN_BASE and loaders are loaded into the\n\t\t\t * independently randomized mmap region (0 load_bias\n\t\t\t * without MAP_FIXED).\n\t\t\t */\n\t\t\tif (elf_interpreter) {\n\t\t\t\tload_bias = ELF_ET_DYN_BASE;\n\t\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\t\tload_bias += arch_mmap_rnd();\n\t\t\t\telf_flags |= elf_fixed;\n\t\t\t} else\n\t\t\t\tload_bias = 0;\n\n\t\t\t/*\n\t\t\t * Since load_bias is used for all subsequent loading\n\t\t\t * calculations, we must lower it by the first vaddr\n\t\t\t * so that the remaining calculations based on the\n\t\t\t * ELF vaddrs will be correctly offset. The result\n\t\t\t * is then page aligned.\n\t\t\t */\n\t\t\tload_bias = ELF_PAGESTART(load_bias - vaddr);\n\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\tloc->elf_ex.e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk) {\n\t\t\tbss_prot = elf_prot;\n\t\t\telf_brk = k;\n\t\t}\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk, bss_prot);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef compat_brk_randomized\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tfinalize_exec(bprm);\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define INIT_ARCH_ELF_STATE {}",
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
    ],
    "globals_used": [
      "static int load_elf_binary(struct linux_binprm *bprm);",
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);",
      "static struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_phdata"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "interpreter"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "interpreter"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_thread",
          "args": [
            "regs",
            "elf_entry",
            "bprm->p"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalize_exec",
          "args": [
            "bprm"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "finalize_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1388-1394",
          "snippet": "void finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ELF_PLAT_INIT",
          "args": [
            "regs",
            "reloc_func_desc"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "0",
            "PAGE_SIZE",
            "PROT_READ | PROT_EXEC",
            "MAP_FIXED | MAP_PRIVATE",
            "0"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_randomize_brk",
          "args": [
            "current->mm"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_elf_tables",
          "args": [
            "bprm",
            "&loc->elf_ex",
            "load_addr",
            "interp_load_addr"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "create_elf_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "164-345",
          "snippet": "static int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE, bprm->secureexec);\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\n\t/* Populate list of argv pointers back to argv strings. */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = p;\n\n\t/* Populate list of envp pointers back to envp strings. */\n\tcurrent->mm->env_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_BASE_PLATFORM NULL"
          ],
          "globals_used": [
            "static int load_elf_binary(struct linux_binprm *bprm);",
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_BASE_PLATFORM NULL\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE, bprm->secureexec);\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\n\t/* Populate list of argv pointers back to argv strings. */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = p;\n\n\t/* Populate list of envp pointers back to envp strings. */\n\tcurrent->mm->env_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_setup_additional_pages",
          "args": [
            "bprm",
            "!!elf_interpreter"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_binfmt",
          "args": [
            "&elf_format"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "set_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1931-1941",
          "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "elf_entry"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "interpreter"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)elf_entry"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "elf_entry"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)elf_entry"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_elf_interp",
          "args": [
            "&loc->interp_elf_ex",
            "interpreter",
            "&interp_map_addr",
            "load_bias",
            "interp_elf_phdata"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "load_elf_interp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "537-663",
          "snippet": "static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tint bss_prot = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex) ||\n\t    elf_check_fdpic(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED_NOREPLACE;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_memsz;\n\t\t\tif (k > last_bss) {\n\t\t\t\tlast_bss = k;\n\t\t\t\tbss_prot = elf_prot;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now fill out the bss section: first pad the last page from\n\t * the file up to the page boundary, and zero it from elf_bss\n\t * up to the end of the page.\n\t */\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\t/*\n\t * Next, align both the file and mem bss up to the page size,\n\t * since this is where elf_bss was just zeroed up to, and where\n\t * last_bss will end after the vm_brk_flags() below.\n\t */\n\telf_bss = ELF_PAGEALIGN(elf_bss);\n\tlast_bss = ELF_PAGEALIGN(last_bss);\n\t/* Finally, if there is still more bss to allocate, do it. */\n\tif (last_bss > elf_bss) {\n\t\terror = vm_brk_flags(elf_bss, last_bss - elf_bss,\n\t\t\t\tbss_prot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tint bss_prot = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex) ||\n\t    elf_check_fdpic(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED_NOREPLACE;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_memsz;\n\t\t\tif (k > last_bss) {\n\t\t\t\tlast_bss = k;\n\t\t\t\tbss_prot = elf_prot;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now fill out the bss section: first pad the last page from\n\t * the file up to the page boundary, and zero it from elf_bss\n\t * up to the end of the page.\n\t */\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\t/*\n\t * Next, align both the file and mem bss up to the page size,\n\t * since this is where elf_bss was just zeroed up to, and where\n\t * last_bss will end after the vm_brk_flags() below.\n\t */\n\telf_bss = ELF_PAGEALIGN(elf_bss);\n\tlast_bss = ELF_PAGEALIGN(last_bss);\n\t/* Finally, if there is still more bss to allocate, do it. */\n\tif (last_bss > elf_bss) {\n\t\terror = vm_brk_flags(elf_bss, last_bss - elf_bss,\n\t\t\t\tbss_prot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "padzero(elf_bss)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padzero",
          "args": [
            "elf_bss"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "padzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "127-138",
          "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "elf_bss != elf_brk"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_brk",
          "args": [
            "elf_bss",
            "elf_brk",
            "bss_prot"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "set_brk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "103-120",
          "snippet": "static int set_brk(unsigned long start, unsigned long end, int prot)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\t/*\n\t\t * Map the last of the bss segment.\n\t\t * If the header is requesting these pages to be\n\t\t * executable, honour that (ppc32 needs this).\n\t\t */\n\t\tint error = vm_brk_flags(start, end - start,\n\t\t\t\tprot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int set_brk(unsigned long start, unsigned long end, int prot)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\t/*\n\t\t * Map the last of the bss segment.\n\t\t * If the header is requesting these pages to be\n\t\t * executable, honour that (ppc32 needs this).\n\t\t */\n\t\tint error = vm_brk_flags(start, end - start,\n\t\t\t\tprot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "k"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "load_bias + vaddr"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "(void*)error"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)error"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "error"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_map",
          "args": [
            "bprm->file",
            "load_bias + vaddr",
            "elf_ppnt",
            "elf_prot",
            "elf_flags",
            "total_size"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "elf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "349-386",
          "snippet": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "total_mapping_size",
          "args": [
            "elf_phdata",
            "loc->elf_ex.e_phnum"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "total_mapping_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "390-406",
          "snippet": "static unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "load_bias - vaddr"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_mmap_rnd",
          "args": [],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias",
            "nbyte"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "elf_bss"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "elf_brk > elf_bss"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_arg_pages",
          "args": [
            "bprm",
            "randomize_stack_top(STACK_TOP)",
            "executable_stack"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "setup_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "688-798",
          "snippet": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "randomize_stack_top",
          "args": [
            "STACK_TOP"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "randomize_stack_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "674-688",
          "snippet": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif (current->flags & PF_RANDOMIZE) {\n\t\trandom_variable = get_random_long();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */\n\nstatic unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif (current->flags & PF_RANDOMIZE) {\n\t\trandom_variable = get_random_long();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_exec_creds",
          "args": [
            "bprm"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "install_exec_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1448-1470",
          "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_new_exec",
          "args": [
            "bprm"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1330-1384",
          "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int suid_dumpable = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_read_implies_exec",
          "args": [
            "loc->elf_ex",
            "executable_stack"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERSONALITY2",
          "args": [
            "loc->elf_ex",
            "&arch_state"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_old_exec",
          "args": [
            "bprm"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "flush_old_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1254-1306",
          "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_elf",
          "args": [
            "&loc->elf_ex",
            "!!interpreter",
            "&loc->interp_elf_ex",
            "&arch_state"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "arch_check_elf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "522-528",
          "snippet": "static inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct elfhdr *interp_ehdr,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct elfhdr *interp_ehdr,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_elf_pt_proc",
          "args": [
            "&loc->interp_elf_ex",
            "elf_ppnt",
            "interpreter",
            "true",
            "&arch_state"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "arch_elf_pt_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "498-505",
          "snippet": "static inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_elf_phdrs",
          "args": [
            "&loc->interp_elf_ex",
            "interpreter"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "load_elf_phdrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "417-460",
          "snippet": "static struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\tloff_t pos = elf_ex->e_phoff;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_phdata, size, &pos);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\tloff_t pos = elf_ex->e_phoff;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_phdata, size, &pos);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_fdpic",
          "args": [
            "&loc->interp_elf_ex"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&loc->interp_elf_ex"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "loc->interp_elf_ex.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "interpreter",
            "&loc->interp_elf_ex",
            "sizeof(loc->interp_elf_ex)",
            "&pos"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "would_dump",
          "args": [
            "bprm",
            "interpreter"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "would_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1309-1327",
          "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tif (inode_permission(inode, MAY_READ) < 0) {\n\t\tstruct user_namespace *old, *user_ns;\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n\n\t\t/* Ensure mm->user_ns contains the executable */\n\t\tuser_ns = old = bprm->mm->user_ns;\n\t\twhile ((user_ns != &init_user_ns) &&\n\t\t       !privileged_wrt_inode_uidgid(user_ns, inode))\n\t\t\tuser_ns = user_ns->parent;\n\n\t\tif (old != user_ns) {\n\t\t\tbprm->mm->user_ns = get_user_ns(user_ns);\n\t\t\tput_user_ns(old);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "interpreter"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "interpreter"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_exec",
          "args": [
            "elf_interpreter"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "open_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "880-890",
          "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "elf_ppnt->p_filesz",
            "GFP_KERNEL"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_fdpic",
          "args": [
            "&loc->elf_ex"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&loc->elf_ex"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "loc->elf_ex.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define INIT_ARCH_ELF_STATE {}\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint bss_prot = 0;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\tloff_t pos;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (elf_check_fdpic(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tpos = elf_ppnt->p_offset;\n\t\t\tretval = kernel_read(bprm->file, elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz, &pos);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\t/* Get the exec headers */\n\t\t\tpos = 0;\n\t\t\tretval = kernel_read(interpreter, &loc->interp_elf_ex,\n\t\t\t\t\t     sizeof(loc->interp_elf_ex), &pos);\n\t\t\tif (retval != sizeof(loc->interp_elf_ex)) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex) ||\n\t\t    elf_check_fdpic(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex,\n\t\t\t\t!!interpreter, &loc->interp_elf_ex,\n\t\t\t\t&arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\tinstall_exec_creds(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags, elf_fixed = MAP_FIXED_NOREPLACE;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias,\n\t\t\t\t\t bss_prot);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Some binaries have overlapping elf segments and then\n\t\t\t * we have to forcefully map over an existing mapping\n\t\t\t * e.g. over this newly established brk mapping.\n\t\t\t */\n\t\t\telf_fixed = MAP_FIXED;\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\t/*\n\t\t * If we are loading ET_EXEC or we have already performed\n\t\t * the ET_DYN load_addr calculations, proceed normally.\n\t\t */\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= elf_fixed;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/*\n\t\t\t * This logic is run once for the first LOAD Program\n\t\t\t * Header for ET_DYN binaries to calculate the\n\t\t\t * randomization (load_bias) for all the LOAD\n\t\t\t * Program Headers, and to calculate the entire\n\t\t\t * size of the ELF mapping (total_size). (Note that\n\t\t\t * load_addr_set is set to true later once the\n\t\t\t * initial mapping is performed.)\n\t\t\t *\n\t\t\t * There are effectively two types of ET_DYN\n\t\t\t * binaries: programs (i.e. PIE: ET_DYN with INTERP)\n\t\t\t * and loaders (ET_DYN without INTERP, since they\n\t\t\t * _are_ the ELF interpreter). The loaders must\n\t\t\t * be loaded away from programs since the program\n\t\t\t * may otherwise collide with the loader (especially\n\t\t\t * for ET_EXEC which does not have a randomized\n\t\t\t * position). For example to handle invocations of\n\t\t\t * \"./ld.so someprog\" to test out a new version of\n\t\t\t * the loader, the subsequent program that the\n\t\t\t * loader loads must avoid the loader itself, so\n\t\t\t * they cannot share the same load range. Sufficient\n\t\t\t * room for the brk must be allocated with the\n\t\t\t * loader as well, since brk must be available with\n\t\t\t * the loader.\n\t\t\t *\n\t\t\t * Therefore, programs are loaded offset from\n\t\t\t * ELF_ET_DYN_BASE and loaders are loaded into the\n\t\t\t * independently randomized mmap region (0 load_bias\n\t\t\t * without MAP_FIXED).\n\t\t\t */\n\t\t\tif (elf_interpreter) {\n\t\t\t\tload_bias = ELF_ET_DYN_BASE;\n\t\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\t\tload_bias += arch_mmap_rnd();\n\t\t\t\telf_flags |= elf_fixed;\n\t\t\t} else\n\t\t\t\tload_bias = 0;\n\n\t\t\t/*\n\t\t\t * Since load_bias is used for all subsequent loading\n\t\t\t * calculations, we must lower it by the first vaddr\n\t\t\t * so that the remaining calculations based on the\n\t\t\t * ELF vaddrs will be correctly offset. The result\n\t\t\t * is then page aligned.\n\t\t\t */\n\t\t\tload_bias = ELF_PAGESTART(load_bias - vaddr);\n\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\tloc->elf_ex.e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk) {\n\t\t\tbss_prot = elf_prot;\n\t\t\telf_brk = k;\n\t\t}\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk, bss_prot);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef compat_brk_randomized\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tfinalize_exec(bprm);\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}"
  },
  {
    "function_name": "randomize_stack_top",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "674-688",
    "snippet": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif (current->flags & PF_RANDOMIZE) {\n\t\trandom_variable = get_random_long();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_long",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */\n\nstatic unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif (current->flags & PF_RANDOMIZE) {\n\t\trandom_variable = get_random_long();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}"
  },
  {
    "function_name": "load_elf_interp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "537-663",
    "snippet": "static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tint bss_prot = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex) ||\n\t    elf_check_fdpic(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED_NOREPLACE;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_memsz;\n\t\t\tif (k > last_bss) {\n\t\t\t\tlast_bss = k;\n\t\t\t\tbss_prot = elf_prot;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now fill out the bss section: first pad the last page from\n\t * the file up to the page boundary, and zero it from elf_bss\n\t * up to the end of the page.\n\t */\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\t/*\n\t * Next, align both the file and mem bss up to the page size,\n\t * since this is where elf_bss was just zeroed up to, and where\n\t * last_bss will end after the vm_brk_flags() below.\n\t */\n\telf_bss = ELF_PAGEALIGN(elf_bss);\n\tlast_bss = ELF_PAGEALIGN(last_bss);\n\t/* Finally, if there is still more bss to allocate, do it. */\n\tif (last_bss > elf_bss) {\n\t\terror = vm_brk_flags(elf_bss, last_bss - elf_bss,\n\t\t\t\tbss_prot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_brk_flags",
          "args": [
            "elf_bss",
            "last_bss - elf_bss",
            "bss_prot & PROT_EXEC ? VM_EXEC : 0"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "last_bss"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "elf_bss"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padzero",
          "args": [
            "elf_bss"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "padzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "127-138",
          "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "k"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "vaddr"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "map_addr"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_map",
          "args": [
            "interpreter",
            "load_addr + vaddr",
            "eppnt",
            "elf_prot",
            "elf_type",
            "total_size"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "elf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "349-386",
          "snippet": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "total_mapping_size",
          "args": [
            "interp_elf_phdata",
            "interp_elf_ex->e_phnum"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "total_mapping_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
          "lines": "390-406",
          "snippet": "static unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/dax.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_fdpic",
          "args": [
            "interp_elf_ex"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "interp_elf_ex"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tint bss_prot = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex) ||\n\t    elf_check_fdpic(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED_NOREPLACE;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_memsz;\n\t\t\tif (k > last_bss) {\n\t\t\t\tlast_bss = k;\n\t\t\t\tbss_prot = elf_prot;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now fill out the bss section: first pad the last page from\n\t * the file up to the page boundary, and zero it from elf_bss\n\t * up to the end of the page.\n\t */\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\t/*\n\t * Next, align both the file and mem bss up to the page size,\n\t * since this is where elf_bss was just zeroed up to, and where\n\t * last_bss will end after the vm_brk_flags() below.\n\t */\n\telf_bss = ELF_PAGEALIGN(elf_bss);\n\tlast_bss = ELF_PAGEALIGN(last_bss);\n\t/* Finally, if there is still more bss to allocate, do it. */\n\tif (last_bss > elf_bss) {\n\t\terror = vm_brk_flags(elf_bss, last_bss - elf_bss,\n\t\t\t\tbss_prot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "arch_check_elf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "522-528",
    "snippet": "static inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct elfhdr *interp_ehdr,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct elfhdr *interp_ehdr,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_elf_pt_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "498-505",
    "snippet": "static inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
  },
  {
    "function_name": "load_elf_phdrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "417-460",
    "snippet": "static struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\tloff_t pos = elf_ex->e_phoff;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_phdata, size, &pos);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
    ],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_phdata"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "elf_file",
            "elf_phdata",
            "size",
            "&pos"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\tloff_t pos = elf_ex->e_phoff;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_phdata, size, &pos);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}"
  },
  {
    "function_name": "total_mapping_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "390-406",
    "snippet": "static unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "cmds[first_idx].p_vaddr"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}"
  },
  {
    "function_name": "elf_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "349-386",
    "snippet": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\"",
            "task_pid_nr(current)",
            "current->comm",
            "(void *)addr"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "(void *)map_addr"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "filep",
            "addr",
            "size",
            "prot",
            "type",
            "off"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "map_addr+size",
            "total_size-size"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "map_addr"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "filep",
            "addr",
            "total_size",
            "prot",
            "type",
            "off"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "total_size"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "size"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "addr"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}"
  },
  {
    "function_name": "create_elf_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "164-345",
    "snippet": "static int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE, bprm->secureexec);\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\n\t/* Populate list of argv pointers back to argv strings. */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = p;\n\n\t/* Populate list of envp pointers back to envp strings. */\n\tcurrent->mm->env_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_BASE_PLATFORM NULL"
    ],
    "globals_used": [
      "static int load_elf_binary(struct linux_binprm *bprm);",
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "sp",
            "elf_info",
            "ei_index * sizeof(elf_addr_t)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "sp++"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "(void __user *)p",
            "MAX_ARG_STRLEN"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(elf_addr_t)p",
            "sp++"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "sp++"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "(void __user *)p",
            "MAX_ARG_STRLEN"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(elf_addr_t)p",
            "sp++"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "argc",
            "sp++"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_extend_vma",
          "args": [
            "current->mm",
            "bprm->p"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ROUND",
          "args": [
            "sp",
            "items"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ADD",
          "args": [
            "p",
            "ei_index"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&elf_info[ei_index]",
            "0",
            "sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EXECFD",
            "bprm->interp_data"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_BASE_PLATFORM",
            "(elf_addr_t)(unsigned long)u_base_platform"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PLATFORM",
            "(elf_addr_t)(unsigned long)u_platform"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EXECFN",
            "bprm->exec"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_HWCAP2",
            "ELF_HWCAP2"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_RANDOM",
            "(elf_addr_t)(unsigned long)u_rand_bytes"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_SECURE",
            "bprm->secureexec"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EGID",
            "from_kgid_munged(cred->user_ns, cred->egid)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->egid"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_GID",
            "from_kgid_munged(cred->user_ns, cred->gid)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->gid"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EUID",
            "from_kuid_munged(cred->user_ns, cred->euid)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->euid"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_UID",
            "from_kuid_munged(cred->user_ns, cred->uid)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->uid"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_ENTRY",
            "exec->e_entry"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_FLAGS",
            "0"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_BASE",
            "interp_load_addr"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHNUM",
            "exec->e_phnum"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHENT",
            "sizeof(struct elf_phdr)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHDR",
            "load_addr + exec->e_phoff"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_CLKTCK",
            "CLOCKS_PER_SEC"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PAGESZ",
            "ELF_EXEC_PAGESIZE"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_HWCAP",
            "ELF_HWCAP"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_rand_bytes",
            "k_rand_bytes",
            "sizeof(k_rand_bytes)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ALLOC",
          "args": [
            "p",
            "sizeof(k_rand_bytes)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "k_rand_bytes",
            "sizeof(k_rand_bytes)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_base_platform",
            "k_base_platform",
            "len"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ALLOC",
          "args": [
            "p",
            "len"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "k_base_platform"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_platform",
            "k_platform",
            "len"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ALLOC",
          "args": [
            "p",
            "len"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_align_stack",
          "args": [
            "p"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_BASE_PLATFORM NULL\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE, bprm->secureexec);\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\n\t/* Populate list of argv pointers back to argv strings. */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = p;\n\n\t/* Populate list of envp pointers back to envp strings. */\n\tcurrent->mm->env_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "padzero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "127-138",
    "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void __user *) elf_bss",
            "nbyte"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "elf_bss"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_brk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_elf.c",
    "lines": "103-120",
    "snippet": "static int set_brk(unsigned long start, unsigned long end, int prot)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\t/*\n\t\t * Map the last of the bss segment.\n\t\t * If the header is requesting these pages to be\n\t\t * executable, honour that (ppc32 needs this).\n\t\t */\n\t\tint error = vm_brk_flags(start, end - start,\n\t\t\t\tprot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/dax.h>",
      "#include <linux/cred.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf-randomize.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_brk_flags",
          "args": [
            "start",
            "end - start",
            "prot & PROT_EXEC ? VM_EXEC : 0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "end"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "start"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <linux/dax.h>\n#include <linux/cred.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf-randomize.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int set_brk(unsigned long start, unsigned long end, int prot)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\t/*\n\t\t * Map the last of the bss segment.\n\t\t * If the header is requesting these pages to be\n\t\t * executable, honour that (ppc32 needs this).\n\t\t */\n\t\tint error = vm_brk_flags(start, end - start,\n\t\t\t\tprot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}"
  }
]