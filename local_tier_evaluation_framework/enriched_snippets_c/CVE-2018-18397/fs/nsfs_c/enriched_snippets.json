[
  {
    "function_name": "nsfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "277-283",
    "snippet": "void __init nsfs_init(void)\n{\n\tnsfs_mnt = kern_mount(&nsfs);\n\tif (IS_ERR(nsfs_mnt))\n\t\tpanic(\"can't set nsfs up\\n\");\n\tnsfs_mnt->mnt_sb->s_flags &= ~SB_NOUSER;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *nsfs_mnt;",
      "static struct file_system_type nsfs = {\n\t.name = \"nsfs\",\n\t.mount = nsfs_mount,\n\t.kill_sb = kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"can't set nsfs up\\n\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nsfs_mnt"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&nsfs"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic struct vfsmount *nsfs_mnt;\nstatic struct file_system_type nsfs = {\n\t.name = \"nsfs\",\n\t.mount = nsfs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nvoid __init nsfs_init(void)\n{\n\tnsfs_mnt = kern_mount(&nsfs);\n\tif (IS_ERR(nsfs_mnt))\n\t\tpanic(\"can't set nsfs up\\n\");\n\tnsfs_mnt->mnt_sb->s_flags &= ~SB_NOUSER;\n}"
  },
  {
    "function_name": "nsfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "265-270",
    "snippet": "static struct dentry *nsfs_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"nsfs:\", &nsfs_ops,\n\t\t\t&ns_dentry_operations, NSFS_MAGIC);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct dentry_operations ns_dentry_operations =\n{\n\t.d_prune\t= ns_prune_dentry,\n\t.d_delete\t= always_delete_dentry,\n\t.d_dname\t= ns_dname,\n};",
      "static const struct super_operations nsfs_ops = {\n\t.statfs = simple_statfs,\n\t.evict_inode = nsfs_evict,\n\t.show_path = nsfs_show_path,\n};",
      "static struct file_system_type nsfs = {\n\t.name = \"nsfs\",\n\t.mount = nsfs_mount,\n\t.kill_sb = kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"nsfs:\"",
            "&nsfs_ops",
            "&ns_dentry_operations",
            "NSFS_MAGIC"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nconst struct dentry_operations ns_dentry_operations =\n{\n\t.d_prune\t= ns_prune_dentry,\n\t.d_delete\t= always_delete_dentry,\n\t.d_dname\t= ns_dname,\n};\nstatic const struct super_operations nsfs_ops = {\n\t.statfs = simple_statfs,\n\t.evict_inode = nsfs_evict,\n\t.show_path = nsfs_show_path,\n};\nstatic struct file_system_type nsfs = {\n\t.name = \"nsfs\",\n\t.mount = nsfs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic struct dentry *nsfs_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"nsfs:\", &nsfs_ops,\n\t\t\t&ns_dentry_operations, NSFS_MAGIC);\n}"
  },
  {
    "function_name": "nsfs_show_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "251-258",
    "snippet": "static int nsfs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\tseq_printf(seq, \"%s:[%lu]\", ns_ops->name, inode->i_ino);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s:[%lu]\"",
            "ns_ops->name",
            "inode->i_ino"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "401-408",
          "snippet": "void seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic int nsfs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\tseq_printf(seq, \"%s:[%lu]\", ns_ops->name, inode->i_ino);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_ns_fget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "233-249",
    "snippet": "struct file *proc_ns_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &ns_file_operations)\n\t\tgoto out_invalid;\n\n\treturn file;\n\nout_invalid:\n\tfput(file);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "fd"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "proc_ns_fget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
          "lines": "233-249",
          "snippet": "struct file *proc_ns_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &ns_file_operations)\n\t\tgoto out_invalid;\n\n\treturn file;\n\nout_invalid:\n\tfput(file);\n\treturn ERR_PTR(-EINVAL);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};\n\nstruct file *proc_ns_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &ns_file_operations)\n\t\tgoto out_invalid;\n\n\treturn file;\n\nout_invalid:\n\tfput(file);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "ns_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "218-231",
    "snippet": "int ns_get_name(char *buf, size_t size, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tint res = -ENOENT;\n\tconst char *name;\n\tns = ns_ops->get(task);\n\tif (ns) {\n\t\tname = ns_ops->real_ns_name ? : ns_ops->name;\n\t\tres = snprintf(buf, size, \"%s:[%u]\", name, ns->inum);\n\t\tns_ops->put(ns);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_ops->put",
          "args": [
            "ns"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "size",
            "\"%s:[%u]\"",
            "name",
            "ns->inum"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_ops->get",
          "args": [
            "task"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/orangefs/orangefs-bufmap.c",
          "lines": "124-137",
          "snippet": "static int get(struct slot_map *m)\n{\n\tint res = 0;\n\tspin_lock(&m->q.lock);\n\tif (unlikely(m->c <= 0))\n\t\tres = wait_for_free(m);\n\tif (likely(!res)) {\n\t\tm->c--;\n\t\tres = find_first_zero_bit(m->map, m->count);\n\t\t__set_bit(res, m->map);\n\t}\n\tspin_unlock(&m->q.lock);\n\treturn res;\n}",
          "includes": [
            "#include \"orangefs-bufmap.h\"",
            "#include \"orangefs-kernel.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"orangefs-bufmap.h\"\n#include \"orangefs-kernel.h\"\n#include \"protocol.h\"\n\nstatic int get(struct slot_map *m)\n{\n\tint res = 0;\n\tspin_lock(&m->q.lock);\n\tif (unlikely(m->c <= 0))\n\t\tres = wait_for_free(m);\n\tif (likely(!res)) {\n\t\tm->c--;\n\t\tres = find_first_zero_bit(m->map, m->count);\n\t\t__set_bit(res, m->map);\n\t}\n\tspin_unlock(&m->q.lock);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nint ns_get_name(char *buf, size_t size, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tint res = -ENOENT;\n\tconst char *name;\n\tns = ns_ops->get(task);\n\tif (ns) {\n\t\tname = ns_ops->real_ns_name ? : ns_ops->name;\n\t\tres = snprintf(buf, size, \"%s:[%u]\", name, ns->inum);\n\t\tns_ops->put(ns);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "ns_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "189-216",
    "snippet": "static long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ns_common *ns = get_proc_ns(file_inode(filp));\n\tuid_t __user *argp;\n\tuid_t uid;\n\n\tswitch (ioctl) {\n\tcase NS_GET_USERNS:\n\t\treturn open_related_ns(ns, ns_get_owner);\n\tcase NS_GET_PARENT:\n\t\tif (!ns->ops->get_parent)\n\t\t\treturn -EINVAL;\n\t\treturn open_related_ns(ns, ns->ops->get_parent);\n\tcase NS_GET_NSTYPE:\n\t\treturn ns->ops->type;\n\tcase NS_GET_OWNER_UID:\n\t\tif (ns->ops->type != CLONE_NEWUSER)\n\t\t\treturn -EINVAL;\n\t\tuser_ns = container_of(ns, struct user_namespace, ns);\n\t\targp = (uid_t __user *) arg;\n\t\tuid = from_kuid_munged(current_user_ns(), user_ns->owner);\n\t\treturn put_user(uid, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "uid",
            "argp"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "user_ns->owner"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ns",
            "structuser_namespace",
            "ns"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_related_ns",
          "args": [
            "ns",
            "ns->ops->get_parent"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "open_related_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
          "lines": "146-186",
          "snippet": "int open_related_ns(struct ns_common *ns,\n\t\t   struct ns_common *(*get_ns)(struct ns_common *ns))\n{\n\tstruct path path = {};\n\tstruct file *f;\n\tvoid *err;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\twhile (1) {\n\t\tstruct ns_common *relative;\n\n\t\trelative = get_ns(ns);\n\t\tif (IS_ERR(relative)) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn PTR_ERR(relative);\n\t\t}\n\n\t\terr = __ns_get_path(&path, relative);\n\t\tif (IS_ERR(err) && PTR_ERR(err) == -EAGAIN)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (IS_ERR(err)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(err);\n\t}\n\n\tf = dentry_open(&path, O_RDONLY, current_cred());\n\tpath_put(&path);\n\tif (IS_ERR(f)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(f);\n\t} else\n\t\tfd_install(fd, f);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/nsfs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/ktime.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nint open_related_ns(struct ns_common *ns,\n\t\t   struct ns_common *(*get_ns)(struct ns_common *ns))\n{\n\tstruct path path = {};\n\tstruct file *f;\n\tvoid *err;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\twhile (1) {\n\t\tstruct ns_common *relative;\n\n\t\trelative = get_ns(ns);\n\t\tif (IS_ERR(relative)) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn PTR_ERR(relative);\n\t\t}\n\n\t\terr = __ns_get_path(&path, relative);\n\t\tif (IS_ERR(err) && PTR_ERR(err) == -EAGAIN)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (IS_ERR(err)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(err);\n\t}\n\n\tf = dentry_open(&path, O_RDONLY, current_cred());\n\tpath_put(&path);\n\tif (IS_ERR(f)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(f);\n\t} else\n\t\tfd_install(fd, f);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_ns",
          "args": [
            "file_inode(filp)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg);\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ns_common *ns = get_proc_ns(file_inode(filp));\n\tuid_t __user *argp;\n\tuid_t uid;\n\n\tswitch (ioctl) {\n\tcase NS_GET_USERNS:\n\t\treturn open_related_ns(ns, ns_get_owner);\n\tcase NS_GET_PARENT:\n\t\tif (!ns->ops->get_parent)\n\t\t\treturn -EINVAL;\n\t\treturn open_related_ns(ns, ns->ops->get_parent);\n\tcase NS_GET_NSTYPE:\n\t\treturn ns->ops->type;\n\tcase NS_GET_OWNER_UID:\n\t\tif (ns->ops->type != CLONE_NEWUSER)\n\t\t\treturn -EINVAL;\n\t\tuser_ns = container_of(ns, struct user_namespace, ns);\n\t\targp = (uid_t __user *) arg;\n\t\tuid = from_kuid_munged(current_user_ns(), user_ns->owner);\n\t\treturn put_user(uid, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "open_related_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "146-186",
    "snippet": "int open_related_ns(struct ns_common *ns,\n\t\t   struct ns_common *(*get_ns)(struct ns_common *ns))\n{\n\tstruct path path = {};\n\tstruct file *f;\n\tvoid *err;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\twhile (1) {\n\t\tstruct ns_common *relative;\n\n\t\trelative = get_ns(ns);\n\t\tif (IS_ERR(relative)) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn PTR_ERR(relative);\n\t\t}\n\n\t\terr = __ns_get_path(&path, relative);\n\t\tif (IS_ERR(err) && PTR_ERR(err) == -EAGAIN)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (IS_ERR(err)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(err);\n\t}\n\n\tf = dentry_open(&path, O_RDONLY, current_cred());\n\tpath_put(&path);\n\tif (IS_ERR(f)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(f);\n\t} else\n\t\tfd_install(fd, f);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "f"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "f"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "556-562",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&path",
            "O_RDONLY",
            "current_cred()"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "883-903",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = alloc_empty_file(flags, cred);\n\tif (!IS_ERR(f)) {\n\t\terror = vfs_open(path, f);\n\t\tif (error) {\n\t\t\tfput(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = alloc_empty_file(flags, cred);\n\tif (!IS_ERR(f)) {\n\t\terror = vfs_open(path, f);\n\t\tif (error) {\n\t\t\tfput(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "err"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "err"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "err"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "err"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ns_get_path",
          "args": [
            "&path",
            "relative"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__ns_get_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
          "lines": "54-104",
          "snippet": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &empty_name);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/nsfs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/ktime.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *nsfs_mnt;",
            "static const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic struct vfsmount *nsfs_mnt;\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};\n\nstatic void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &empty_name);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "relative"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "relative"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ns",
          "args": [
            "ns"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_get_nsegments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/sufile.h",
          "lines": "18-21",
          "snippet": "static inline unsigned long nilfs_sufile_get_nsegments(struct inode *sufile)\n{\n\treturn ((struct the_nilfs *)sufile->i_sb->s_fs_info)->ns_nsegments;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long nilfs_sufile_get_nsegments(struct inode *sufile)\n{\n\treturn ((struct the_nilfs *)sufile->i_sb->s_fs_info)->ns_nsegments;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "O_CLOEXEC"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nint open_related_ns(struct ns_common *ns,\n\t\t   struct ns_common *(*get_ns)(struct ns_common *ns))\n{\n\tstruct path path = {};\n\tstruct file *f;\n\tvoid *err;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\twhile (1) {\n\t\tstruct ns_common *relative;\n\n\t\trelative = get_ns(ns);\n\t\tif (IS_ERR(relative)) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn PTR_ERR(relative);\n\t\t}\n\n\t\terr = __ns_get_path(&path, relative);\n\t\tif (IS_ERR(err) && PTR_ERR(err) == -EAGAIN)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (IS_ERR(err)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(err);\n\t}\n\n\tf = dentry_open(&path, O_RDONLY, current_cred());\n\tpath_put(&path);\n\tif (IS_ERR(f)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(f);\n\t} else\n\t\tfd_install(fd, f);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "ns_get_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "135-144",
    "snippet": "void *ns_get_path(struct path *path, struct task_struct *task,\n\t\t  const struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_get_path_task_args args = {\n\t\t.ns_ops\t= ns_ops,\n\t\t.task\t= task,\n\t};\n\n\treturn ns_get_path_cb(path, ns_get_path_task, &args);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_get_path_cb",
          "args": [
            "path",
            "ns_get_path_task",
            "&args"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ns_get_path_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
          "lines": "106-121",
          "snippet": "void *ns_get_path_cb(struct path *path, ns_get_path_helper_t *ns_get_cb,\n\t\t     void *private_data)\n{\n\tstruct ns_common *ns;\n\tvoid *ret;\n\nagain:\n\tns = ns_get_cb(private_data);\n\tif (!ns)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = __ns_get_path(path, ns);\n\tif (IS_ERR(ret) && PTR_ERR(ret) == -EAGAIN)\n\t\tgoto again;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/nsfs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/ktime.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nvoid *ns_get_path_cb(struct path *path, ns_get_path_helper_t *ns_get_cb,\n\t\t     void *private_data)\n{\n\tstruct ns_common *ns;\n\tvoid *ret;\n\nagain:\n\tns = ns_get_cb(private_data);\n\tif (!ns)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = __ns_get_path(path, ns);\n\tif (IS_ERR(ret) && PTR_ERR(ret) == -EAGAIN)\n\t\tgoto again;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nvoid *ns_get_path(struct path *path, struct task_struct *task,\n\t\t  const struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_get_path_task_args args = {\n\t\t.ns_ops\t= ns_ops,\n\t\t.task\t= task,\n\t};\n\n\treturn ns_get_path_cb(path, ns_get_path_task, &args);\n}"
  },
  {
    "function_name": "ns_get_path_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "128-133",
    "snippet": "static struct ns_common *ns_get_path_task(void *private_data)\n{\n\tstruct ns_get_path_task_args *args = private_data;\n\n\treturn args->ns_ops->get(args->task);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "args->ns_ops->get",
          "args": [
            "args->task"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/orangefs/orangefs-bufmap.c",
          "lines": "124-137",
          "snippet": "static int get(struct slot_map *m)\n{\n\tint res = 0;\n\tspin_lock(&m->q.lock);\n\tif (unlikely(m->c <= 0))\n\t\tres = wait_for_free(m);\n\tif (likely(!res)) {\n\t\tm->c--;\n\t\tres = find_first_zero_bit(m->map, m->count);\n\t\t__set_bit(res, m->map);\n\t}\n\tspin_unlock(&m->q.lock);\n\treturn res;\n}",
          "includes": [
            "#include \"orangefs-bufmap.h\"",
            "#include \"orangefs-kernel.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"orangefs-bufmap.h\"\n#include \"orangefs-kernel.h\"\n#include \"protocol.h\"\n\nstatic int get(struct slot_map *m)\n{\n\tint res = 0;\n\tspin_lock(&m->q.lock);\n\tif (unlikely(m->c <= 0))\n\t\tres = wait_for_free(m);\n\tif (likely(!res)) {\n\t\tm->c--;\n\t\tres = find_first_zero_bit(m->map, m->count);\n\t\t__set_bit(res, m->map);\n\t}\n\tspin_unlock(&m->q.lock);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic struct ns_common *ns_get_path_task(void *private_data)\n{\n\tstruct ns_get_path_task_args *args = private_data;\n\n\treturn args->ns_ops->get(args->task);\n}"
  },
  {
    "function_name": "ns_get_path_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "106-121",
    "snippet": "void *ns_get_path_cb(struct path *path, ns_get_path_helper_t *ns_get_cb,\n\t\t     void *private_data)\n{\n\tstruct ns_common *ns;\n\tvoid *ret;\n\nagain:\n\tns = ns_get_cb(private_data);\n\tif (!ns)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = __ns_get_path(path, ns);\n\tif (IS_ERR(ret) && PTR_ERR(ret) == -EAGAIN)\n\t\tgoto again;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ret"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ret"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ns_get_path",
          "args": [
            "path",
            "ns"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__ns_get_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
          "lines": "54-104",
          "snippet": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &empty_name);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/nsfs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/ktime.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *nsfs_mnt;",
            "static const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic struct vfsmount *nsfs_mnt;\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};\n\nstatic void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &empty_name);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_get_cb",
          "args": [
            "private_data"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nvoid *ns_get_path_cb(struct path *path, ns_get_path_helper_t *ns_get_cb,\n\t\t     void *private_data)\n{\n\tstruct ns_common *ns;\n\tvoid *ret;\n\nagain:\n\tns = ns_get_cb(private_data);\n\tif (!ns)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = __ns_get_path(path, ns);\n\tif (IS_ERR(ret) && PTR_ERR(ret) == -EAGAIN)\n\t\tgoto again;\n\treturn ret;\n}"
  },
  {
    "function_name": "__ns_get_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "54-104",
    "snippet": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &empty_name);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *nsfs_mnt;",
      "static const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2338-2357",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint isdir = d_is_dir(dentry);\n\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\t/*\n\t * Are we the only user?\n\t */\n\tif (dentry->d_lockref.count == 1) {\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t} else {\n\t\t__d_drop(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint isdir = d_is_dir(dentry);\n\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\t/*\n\t * Are we the only user?\n\t */\n\tif (dentry->d_lockref.count == 1) {\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t} else {\n\t\t__d_drop(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_cmpxchg",
          "args": [
            "&ns->stashed",
            "0",
            "(unsigned long)dentry"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1937-1940",
          "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_pseudo",
          "args": [
            "mnt->mnt_sb",
            "&empty_name"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1720-1723",
          "snippet": "struct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns->ops->put",
          "args": [
            "ns"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode_pseudo",
          "args": [
            "mnt->mnt_sb"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "904-915",
          "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "mnt"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1192-1197",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns->ops->put",
          "args": [
            "ns"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_get_not_dead",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&ns->stashed"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic struct vfsmount *nsfs_mnt;\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};\n\nstatic void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &empty_name);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}"
  },
  {
    "function_name": "nsfs_evict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "47-52",
    "snippet": "static void nsfs_evict(struct inode *inode)\n{\n\tstruct ns_common *ns = inode->i_private;\n\tclear_inode(inode);\n\tns->ops->put(ns);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns->ops->put",
          "args": [
            "ns"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "504-521",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic void nsfs_evict(struct inode *inode)\n{\n\tstruct ns_common *ns = inode->i_private;\n\tclear_inode(inode);\n\tns->ops->put(ns);\n}"
  },
  {
    "function_name": "ns_prune_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "31-38",
    "snippet": "static void ns_prune_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode) {\n\t\tstruct ns_common *ns = inode->i_private;\n\t\tatomic_long_set(&ns->stashed, 0);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&ns->stashed",
            "0"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic void ns_prune_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode) {\n\t\tstruct ns_common *ns = inode->i_private;\n\t\tatomic_long_set(&ns->stashed, 0);\n\t}\n}"
  },
  {
    "function_name": "ns_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nsfs.c",
    "lines": "22-29",
    "snippet": "static char *ns_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\treturn dynamic_dname(dentry, buffer, buflen, \"%s:[%lu]\",\n\t\tns_ops->name, inode->i_ino);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/nsfs.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/ktime.h>",
      "#include <linux/magic.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynamic_dname",
          "args": [
            "dentry",
            "buffer",
            "buflen",
            "\"%s:[%lu]\"",
            "ns_ops->name",
            "inode->i_ino"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "dynamic_dname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "291-307",
          "snippet": "char *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/nsfs.h>\n#include <linux/user_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/ktime.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n\nstatic char *ns_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\treturn dynamic_dname(dentry, buffer, buflen, \"%s:[%lu]\",\n\t\tns_ops->name, inode->i_ino);\n}"
  }
]