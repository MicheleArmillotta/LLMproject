[
  {
    "function_name": "do_io_getevents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "2035-2052",
    "snippet": "static long do_io_getevents(aio_context_t ctx_id,\n\t\tlong min_nr,\n\t\tlong nr,\n\t\tstruct io_event __user *events,\n\t\tstruct timespec64 *ts)\n{\n\tktime_t until = ts ? timespec64_to_ktime(*ts) : KTIME_MAX;\n\tstruct kioctx *ioctx = lookup_ioctx(ctx_id);\n\tlong ret = -EINVAL;\n\n\tif (likely(ioctx)) {\n\t\tif (likely(min_nr <= nr && min_nr >= 0))\n\t\t\tret = read_events(ioctx, min_nr, nr, events, until);\n\t\tpercpu_ref_put(&ioctx->users);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&ioctx->users"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_events",
          "args": [
            "ioctx",
            "min_nr",
            "nr",
            "events",
            "until"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "read_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1243-1270",
          "snippet": "static long read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\tstruct io_event __user *event,\n\t\t\tktime_t until)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Note that aio_read_events() is being called as the conditional - i.e.\n\t * we're calling it after prepare_to_wait() has set task state to\n\t * TASK_INTERRUPTIBLE.\n\t *\n\t * But aio_read_events() can block, and if it blocks it's going to flip\n\t * the task state back to TASK_RUNNING.\n\t *\n\t * This should be ok, provided it doesn't flip the state back to\n\t * TASK_RUNNING and return 0 too much - that causes us to spin. That\n\t * will only happen if the mutex_lock() call blocks, and we then find\n\t * the ringbuffer empty. So in practice we should be ok, but it's\n\t * something to be aware of when touching this code.\n\t */\n\tif (until == 0)\n\t\taio_read_events(ctx, min_nr, nr, event, &ret);\n\telse\n\t\twait_event_interruptible_hrtimeout(ctx->wait,\n\t\t\t\taio_read_events(ctx, min_nr, nr, event, &ret),\n\t\t\t\tuntil);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic long read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\tstruct io_event __user *event,\n\t\t\tktime_t until)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Note that aio_read_events() is being called as the conditional - i.e.\n\t * we're calling it after prepare_to_wait() has set task state to\n\t * TASK_INTERRUPTIBLE.\n\t *\n\t * But aio_read_events() can block, and if it blocks it's going to flip\n\t * the task state back to TASK_RUNNING.\n\t *\n\t * This should be ok, provided it doesn't flip the state back to\n\t * TASK_RUNNING and return 0 too much - that causes us to spin. That\n\t * will only happen if the mutex_lock() call blocks, and we then find\n\t * the ringbuffer empty. So in practice we should be ok, but it's\n\t * something to be aware of when touching this code.\n\t */\n\tif (until == 0)\n\t\taio_read_events(ctx, min_nr, nr, event, &ret);\n\telse\n\t\twait_event_interruptible_hrtimeout(ctx->wait,\n\t\t\t\taio_read_events(ctx, min_nr, nr, event, &ret),\n\t\t\t\tuntil);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "min_nr <= nr && min_nr >= 0"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ioctx"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_ioctx",
          "args": [
            "ctx_id"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_ioctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1024-1049",
          "snippet": "static struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = rcu_dereference(table->table[id]);\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tif (percpu_ref_tryget_live(&ctx->users))\n\t\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = rcu_dereference(table->table[id]);\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tif (percpu_ref_tryget_live(&ctx->users))\n\t\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*ts"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic long do_io_getevents(aio_context_t ctx_id,\n\t\tlong min_nr,\n\t\tlong nr,\n\t\tstruct io_event __user *events,\n\t\tstruct timespec64 *ts)\n{\n\tktime_t until = ts ? timespec64_to_ktime(*ts) : KTIME_MAX;\n\tstruct kioctx *ioctx = lookup_ioctx(ctx_id);\n\tlong ret = -EINVAL;\n\n\tif (likely(ioctx)) {\n\t\tif (likely(min_nr <= nr && min_nr >= 0))\n\t\t\tret = read_events(ioctx, min_nr, nr, events, until);\n\t\tpercpu_ref_put(&ioctx->users);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lookup_kiocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1971-1984",
    "snippet": "static struct aio_kiocb *\nlookup_kiocb(struct kioctx *ctx, struct iocb __user *iocb)\n{\n\tstruct aio_kiocb *kiocb;\n\n\tassert_spin_locked(&ctx->ctx_lock);\n\n\t/* TODO: use a hash or array, this sucks. */\n\tlist_for_each_entry(kiocb, &ctx->active_reqs, ki_list) {\n\t\tif (kiocb->ki_user_iocb == iocb)\n\t\t\treturn kiocb;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kiocb",
            "&ctx->active_reqs",
            "ki_list"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct aio_kiocb *\nlookup_kiocb(struct kioctx *ctx, struct iocb __user *iocb)\n{\n\tstruct aio_kiocb *kiocb;\n\n\tassert_spin_locked(&ctx->ctx_lock);\n\n\t/* TODO: use a hash or array, this sucks. */\n\tlist_for_each_entry(kiocb, &ctx->active_reqs, ki_list) {\n\t\tif (kiocb->ki_user_iocb == iocb)\n\t\t\treturn kiocb;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "io_submit_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1777-1874",
    "snippet": "static int io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,\n\t\t\t bool compat)\n{\n\tstruct aio_kiocb *req;\n\tstruct iocb iocb;\n\tssize_t ret;\n\n\tif (unlikely(copy_from_user(&iocb, user_iocb, sizeof(iocb))))\n\t\treturn -EFAULT;\n\n\t/* enforce forwards compatibility on users */\n\tif (unlikely(iocb.aio_reserved2)) {\n\t\tpr_debug(\"EINVAL: reserve field set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* prevent overflows */\n\tif (unlikely(\n\t    (iocb.aio_buf != (unsigned long)iocb.aio_buf) ||\n\t    (iocb.aio_nbytes != (size_t)iocb.aio_nbytes) ||\n\t    ((ssize_t)iocb.aio_nbytes < 0)\n\t   )) {\n\t\tpr_debug(\"EINVAL: overflow check\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treq = aio_get_req(ctx);\n\tif (unlikely(!req))\n\t\treturn -EAGAIN;\n\n\tif (iocb.aio_flags & IOCB_FLAG_RESFD) {\n\t\t/*\n\t\t * If the IOCB_FLAG_RESFD flag of aio_flags is set, get an\n\t\t * instance of the file* now. The file descriptor must be\n\t\t * an eventfd() fd, and will be signaled for each completed\n\t\t * event using the eventfd_signal() function.\n\t\t */\n\t\treq->ki_eventfd = eventfd_ctx_fdget((int) iocb.aio_resfd);\n\t\tif (IS_ERR(req->ki_eventfd)) {\n\t\t\tret = PTR_ERR(req->ki_eventfd);\n\t\t\treq->ki_eventfd = NULL;\n\t\t\tgoto out_put_req;\n\t\t}\n\t}\n\n\tret = put_user(KIOCB_KEY, &user_iocb->aio_key);\n\tif (unlikely(ret)) {\n\t\tpr_debug(\"EFAULT: aio_key\\n\");\n\t\tgoto out_put_req;\n\t}\n\n\treq->ki_user_iocb = user_iocb;\n\treq->ki_user_data = iocb.aio_data;\n\n\tswitch (iocb.aio_lio_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = aio_read(&req->rw, &iocb, false, compat);\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = aio_write(&req->rw, &iocb, false, compat);\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = aio_read(&req->rw, &iocb, true, compat);\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = aio_write(&req->rw, &iocb, true, compat);\n\t\tbreak;\n\tcase IOCB_CMD_FSYNC:\n\t\tret = aio_fsync(&req->fsync, &iocb, false);\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = aio_fsync(&req->fsync, &iocb, true);\n\t\tbreak;\n\tcase IOCB_CMD_POLL:\n\t\tret = aio_poll(req, &iocb);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"invalid aio operation %d\\n\", iocb.aio_lio_opcode);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * If ret is 0, we'd either done aio_complete() ourselves or have\n\t * arranged for that to be done asynchronously.  Anything non-zero\n\t * means that we need to destroy req ourselves.\n\t */\n\tif (ret)\n\t\tgoto out_put_req;\n\treturn 0;\nout_put_req:\n\tput_reqs_available(ctx, 1);\n\tpercpu_ref_put(&ctx->reqs);\n\tif (req->ki_eventfd)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define KIOCB_KEY\t\t0"
    ],
    "globals_used": [
      "static struct kmem_cache\t*kiocb_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kiocb_cachep",
            "req"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "req->ki_eventfd"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "89-92",
          "snippet": "void eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&ctx->reqs"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_reqs_available",
          "args": [
            "ctx",
            "1"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "put_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "887-902",
          "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"invalid aio operation %d\\n\"",
            "iocb.aio_lio_opcode"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_poll",
          "args": [
            "req",
            "&iocb"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "aio_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1709-1775",
          "snippet": "static ssize_t aio_poll(struct aio_kiocb *aiocb, struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\n\t/* reject any unknown events outside the normal event mask. */\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\t/* reject fields that are not defined for poll */\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; /* same as no support for IOCB_CMD_POLL */\n\n\t/* initialized the list so that we can do list_empty checks */\n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\n\t/* one for removal from waitqueue, one for this function */\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\t/* we did not manage to set up a waitqueue, done */\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\t/* wake_up context handles the rest */\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\t/* if we get an error or a mask we are done */\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\t/* actually waiting for an event */\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\nout:\n\tif (unlikely(apt.error)) {\n\t\tfput(req->file);\n\t\treturn apt.error;\n\t}\n\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_poll(struct aio_kiocb *aiocb, struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\n\t/* reject any unknown events outside the normal event mask. */\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\t/* reject fields that are not defined for poll */\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; /* same as no support for IOCB_CMD_POLL */\n\n\t/* initialized the list so that we can do list_empty checks */\n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\n\t/* one for removal from waitqueue, one for this function */\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\t/* we did not manage to set up a waitqueue, done */\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\t/* wake_up context handles the rest */\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\t/* if we get an error or a mask we are done */\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\t/* actually waiting for an event */\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\nout:\n\tif (unlikely(apt.error)) {\n\t\tfput(req->file);\n\t\treturn apt.error;\n\t}\n\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_fsync",
          "args": [
            "&req->fsync",
            "&iocb",
            "true"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "aio_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1581-1599",
          "snippet": "static int aio_fsync(struct fsync_iocb *req, struct iocb *iocb, bool datasync)\n{\n\tif (unlikely(iocb->aio_buf || iocb->aio_offset || iocb->aio_nbytes ||\n\t\t\tiocb->aio_rw_flags))\n\t\treturn -EINVAL;\n\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\tif (unlikely(!req->file->f_op->fsync)) {\n\t\tfput(req->file);\n\t\treturn -EINVAL;\n\t}\n\n\treq->datasync = datasync;\n\tINIT_WORK(&req->work, aio_fsync_work);\n\tschedule_work(&req->work);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_fsync(struct fsync_iocb *req, struct iocb *iocb, bool datasync)\n{\n\tif (unlikely(iocb->aio_buf || iocb->aio_offset || iocb->aio_nbytes ||\n\t\t\tiocb->aio_rw_flags))\n\t\treturn -EINVAL;\n\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\tif (unlikely(!req->file->f_op->fsync)) {\n\t\tfput(req->file);\n\t\treturn -EINVAL;\n\t}\n\n\treq->datasync = datasync;\n\tINIT_WORK(&req->work, aio_fsync_work);\n\tschedule_work(&req->work);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_write",
          "args": [
            "&req->rw",
            "&iocb",
            "true",
            "compat"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "aio_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1525-1569",
          "snippet": "static ssize_t aio_write(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->write_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(WRITE, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(WRITE, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret) {\n\t\t/*\n\t\t * Open-code file_start_write here to grab freeze protection,\n\t\t * which will be released by another thread in\n\t\t * aio_complete_rw().  Fool lockdep by telling it the lock got\n\t\t * released so that it doesn't complain about the held lock when\n\t\t * we return to userspace.\n\t\t */\n\t\tif (S_ISREG(file_inode(file)->i_mode)) {\n\t\t\t__sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);\n\t\t\t__sb_writers_release(file_inode(file)->i_sb, SB_FREEZE_WRITE);\n\t\t}\n\t\treq->ki_flags |= IOCB_WRITE;\n\t\taio_rw_done(req, call_write_iter(file, req, &iter));\n\t}\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_write(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->write_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(WRITE, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(WRITE, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret) {\n\t\t/*\n\t\t * Open-code file_start_write here to grab freeze protection,\n\t\t * which will be released by another thread in\n\t\t * aio_complete_rw().  Fool lockdep by telling it the lock got\n\t\t * released so that it doesn't complain about the held lock when\n\t\t * we return to userspace.\n\t\t */\n\t\tif (S_ISREG(file_inode(file)->i_mode)) {\n\t\t\t__sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);\n\t\t\t__sb_writers_release(file_inode(file)->i_sb, SB_FREEZE_WRITE);\n\t\t}\n\t\treq->ki_flags |= IOCB_WRITE;\n\t\taio_rw_done(req, call_write_iter(file, req, &iter));\n\t}\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_read",
          "args": [
            "&req->rw",
            "&iocb",
            "true",
            "compat"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "aio_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1492-1523",
          "snippet": "static ssize_t aio_read(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->read_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(READ, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(READ, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret)\n\t\taio_rw_done(req, call_read_iter(file, req, &iter));\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_read(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->read_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(READ, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(READ, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret)\n\t\taio_rw_done(req, call_read_iter(file, req, &iter));\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EFAULT: aio_key\\n\""
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "KIOCB_KEY",
            "&user_iocb->aio_key"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req->ki_eventfd"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req->ki_eventfd"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_fdget",
          "args": [
            "(int) iocb.aio_resfd"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_fdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "349-358",
          "snippet": "struct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nstruct eventfd_ctx *eventfd_ctx_fdget(int fd)\n{\n\tstruct eventfd_ctx *ctx;\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tctx = eventfd_ctx_fileget(f.file);\n\tfdput(f);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_get_req",
          "args": [
            "ctx"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "aio_get_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1000-1022",
          "snippet": "static inline struct aio_kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct aio_kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\tINIT_LIST_HEAD(&req->ki_list);\n\trefcount_set(&req->ki_refcnt, 0);\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*kiocb_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic inline struct aio_kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct aio_kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\tINIT_LIST_HEAD(&req->ki_list);\n\trefcount_set(&req->ki_refcnt, 0);\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EINVAL: overflow check\\n\""
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(iocb.aio_buf != (unsigned long)iocb.aio_buf) ||\n\t    (iocb.aio_nbytes != (size_t)iocb.aio_nbytes) ||\n\t    ((ssize_t)iocb.aio_nbytes < 0)"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EINVAL: reserve field set\\n\""
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "iocb.aio_reserved2"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copy_from_user(&iocb, user_iocb, sizeof(iocb))"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&iocb",
            "user_iocb",
            "sizeof(iocb)"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define KIOCB_KEY\t\t0\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic int io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,\n\t\t\t bool compat)\n{\n\tstruct aio_kiocb *req;\n\tstruct iocb iocb;\n\tssize_t ret;\n\n\tif (unlikely(copy_from_user(&iocb, user_iocb, sizeof(iocb))))\n\t\treturn -EFAULT;\n\n\t/* enforce forwards compatibility on users */\n\tif (unlikely(iocb.aio_reserved2)) {\n\t\tpr_debug(\"EINVAL: reserve field set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* prevent overflows */\n\tif (unlikely(\n\t    (iocb.aio_buf != (unsigned long)iocb.aio_buf) ||\n\t    (iocb.aio_nbytes != (size_t)iocb.aio_nbytes) ||\n\t    ((ssize_t)iocb.aio_nbytes < 0)\n\t   )) {\n\t\tpr_debug(\"EINVAL: overflow check\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treq = aio_get_req(ctx);\n\tif (unlikely(!req))\n\t\treturn -EAGAIN;\n\n\tif (iocb.aio_flags & IOCB_FLAG_RESFD) {\n\t\t/*\n\t\t * If the IOCB_FLAG_RESFD flag of aio_flags is set, get an\n\t\t * instance of the file* now. The file descriptor must be\n\t\t * an eventfd() fd, and will be signaled for each completed\n\t\t * event using the eventfd_signal() function.\n\t\t */\n\t\treq->ki_eventfd = eventfd_ctx_fdget((int) iocb.aio_resfd);\n\t\tif (IS_ERR(req->ki_eventfd)) {\n\t\t\tret = PTR_ERR(req->ki_eventfd);\n\t\t\treq->ki_eventfd = NULL;\n\t\t\tgoto out_put_req;\n\t\t}\n\t}\n\n\tret = put_user(KIOCB_KEY, &user_iocb->aio_key);\n\tif (unlikely(ret)) {\n\t\tpr_debug(\"EFAULT: aio_key\\n\");\n\t\tgoto out_put_req;\n\t}\n\n\treq->ki_user_iocb = user_iocb;\n\treq->ki_user_data = iocb.aio_data;\n\n\tswitch (iocb.aio_lio_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = aio_read(&req->rw, &iocb, false, compat);\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = aio_write(&req->rw, &iocb, false, compat);\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = aio_read(&req->rw, &iocb, true, compat);\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = aio_write(&req->rw, &iocb, true, compat);\n\t\tbreak;\n\tcase IOCB_CMD_FSYNC:\n\t\tret = aio_fsync(&req->fsync, &iocb, false);\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = aio_fsync(&req->fsync, &iocb, true);\n\t\tbreak;\n\tcase IOCB_CMD_POLL:\n\t\tret = aio_poll(req, &iocb);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"invalid aio operation %d\\n\", iocb.aio_lio_opcode);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * If ret is 0, we'd either done aio_complete() ourselves or have\n\t * arranged for that to be done asynchronously.  Anything non-zero\n\t * means that we need to destroy req ourselves.\n\t */\n\tif (ret)\n\t\tgoto out_put_req;\n\treturn 0;\nout_put_req:\n\tput_reqs_available(ctx, 1);\n\tpercpu_ref_put(&ctx->reqs);\n\tif (req->ki_eventfd)\n\t\teventfd_ctx_put(req->ki_eventfd);\n\tkmem_cache_free(kiocb_cachep, req);\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1709-1775",
    "snippet": "static ssize_t aio_poll(struct aio_kiocb *aiocb, struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\n\t/* reject any unknown events outside the normal event mask. */\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\t/* reject fields that are not defined for poll */\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; /* same as no support for IOCB_CMD_POLL */\n\n\t/* initialized the list so that we can do list_empty checks */\n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\n\t/* one for removal from waitqueue, one for this function */\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\t/* we did not manage to set up a waitqueue, done */\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\t/* wake_up context handles the rest */\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\t/* if we get an error or a mask we are done */\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\t/* actually waiting for an event */\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\nout:\n\tif (unlikely(apt.error)) {\n\t\tfput(req->file);\n\t\treturn apt.error;\n\t}\n\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iocb_put",
          "args": [
            "aiocb"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "iocb_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1051-1058",
          "snippet": "static inline void iocb_put(struct aio_kiocb *iocb)\n{\n\tif (refcount_read(&iocb->ki_refcnt) == 0 ||\n\t    refcount_dec_and_test(&iocb->ki_refcnt)) {\n\t\tpercpu_ref_put(&iocb->ki_ctx->reqs);\n\t\tkmem_cache_free(kiocb_cachep, iocb);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*kiocb_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic inline void iocb_put(struct aio_kiocb *iocb)\n{\n\tif (refcount_read(&iocb->ki_refcnt) == 0 ||\n\t    refcount_dec_and_test(&iocb->ki_refcnt)) {\n\t\tpercpu_ref_put(&iocb->ki_ctx->reqs);\n\t\tkmem_cache_free(kiocb_cachep, iocb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_poll_complete",
          "args": [
            "aiocb",
            "mask"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "aio_poll_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1601-1607",
          "snippet": "static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "req->file"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "apt.error"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&req->head->lock"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&aiocb->ki_list",
            "&ctx->active_reqs"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->wait.entry"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&req->wait.entry)"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&req->wait.entry"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&req->head->lock"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req->head"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_poll",
          "args": [
            "req->file",
            "&apt.pt"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&aiocb->ki_refcnt",
            "2"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&req->wait",
            "aio_poll_wake"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&req->wait.entry"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req->file"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "iocb->aio_fildes"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "708-711",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "demangle_poll",
          "args": [
            "iocb->aio_buf"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&req->work",
            "aio_poll_complete_work"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_poll(struct aio_kiocb *aiocb, struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\n\t/* reject any unknown events outside the normal event mask. */\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\t/* reject fields that are not defined for poll */\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; /* same as no support for IOCB_CMD_POLL */\n\n\t/* initialized the list so that we can do list_empty checks */\n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\n\t/* one for removal from waitqueue, one for this function */\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\t/* we did not manage to set up a waitqueue, done */\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\t/* wake_up context handles the rest */\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\t/* if we get an error or a mask we are done */\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\t/* actually waiting for an event */\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\nout:\n\tif (unlikely(apt.error)) {\n\t\tfput(req->file);\n\t\treturn apt.error;\n\t}\n\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_poll_queue_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1692-1707",
    "snippet": "static void\naio_poll_queue_proc(struct file *file, struct wait_queue_head *head,\n\t\tstruct poll_table_struct *p)\n{\n\tstruct aio_poll_table *pt = container_of(p, struct aio_poll_table, pt);\n\n\t/* multiple wait queues per file are not supported */\n\tif (unlikely(pt->iocb->poll.head)) {\n\t\tpt->error = -EINVAL;\n\t\treturn;\n\t}\n\n\tpt->error = 0;\n\tpt->iocb->poll.head = head;\n\tadd_wait_queue(head, &pt->iocb->poll.wait);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "head",
            "&pt->iocb->poll.wait"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pt->iocb->poll.head"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structaio_poll_table",
            "pt"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void\naio_poll_queue_proc(struct file *file, struct wait_queue_head *head,\n\t\tstruct poll_table_struct *p)\n{\n\tstruct aio_poll_table *pt = container_of(p, struct aio_poll_table, pt);\n\n\t/* multiple wait queues per file are not supported */\n\tif (unlikely(pt->iocb->poll.head)) {\n\t\tpt->error = -EINVAL;\n\t\treturn;\n\t}\n\n\tpt->error = 0;\n\tpt->iocb->poll.head = head;\n\tadd_wait_queue(head, &pt->iocb->poll.wait);\n}"
  },
  {
    "function_name": "aio_poll_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1656-1684",
    "snippet": "static int aio_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,\n\t\tvoid *key)\n{\n\tstruct poll_iocb *req = container_of(wait, struct poll_iocb, wait);\n\tstruct aio_kiocb *iocb = container_of(req, struct aio_kiocb, poll);\n\t__poll_t mask = key_to_poll(key);\n\n\treq->woken = true;\n\n\t/* for instances that support it check for an event match first: */\n\tif (mask) {\n\t\tif (!(mask & req->events))\n\t\t\treturn 0;\n\n\t\t/* try to complete the iocb inline if we can: */\n\t\tif (spin_trylock(&iocb->ki_ctx->ctx_lock)) {\n\t\t\tlist_del(&iocb->ki_list);\n\t\t\tspin_unlock(&iocb->ki_ctx->ctx_lock);\n\n\t\t\tlist_del_init(&req->wait.entry);\n\t\t\taio_poll_complete(iocb, mask);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_del_init(&req->wait.entry);\n\tschedule_work(&req->work);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&req->work"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/direct.c",
          "lines": "740-757",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq);",
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq);\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->wait.entry"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_poll_complete",
          "args": [
            "iocb",
            "mask"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "aio_poll_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1601-1607",
          "snippet": "static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->wait.entry"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&iocb->ki_ctx->ctx_lock"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&iocb->ki_list"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&iocb->ki_ctx->ctx_lock"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_to_poll",
          "args": [
            "key"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "req",
            "structaio_kiocb",
            "poll"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structpoll_iocb",
            "wait"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,\n\t\tvoid *key)\n{\n\tstruct poll_iocb *req = container_of(wait, struct poll_iocb, wait);\n\tstruct aio_kiocb *iocb = container_of(req, struct aio_kiocb, poll);\n\t__poll_t mask = key_to_poll(key);\n\n\treq->woken = true;\n\n\t/* for instances that support it check for an event match first: */\n\tif (mask) {\n\t\tif (!(mask & req->events))\n\t\t\treturn 0;\n\n\t\t/* try to complete the iocb inline if we can: */\n\t\tif (spin_trylock(&iocb->ki_ctx->ctx_lock)) {\n\t\t\tlist_del(&iocb->ki_list);\n\t\t\tspin_unlock(&iocb->ki_ctx->ctx_lock);\n\n\t\t\tlist_del_init(&req->wait.entry);\n\t\t\taio_poll_complete(iocb, mask);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_del_init(&req->wait.entry);\n\tschedule_work(&req->work);\n\treturn 1;\n}"
  },
  {
    "function_name": "aio_poll_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1640-1654",
    "snippet": "static int aio_poll_cancel(struct kiocb *iocb)\n{\n\tstruct aio_kiocb *aiocb = container_of(iocb, struct aio_kiocb, rw);\n\tstruct poll_iocb *req = &aiocb->poll;\n\n\tspin_lock(&req->head->lock);\n\tWRITE_ONCE(req->cancelled, true);\n\tif (!list_empty(&req->wait.entry)) {\n\t\tlist_del_init(&req->wait.entry);\n\t\tschedule_work(&aiocb->poll.work);\n\t}\n\tspin_unlock(&req->head->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&req->head->lock"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&aiocb->poll.work"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/direct.c",
          "lines": "740-757",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq);",
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq);\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->wait.entry"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&req->wait.entry"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "req->cancelled",
            "true"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&req->head->lock"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "iocb",
            "structaio_kiocb",
            "rw"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_poll_cancel(struct kiocb *iocb)\n{\n\tstruct aio_kiocb *aiocb = container_of(iocb, struct aio_kiocb, rw);\n\tstruct poll_iocb *req = &aiocb->poll;\n\n\tspin_lock(&req->head->lock);\n\tWRITE_ONCE(req->cancelled, true);\n\tif (!list_empty(&req->wait.entry)) {\n\t\tlist_del_init(&req->wait.entry);\n\t\tschedule_work(&aiocb->poll.work);\n\t}\n\tspin_unlock(&req->head->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_poll_complete_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1609-1637",
    "snippet": "static void aio_poll_complete_work(struct work_struct *work)\n{\n\tstruct poll_iocb *req = container_of(work, struct poll_iocb, work);\n\tstruct aio_kiocb *iocb = container_of(req, struct aio_kiocb, poll);\n\tstruct poll_table_struct pt = { ._key = req->events };\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\t__poll_t mask = 0;\n\n\tif (!READ_ONCE(req->cancelled))\n\t\tmask = vfs_poll(req->file, &pt) & req->events;\n\n\t/*\n\t * Note that ->ki_cancel callers also delete iocb from active_reqs after\n\t * calling ->ki_cancel.  We need the ctx_lock roundtrip here to\n\t * synchronize with them.  In the cancellation case the list_del_init\n\t * itself is not actually needed, but harmless so we keep it in to\n\t * avoid further branches in the fast path.\n\t */\n\tspin_lock_irq(&ctx->ctx_lock);\n\tif (!mask && !READ_ONCE(req->cancelled)) {\n\t\tadd_wait_queue(req->head, &req->wait);\n\t\tspin_unlock_irq(&ctx->ctx_lock);\n\t\treturn;\n\t}\n\tlist_del_init(&iocb->ki_list);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\taio_poll_complete(iocb, mask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aio_poll_complete",
          "args": [
            "iocb",
            "mask"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "aio_poll_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1601-1607",
          "snippet": "static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&iocb->ki_list"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "req->head",
            "&req->wait"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "req->cancelled"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_poll",
          "args": [
            "req->file",
            "&pt"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "req->cancelled"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "req",
            "structaio_kiocb",
            "poll"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structpoll_iocb",
            "work"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_poll_complete_work(struct work_struct *work)\n{\n\tstruct poll_iocb *req = container_of(work, struct poll_iocb, work);\n\tstruct aio_kiocb *iocb = container_of(req, struct aio_kiocb, poll);\n\tstruct poll_table_struct pt = { ._key = req->events };\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\t__poll_t mask = 0;\n\n\tif (!READ_ONCE(req->cancelled))\n\t\tmask = vfs_poll(req->file, &pt) & req->events;\n\n\t/*\n\t * Note that ->ki_cancel callers also delete iocb from active_reqs after\n\t * calling ->ki_cancel.  We need the ctx_lock roundtrip here to\n\t * synchronize with them.  In the cancellation case the list_del_init\n\t * itself is not actually needed, but harmless so we keep it in to\n\t * avoid further branches in the fast path.\n\t */\n\tspin_lock_irq(&ctx->ctx_lock);\n\tif (!mask && !READ_ONCE(req->cancelled)) {\n\t\tadd_wait_queue(req->head, &req->wait);\n\t\tspin_unlock_irq(&ctx->ctx_lock);\n\t\treturn;\n\t}\n\tlist_del_init(&iocb->ki_list);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\taio_poll_complete(iocb, mask);\n}"
  },
  {
    "function_name": "aio_poll_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1601-1607",
    "snippet": "static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_complete",
          "args": [
            "iocb",
            "mangle_poll(mask)",
            "0"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "aio_complete_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1394-1415",
          "snippet": "static void aio_complete_rw(struct kiocb *kiocb, long res, long res2)\n{\n\tstruct aio_kiocb *iocb = container_of(kiocb, struct aio_kiocb, rw);\n\n\tif (!list_empty_careful(&iocb->ki_list))\n\t\taio_remove_iocb(iocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(kiocb->ki_filp);\n\n\t\t/*\n\t\t * Tell lockdep we inherited freeze protection from submission\n\t\t * thread.\n\t\t */\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\t\tfile_end_write(kiocb->ki_filp);\n\t}\n\n\tfput(kiocb->ki_filp);\n\taio_complete(iocb, res, res2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_complete_rw(struct kiocb *kiocb, long res, long res2)\n{\n\tstruct aio_kiocb *iocb = container_of(kiocb, struct aio_kiocb, rw);\n\n\tif (!list_empty_careful(&iocb->ki_list))\n\t\taio_remove_iocb(iocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(kiocb->ki_filp);\n\n\t\t/*\n\t\t * Tell lockdep we inherited freeze protection from submission\n\t\t * thread.\n\t\t */\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\t\tfile_end_write(kiocb->ki_filp);\n\t}\n\n\tfput(kiocb->ki_filp);\n\taio_complete(iocb, res, res2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mangle_poll",
          "args": [
            "mask"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}"
  },
  {
    "function_name": "aio_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1581-1599",
    "snippet": "static int aio_fsync(struct fsync_iocb *req, struct iocb *iocb, bool datasync)\n{\n\tif (unlikely(iocb->aio_buf || iocb->aio_offset || iocb->aio_nbytes ||\n\t\t\tiocb->aio_rw_flags))\n\t\treturn -EINVAL;\n\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\tif (unlikely(!req->file->f_op->fsync)) {\n\t\tfput(req->file);\n\t\treturn -EINVAL;\n\t}\n\n\treq->datasync = datasync;\n\tINIT_WORK(&req->work, aio_fsync_work);\n\tschedule_work(&req->work);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&req->work"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/direct.c",
          "lines": "740-757",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq);",
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq);\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&req->work",
            "aio_fsync_work"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "req->file"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req->file->f_op->fsync"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req->file"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "iocb->aio_fildes"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "708-711",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "iocb->aio_buf || iocb->aio_offset || iocb->aio_nbytes ||\n\t\t\tiocb->aio_rw_flags"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_fsync(struct fsync_iocb *req, struct iocb *iocb, bool datasync)\n{\n\tif (unlikely(iocb->aio_buf || iocb->aio_offset || iocb->aio_nbytes ||\n\t\t\tiocb->aio_rw_flags))\n\t\treturn -EINVAL;\n\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\tif (unlikely(!req->file->f_op->fsync)) {\n\t\tfput(req->file);\n\t\treturn -EINVAL;\n\t}\n\n\treq->datasync = datasync;\n\tINIT_WORK(&req->work, aio_fsync_work);\n\tschedule_work(&req->work);\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_fsync_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1571-1579",
    "snippet": "static void aio_fsync_work(struct work_struct *work)\n{\n\tstruct fsync_iocb *req = container_of(work, struct fsync_iocb, work);\n\tint ret;\n\n\tret = vfs_fsync(req->file, req->datasync);\n\tfput(req->file);\n\taio_complete(container_of(req, struct aio_kiocb, fsync), ret, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "req->file"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "req->file",
            "req->datasync"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "209-212",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structfsync_iocb",
            "work"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_fsync_work(struct work_struct *work)\n{\n\tstruct fsync_iocb *req = container_of(work, struct fsync_iocb, work);\n\tint ret;\n\n\tret = vfs_fsync(req->file, req->datasync);\n\tfput(req->file);\n\taio_complete(container_of(req, struct aio_kiocb, fsync), ret, 0);\n}"
  },
  {
    "function_name": "aio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1525-1569",
    "snippet": "static ssize_t aio_write(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->write_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(WRITE, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(WRITE, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret) {\n\t\t/*\n\t\t * Open-code file_start_write here to grab freeze protection,\n\t\t * which will be released by another thread in\n\t\t * aio_complete_rw().  Fool lockdep by telling it the lock got\n\t\t * released so that it doesn't complain about the held lock when\n\t\t * we return to userspace.\n\t\t */\n\t\tif (S_ISREG(file_inode(file)->i_mode)) {\n\t\t\t__sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);\n\t\t\t__sb_writers_release(file_inode(file)->i_sb, SB_FREEZE_WRITE);\n\t\t}\n\t\treq->ki_flags |= IOCB_WRITE;\n\t\taio_rw_done(req, call_write_iter(file, req, &iter));\n\t}\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iovec"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_rw_done",
          "args": [
            "req",
            "call_write_iter(file, req, &iter)"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "aio_rw_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1472-1490",
          "snippet": "static inline void aio_rw_done(struct kiocb *req, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\taio_complete_rw(req, ret, 0);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void aio_rw_done(struct kiocb *req, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\taio_complete_rw(req, ret, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_write_iter",
          "args": [
            "file",
            "req",
            "&iter"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sb_writers_release",
          "args": [
            "file_inode(file)->i_sb",
            "SB_FREEZE_WRITE"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sb_start_write",
          "args": [
            "file_inode(file)->i_sb",
            "SB_FREEZE_WRITE",
            "true"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "__sb_start_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1361-1393",
          "snippet": "int __sb_start_write(struct super_block *sb, int level, bool wait)\n{\n\tbool force_trylock = false;\n\tint ret = 1;\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * We want lockdep to tell us about possible deadlocks with freezing\n\t * but it's it bit tricky to properly instrument it. Getting a freeze\n\t * protection works as getting a read lock but there are subtle\n\t * problems. XFS for example gets freeze protection on internal level\n\t * twice in some cases, which is OK only because we already hold a\n\t * freeze protection also on higher level. Due to these cases we have\n\t * to use wait == F (trylock mode) which must not fail.\n\t */\n\tif (wait) {\n\t\tint i;\n\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (percpu_rwsem_is_held(sb->s_writers.rw_sem + i)) {\n\t\t\t\tforce_trylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n#endif\n\tif (wait && !force_trylock)\n\t\tpercpu_down_read(sb->s_writers.rw_sem + level-1);\n\telse\n\t\tret = percpu_down_read_trylock(sb->s_writers.rw_sem + level-1);\n\n\tWARN_ON(force_trylock && !ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint __sb_start_write(struct super_block *sb, int level, bool wait)\n{\n\tbool force_trylock = false;\n\tint ret = 1;\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * We want lockdep to tell us about possible deadlocks with freezing\n\t * but it's it bit tricky to properly instrument it. Getting a freeze\n\t * protection works as getting a read lock but there are subtle\n\t * problems. XFS for example gets freeze protection on internal level\n\t * twice in some cases, which is OK only because we already hold a\n\t * freeze protection also on higher level. Due to these cases we have\n\t * to use wait == F (trylock mode) which must not fail.\n\t */\n\tif (wait) {\n\t\tint i;\n\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (percpu_rwsem_is_held(sb->s_writers.rw_sem + i)) {\n\t\t\t\tforce_trylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n#endif\n\tif (wait && !force_trylock)\n\t\tpercpu_down_read(sb->s_writers.rw_sem + level-1);\n\telse\n\t\tret = percpu_down_read_trylock(sb->s_writers.rw_sem + level-1);\n\n\tWARN_ON(force_trylock && !ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "file_inode(file)->i_mode"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "file",
            "&req->ki_pos",
            "iov_iter_count(&iter)"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "&iter"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_setup_rw",
          "args": [
            "WRITE",
            "iocb",
            "&iovec",
            "vectored",
            "compat",
            "&iter"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "aio_setup_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1453-1470",
          "snippet": "static int aio_setup_rw(int rw, struct iocb *iocb, struct iovec **iovec,\n\t\tbool vectored, bool compat, struct iov_iter *iter)\n{\n\tvoid __user *buf = (void __user *)(uintptr_t)iocb->aio_buf;\n\tsize_t len = iocb->aio_nbytes;\n\n\tif (!vectored) {\n\t\tssize_t ret = import_single_range(rw, buf, len, *iovec, iter);\n\t\t*iovec = NULL;\n\t\treturn ret;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\treturn compat_import_iovec(rw, buf, len, UIO_FASTIOV, iovec,\n\t\t\t\titer);\n#endif\n\treturn import_iovec(rw, buf, len, UIO_FASTIOV, iovec, iter);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_setup_rw(int rw, struct iocb *iocb, struct iovec **iovec,\n\t\tbool vectored, bool compat, struct iov_iter *iter)\n{\n\tvoid __user *buf = (void __user *)(uintptr_t)iocb->aio_buf;\n\tsize_t len = iocb->aio_nbytes;\n\n\tif (!vectored) {\n\t\tssize_t ret = import_single_range(rw, buf, len, *iovec, iter);\n\t\t*iovec = NULL;\n\t\treturn ret;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\treturn compat_import_iovec(rw, buf, len, UIO_FASTIOV, iovec,\n\t\t\t\titer);\n#endif\n\treturn import_iovec(rw, buf, len, UIO_FASTIOV, iovec, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!file->f_op->write_iter"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(file->f_mode & FMODE_WRITE)"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_prep_rw",
          "args": [
            "req",
            "iocb"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "aio_prep_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1417-1451",
          "snippet": "static int aio_prep_rw(struct kiocb *req, struct iocb *iocb)\n{\n\tint ret;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp))\n\t\treturn -EBADF;\n\treq->ki_complete = aio_complete_rw;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_flags = iocb_flags(req->ki_filp);\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD)\n\t\treq->ki_flags |= IOCB_EVENTFD;\n\treq->ki_hint = ki_hint_validate(file_write_hint(req->ki_filp));\n\tif (iocb->aio_flags & IOCB_FLAG_IOPRIO) {\n\t\t/*\n\t\t * If the IOCB_FLAG_IOPRIO flag of aio_flags is set, then\n\t\t * aio_reqprio is interpreted as an I/O scheduling\n\t\t * class and priority.\n\t\t */\n\t\tret = ioprio_check_cap(iocb->aio_reqprio);\n\t\tif (ret) {\n\t\t\tpr_debug(\"aio ioprio check cap error: %d\\n\", ret);\n\t\t\tfput(req->ki_filp);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_ioprio = iocb->aio_reqprio;\n\t} else\n\t\treq->ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0);\n\n\tret = kiocb_set_rw_flags(req, iocb->aio_rw_flags);\n\tif (unlikely(ret))\n\t\tfput(req->ki_filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_prep_rw(struct kiocb *req, struct iocb *iocb)\n{\n\tint ret;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp))\n\t\treturn -EBADF;\n\treq->ki_complete = aio_complete_rw;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_flags = iocb_flags(req->ki_filp);\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD)\n\t\treq->ki_flags |= IOCB_EVENTFD;\n\treq->ki_hint = ki_hint_validate(file_write_hint(req->ki_filp));\n\tif (iocb->aio_flags & IOCB_FLAG_IOPRIO) {\n\t\t/*\n\t\t * If the IOCB_FLAG_IOPRIO flag of aio_flags is set, then\n\t\t * aio_reqprio is interpreted as an I/O scheduling\n\t\t * class and priority.\n\t\t */\n\t\tret = ioprio_check_cap(iocb->aio_reqprio);\n\t\tif (ret) {\n\t\t\tpr_debug(\"aio ioprio check cap error: %d\\n\", ret);\n\t\t\tfput(req->ki_filp);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_ioprio = iocb->aio_reqprio;\n\t} else\n\t\treq->ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0);\n\n\tret = kiocb_set_rw_flags(req, iocb->aio_rw_flags);\n\tif (unlikely(ret))\n\t\tfput(req->ki_filp);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_write(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->write_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(WRITE, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(WRITE, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret) {\n\t\t/*\n\t\t * Open-code file_start_write here to grab freeze protection,\n\t\t * which will be released by another thread in\n\t\t * aio_complete_rw().  Fool lockdep by telling it the lock got\n\t\t * released so that it doesn't complain about the held lock when\n\t\t * we return to userspace.\n\t\t */\n\t\tif (S_ISREG(file_inode(file)->i_mode)) {\n\t\t\t__sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);\n\t\t\t__sb_writers_release(file_inode(file)->i_sb, SB_FREEZE_WRITE);\n\t\t}\n\t\treq->ki_flags |= IOCB_WRITE;\n\t\taio_rw_done(req, call_write_iter(file, req, &iter));\n\t}\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1492-1523",
    "snippet": "static ssize_t aio_read(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->read_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(READ, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(READ, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret)\n\t\taio_rw_done(req, call_read_iter(file, req, &iter));\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iovec"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_rw_done",
          "args": [
            "req",
            "call_read_iter(file, req, &iter)"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "aio_rw_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1472-1490",
          "snippet": "static inline void aio_rw_done(struct kiocb *req, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\taio_complete_rw(req, ret, 0);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void aio_rw_done(struct kiocb *req, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\taio_complete_rw(req, ret, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_read_iter",
          "args": [
            "file",
            "req",
            "&iter"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "READ",
            "file",
            "&req->ki_pos",
            "iov_iter_count(&iter)"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "365-393",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "&iter"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_setup_rw",
          "args": [
            "READ",
            "iocb",
            "&iovec",
            "vectored",
            "compat",
            "&iter"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "aio_setup_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1453-1470",
          "snippet": "static int aio_setup_rw(int rw, struct iocb *iocb, struct iovec **iovec,\n\t\tbool vectored, bool compat, struct iov_iter *iter)\n{\n\tvoid __user *buf = (void __user *)(uintptr_t)iocb->aio_buf;\n\tsize_t len = iocb->aio_nbytes;\n\n\tif (!vectored) {\n\t\tssize_t ret = import_single_range(rw, buf, len, *iovec, iter);\n\t\t*iovec = NULL;\n\t\treturn ret;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\treturn compat_import_iovec(rw, buf, len, UIO_FASTIOV, iovec,\n\t\t\t\titer);\n#endif\n\treturn import_iovec(rw, buf, len, UIO_FASTIOV, iovec, iter);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_setup_rw(int rw, struct iocb *iocb, struct iovec **iovec,\n\t\tbool vectored, bool compat, struct iov_iter *iter)\n{\n\tvoid __user *buf = (void __user *)(uintptr_t)iocb->aio_buf;\n\tsize_t len = iocb->aio_nbytes;\n\n\tif (!vectored) {\n\t\tssize_t ret = import_single_range(rw, buf, len, *iovec, iter);\n\t\t*iovec = NULL;\n\t\treturn ret;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\treturn compat_import_iovec(rw, buf, len, UIO_FASTIOV, iovec,\n\t\t\t\titer);\n#endif\n\treturn import_iovec(rw, buf, len, UIO_FASTIOV, iovec, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!file->f_op->read_iter"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(file->f_mode & FMODE_READ)"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_prep_rw",
          "args": [
            "req",
            "iocb"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "aio_prep_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1417-1451",
          "snippet": "static int aio_prep_rw(struct kiocb *req, struct iocb *iocb)\n{\n\tint ret;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp))\n\t\treturn -EBADF;\n\treq->ki_complete = aio_complete_rw;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_flags = iocb_flags(req->ki_filp);\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD)\n\t\treq->ki_flags |= IOCB_EVENTFD;\n\treq->ki_hint = ki_hint_validate(file_write_hint(req->ki_filp));\n\tif (iocb->aio_flags & IOCB_FLAG_IOPRIO) {\n\t\t/*\n\t\t * If the IOCB_FLAG_IOPRIO flag of aio_flags is set, then\n\t\t * aio_reqprio is interpreted as an I/O scheduling\n\t\t * class and priority.\n\t\t */\n\t\tret = ioprio_check_cap(iocb->aio_reqprio);\n\t\tif (ret) {\n\t\t\tpr_debug(\"aio ioprio check cap error: %d\\n\", ret);\n\t\t\tfput(req->ki_filp);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_ioprio = iocb->aio_reqprio;\n\t} else\n\t\treq->ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0);\n\n\tret = kiocb_set_rw_flags(req, iocb->aio_rw_flags);\n\tif (unlikely(ret))\n\t\tfput(req->ki_filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_prep_rw(struct kiocb *req, struct iocb *iocb)\n{\n\tint ret;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp))\n\t\treturn -EBADF;\n\treq->ki_complete = aio_complete_rw;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_flags = iocb_flags(req->ki_filp);\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD)\n\t\treq->ki_flags |= IOCB_EVENTFD;\n\treq->ki_hint = ki_hint_validate(file_write_hint(req->ki_filp));\n\tif (iocb->aio_flags & IOCB_FLAG_IOPRIO) {\n\t\t/*\n\t\t * If the IOCB_FLAG_IOPRIO flag of aio_flags is set, then\n\t\t * aio_reqprio is interpreted as an I/O scheduling\n\t\t * class and priority.\n\t\t */\n\t\tret = ioprio_check_cap(iocb->aio_reqprio);\n\t\tif (ret) {\n\t\t\tpr_debug(\"aio ioprio check cap error: %d\\n\", ret);\n\t\t\tfput(req->ki_filp);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_ioprio = iocb->aio_reqprio;\n\t} else\n\t\treq->ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0);\n\n\tret = kiocb_set_rw_flags(req, iocb->aio_rw_flags);\n\tif (unlikely(ret))\n\t\tfput(req->ki_filp);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic ssize_t aio_read(struct kiocb *req, struct iocb *iocb, bool vectored,\n\t\tbool compat)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct iov_iter iter;\n\tstruct file *file;\n\tssize_t ret;\n\n\tret = aio_prep_rw(req, iocb);\n\tif (ret)\n\t\treturn ret;\n\tfile = req->ki_filp;\n\n\tret = -EBADF;\n\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\tgoto out_fput;\n\tret = -EINVAL;\n\tif (unlikely(!file->f_op->read_iter))\n\t\tgoto out_fput;\n\n\tret = aio_setup_rw(READ, iocb, &iovec, vectored, compat, &iter);\n\tif (ret)\n\t\tgoto out_fput;\n\tret = rw_verify_area(READ, file, &req->ki_pos, iov_iter_count(&iter));\n\tif (!ret)\n\t\taio_rw_done(req, call_read_iter(file, req, &iter));\n\tkfree(iovec);\nout_fput:\n\tif (unlikely(ret))\n\t\tfput(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_rw_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1472-1490",
    "snippet": "static inline void aio_rw_done(struct kiocb *req, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\taio_complete_rw(req, ret, 0);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aio_complete_rw",
          "args": [
            "req",
            "ret",
            "0"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "aio_complete_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1394-1415",
          "snippet": "static void aio_complete_rw(struct kiocb *kiocb, long res, long res2)\n{\n\tstruct aio_kiocb *iocb = container_of(kiocb, struct aio_kiocb, rw);\n\n\tif (!list_empty_careful(&iocb->ki_list))\n\t\taio_remove_iocb(iocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(kiocb->ki_filp);\n\n\t\t/*\n\t\t * Tell lockdep we inherited freeze protection from submission\n\t\t * thread.\n\t\t */\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\t\tfile_end_write(kiocb->ki_filp);\n\t}\n\n\tfput(kiocb->ki_filp);\n\taio_complete(iocb, res, res2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_complete_rw(struct kiocb *kiocb, long res, long res2)\n{\n\tstruct aio_kiocb *iocb = container_of(kiocb, struct aio_kiocb, rw);\n\n\tif (!list_empty_careful(&iocb->ki_list))\n\t\taio_remove_iocb(iocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(kiocb->ki_filp);\n\n\t\t/*\n\t\t * Tell lockdep we inherited freeze protection from submission\n\t\t * thread.\n\t\t */\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\t\tfile_end_write(kiocb->ki_filp);\n\t}\n\n\tfput(kiocb->ki_filp);\n\taio_complete(iocb, res, res2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void aio_rw_done(struct kiocb *req, ssize_t ret)\n{\n\tswitch (ret) {\n\tcase -EIOCBQUEUED:\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\tcase -ERESTARTNOINTR:\n\tcase -ERESTARTNOHAND:\n\tcase -ERESTART_RESTARTBLOCK:\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tret = -EINTR;\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\taio_complete_rw(req, ret, 0);\n\t}\n}"
  },
  {
    "function_name": "aio_setup_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1453-1470",
    "snippet": "static int aio_setup_rw(int rw, struct iocb *iocb, struct iovec **iovec,\n\t\tbool vectored, bool compat, struct iov_iter *iter)\n{\n\tvoid __user *buf = (void __user *)(uintptr_t)iocb->aio_buf;\n\tsize_t len = iocb->aio_nbytes;\n\n\tif (!vectored) {\n\t\tssize_t ret = import_single_range(rw, buf, len, *iovec, iter);\n\t\t*iovec = NULL;\n\t\treturn ret;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\treturn compat_import_iovec(rw, buf, len, UIO_FASTIOV, iovec,\n\t\t\t\titer);\n#endif\n\treturn import_iovec(rw, buf, len, UIO_FASTIOV, iovec, iter);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "import_iovec",
          "args": [
            "rw",
            "buf",
            "len",
            "UIO_FASTIOV",
            "iovec",
            "iter"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_import_iovec",
          "args": [
            "rw",
            "buf",
            "len",
            "UIO_FASTIOV",
            "iovec",
            "iter"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "import_single_range",
          "args": [
            "rw",
            "buf",
            "len",
            "*iovec",
            "iter"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_setup_rw(int rw, struct iocb *iocb, struct iovec **iovec,\n\t\tbool vectored, bool compat, struct iov_iter *iter)\n{\n\tvoid __user *buf = (void __user *)(uintptr_t)iocb->aio_buf;\n\tsize_t len = iocb->aio_nbytes;\n\n\tif (!vectored) {\n\t\tssize_t ret = import_single_range(rw, buf, len, *iovec, iter);\n\t\t*iovec = NULL;\n\t\treturn ret;\n\t}\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\treturn compat_import_iovec(rw, buf, len, UIO_FASTIOV, iovec,\n\t\t\t\titer);\n#endif\n\treturn import_iovec(rw, buf, len, UIO_FASTIOV, iovec, iter);\n}"
  },
  {
    "function_name": "aio_prep_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1417-1451",
    "snippet": "static int aio_prep_rw(struct kiocb *req, struct iocb *iocb)\n{\n\tint ret;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp))\n\t\treturn -EBADF;\n\treq->ki_complete = aio_complete_rw;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_flags = iocb_flags(req->ki_filp);\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD)\n\t\treq->ki_flags |= IOCB_EVENTFD;\n\treq->ki_hint = ki_hint_validate(file_write_hint(req->ki_filp));\n\tif (iocb->aio_flags & IOCB_FLAG_IOPRIO) {\n\t\t/*\n\t\t * If the IOCB_FLAG_IOPRIO flag of aio_flags is set, then\n\t\t * aio_reqprio is interpreted as an I/O scheduling\n\t\t * class and priority.\n\t\t */\n\t\tret = ioprio_check_cap(iocb->aio_reqprio);\n\t\tif (ret) {\n\t\t\tpr_debug(\"aio ioprio check cap error: %d\\n\", ret);\n\t\t\tfput(req->ki_filp);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_ioprio = iocb->aio_reqprio;\n\t} else\n\t\treq->ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0);\n\n\tret = kiocb_set_rw_flags(req, iocb->aio_rw_flags);\n\tif (unlikely(ret))\n\t\tfput(req->ki_filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "req->ki_filp"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kiocb_set_rw_flags",
          "args": [
            "req",
            "iocb->aio_rw_flags"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOPRIO_PRIO_VALUE",
          "args": [
            "IOPRIO_CLASS_NONE",
            "0"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"aio ioprio check cap error: %d\\n\"",
            "ret"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioprio_check_cap",
          "args": [
            "iocb->aio_reqprio"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ki_hint_validate",
          "args": [
            "file_write_hint(req->ki_filp)"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_write_hint",
          "args": [
            "req->ki_filp"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iocb_flags",
          "args": [
            "req->ki_filp"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req->ki_filp"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "iocb->aio_fildes"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "708-711",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_prep_rw(struct kiocb *req, struct iocb *iocb)\n{\n\tint ret;\n\n\treq->ki_filp = fget(iocb->aio_fildes);\n\tif (unlikely(!req->ki_filp))\n\t\treturn -EBADF;\n\treq->ki_complete = aio_complete_rw;\n\treq->ki_pos = iocb->aio_offset;\n\treq->ki_flags = iocb_flags(req->ki_filp);\n\tif (iocb->aio_flags & IOCB_FLAG_RESFD)\n\t\treq->ki_flags |= IOCB_EVENTFD;\n\treq->ki_hint = ki_hint_validate(file_write_hint(req->ki_filp));\n\tif (iocb->aio_flags & IOCB_FLAG_IOPRIO) {\n\t\t/*\n\t\t * If the IOCB_FLAG_IOPRIO flag of aio_flags is set, then\n\t\t * aio_reqprio is interpreted as an I/O scheduling\n\t\t * class and priority.\n\t\t */\n\t\tret = ioprio_check_cap(iocb->aio_reqprio);\n\t\tif (ret) {\n\t\t\tpr_debug(\"aio ioprio check cap error: %d\\n\", ret);\n\t\t\tfput(req->ki_filp);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_ioprio = iocb->aio_reqprio;\n\t} else\n\t\treq->ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0);\n\n\tret = kiocb_set_rw_flags(req, iocb->aio_rw_flags);\n\tif (unlikely(ret))\n\t\tfput(req->ki_filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_complete_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1394-1415",
    "snippet": "static void aio_complete_rw(struct kiocb *kiocb, long res, long res2)\n{\n\tstruct aio_kiocb *iocb = container_of(kiocb, struct aio_kiocb, rw);\n\n\tif (!list_empty_careful(&iocb->ki_list))\n\t\taio_remove_iocb(iocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(kiocb->ki_filp);\n\n\t\t/*\n\t\t * Tell lockdep we inherited freeze protection from submission\n\t\t * thread.\n\t\t */\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\t\tfile_end_write(kiocb->ki_filp);\n\t}\n\n\tfput(kiocb->ki_filp);\n\taio_complete(iocb, res, res2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aio_complete",
          "args": [
            "iocb",
            "res",
            "res2"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "aio_complete_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1394-1415",
          "snippet": "static void aio_complete_rw(struct kiocb *kiocb, long res, long res2)\n{\n\tstruct aio_kiocb *iocb = container_of(kiocb, struct aio_kiocb, rw);\n\n\tif (!list_empty_careful(&iocb->ki_list))\n\t\taio_remove_iocb(iocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(kiocb->ki_filp);\n\n\t\t/*\n\t\t * Tell lockdep we inherited freeze protection from submission\n\t\t * thread.\n\t\t */\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\t\tfile_end_write(kiocb->ki_filp);\n\t}\n\n\tfput(kiocb->ki_filp);\n\taio_complete(iocb, res, res2);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "kiocb->ki_filp"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "kiocb->ki_filp"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sb_writers_acquired",
          "args": [
            "inode->i_sb",
            "SB_FREEZE_WRITE"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "kiocb->ki_filp"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aio_remove_iocb",
          "args": [
            "iocb"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "aio_remove_iocb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1384-1392",
          "snippet": "static void aio_remove_iocb(struct aio_kiocb *iocb)\n{\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\tlist_del(&iocb->ki_list);\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_remove_iocb(struct aio_kiocb *iocb)\n{\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\tlist_del(&iocb->ki_list);\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&iocb->ki_list"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kiocb",
            "structaio_kiocb",
            "rw"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_complete_rw(struct kiocb *kiocb, long res, long res2)\n{\n\tstruct aio_kiocb *iocb = container_of(kiocb, struct aio_kiocb, rw);\n\n\tif (!list_empty_careful(&iocb->ki_list))\n\t\taio_remove_iocb(iocb);\n\n\tif (kiocb->ki_flags & IOCB_WRITE) {\n\t\tstruct inode *inode = file_inode(kiocb->ki_filp);\n\n\t\t/*\n\t\t * Tell lockdep we inherited freeze protection from submission\n\t\t * thread.\n\t\t */\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\t__sb_writers_acquired(inode->i_sb, SB_FREEZE_WRITE);\n\t\tfile_end_write(kiocb->ki_filp);\n\t}\n\n\tfput(kiocb->ki_filp);\n\taio_complete(iocb, res, res2);\n}"
  },
  {
    "function_name": "aio_remove_iocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1384-1392",
    "snippet": "static void aio_remove_iocb(struct aio_kiocb *iocb)\n{\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\tlist_del(&iocb->ki_list);\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&iocb->ki_list"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_remove_iocb(struct aio_kiocb *iocb)\n{\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\tlist_del(&iocb->ki_list);\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}"
  },
  {
    "function_name": "read_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1243-1270",
    "snippet": "static long read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\tstruct io_event __user *event,\n\t\t\tktime_t until)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Note that aio_read_events() is being called as the conditional - i.e.\n\t * we're calling it after prepare_to_wait() has set task state to\n\t * TASK_INTERRUPTIBLE.\n\t *\n\t * But aio_read_events() can block, and if it blocks it's going to flip\n\t * the task state back to TASK_RUNNING.\n\t *\n\t * This should be ok, provided it doesn't flip the state back to\n\t * TASK_RUNNING and return 0 too much - that causes us to spin. That\n\t * will only happen if the mutex_lock() call blocks, and we then find\n\t * the ringbuffer empty. So in practice we should be ok, but it's\n\t * something to be aware of when touching this code.\n\t */\n\tif (until == 0)\n\t\taio_read_events(ctx, min_nr, nr, event, &ret);\n\telse\n\t\twait_event_interruptible_hrtimeout(ctx->wait,\n\t\t\t\taio_read_events(ctx, min_nr, nr, event, &ret),\n\t\t\t\tuntil);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_interruptible_hrtimeout",
          "args": [
            "ctx->wait",
            "aio_read_events(ctx, min_nr, nr, event, &ret)",
            "until"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_read_events",
          "args": [
            "ctx",
            "min_nr",
            "nr",
            "event",
            "&ret"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "aio_read_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1226-1241",
          "snippet": "static bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic long read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\tstruct io_event __user *event,\n\t\t\tktime_t until)\n{\n\tlong ret = 0;\n\n\t/*\n\t * Note that aio_read_events() is being called as the conditional - i.e.\n\t * we're calling it after prepare_to_wait() has set task state to\n\t * TASK_INTERRUPTIBLE.\n\t *\n\t * But aio_read_events() can block, and if it blocks it's going to flip\n\t * the task state back to TASK_RUNNING.\n\t *\n\t * This should be ok, provided it doesn't flip the state back to\n\t * TASK_RUNNING and return 0 too much - that causes us to spin. That\n\t * will only happen if the mutex_lock() call blocks, and we then find\n\t * the ringbuffer empty. So in practice we should be ok, but it's\n\t * something to be aware of when touching this code.\n\t */\n\tif (until == 0)\n\t\taio_read_events(ctx, min_nr, nr, event, &ret);\n\telse\n\t\twait_event_interruptible_hrtimeout(ctx->wait,\n\t\t\t\taio_read_events(ctx, min_nr, nr, event, &ret),\n\t\t\t\tuntil);\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_read_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1226-1241",
    "snippet": "static bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&ctx->dead)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ctx->dead"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_read_events_ring",
          "args": [
            "ctx",
            "event + *i",
            "nr - *i"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "aio_read_events_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1146-1224",
          "snippet": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE - pos);\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)",
            "#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)\n#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))\n\nstatic long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE - pos);\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool aio_read_events(struct kioctx *ctx, long min_nr, long nr,\n\t\t\t    struct io_event __user *event, long *i)\n{\n\tlong ret = aio_read_events_ring(ctx, event + *i, nr - *i);\n\n\tif (ret > 0)\n\t\t*i += ret;\n\n\tif (unlikely(atomic_read(&ctx->dead)))\n\t\tret = -EINVAL;\n\n\tif (!*i)\n\t\t*i = ret;\n\n\treturn ret < 0 || *i >= min_nr;\n}"
  },
  {
    "function_name": "aio_read_events_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1146-1224",
    "snippet": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE - pos);\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)",
      "#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%li  h%u t%u\\n\"",
            "ret",
            "head",
            "tail"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copy_ret"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "event + ret",
            "ev + pos",
            "sizeof(*ev) * avail"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "avail",
            "AIO_EVENTS_PER_PAGE - pos"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "avail",
            "nr - ret"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"h%u t%u m%u\\n\"",
            "head",
            "tail",
            "ctx->nr_events"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)\n#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))\n\nstatic long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\t/*\n\t * The mutex can block and wake us up and that will cause\n\t * wait_event_interruptible_hrtimeout() to schedule without sleeping\n\t * and repeat. This should be rare enough that it doesn't cause\n\t * peformance issues. See the comment in read_events() for more detail.\n\t */\n\tsched_annotate_sleep();\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\t/*\n\t * Ensure that once we've read the current tail pointer, that\n\t * we also see the events that were stored up to the tail.\n\t */\n\tsmp_rmb();\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE - pos);\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1063-1140",
    "snippet": "static void aio_complete(struct aio_kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\n\t/*\n\t * Add a completion event to the ring buffer. Must be done holding\n\t * ctx->completion_lock to prevent other code from messing with the tail\n\t * pointer since we might be called from irq context.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\n\tevent->obj = (u64)(unsigned long)iocb->ki_user_iocb;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_user_iocb, iocb->ki_user_data,\n\t\t res, res2);\n\n\t/* after flagging the request as done, we\n\t * must never even look at it again\n\t */\n\tsmp_wmb();\t/* make event visible before updating tail */\n\n\tctx->tail = tail;\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\n\t/*\n\t * Check if the user asked us to deliver the result through an\n\t * eventfd. The eventfd_signal() function is safe to be called\n\t * from IRQ context.\n\t */\n\tif (iocb->ki_eventfd) {\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\t\teventfd_ctx_put(iocb->ki_eventfd);\n\t}\n\n\t/*\n\t * We have to order our ring_info tail store above and test\n\t * of the wait list below outside the wait lock.  This is\n\t * like in wake_up_bit() where clearing a bit has to be\n\t * ordered with the unlocked test.\n\t */\n\tsmp_mb();\n\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\tiocb_put(iocb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)",
      "#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iocb_put",
          "args": [
            "iocb"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "iocb_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1051-1058",
          "snippet": "static inline void iocb_put(struct aio_kiocb *iocb)\n{\n\tif (refcount_read(&iocb->ki_refcnt) == 0 ||\n\t    refcount_dec_and_test(&iocb->ki_refcnt)) {\n\t\tpercpu_ref_put(&iocb->ki_ctx->reqs);\n\t\tkmem_cache_free(kiocb_cachep, iocb);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*kiocb_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic inline void iocb_put(struct aio_kiocb *iocb)\n{\n\tif (refcount_read(&iocb->ki_refcnt) == 0 ||\n\t    refcount_dec_and_test(&iocb->ki_refcnt)) {\n\t\tpercpu_ref_put(&iocb->ki_ctx->reqs);\n\t\tkmem_cache_free(kiocb_cachep, iocb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&ctx->wait"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ctx->wait"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "iocb->ki_eventfd"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_ctx_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "89-92",
          "snippet": "void eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\n{\n\tkref_put(&ctx->kref, eventfd_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "iocb->ki_eventfd",
            "1"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "eventfd_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventfd.c",
          "lines": "54-67",
          "snippet": "__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/kref.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/eventfd.h>\n#include <linux/kref.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/anon_inodes.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n\n__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ULLONG_MAX - ctx->count < n)\n\t\tn = ULLONG_MAX - ctx->count;\n\tctx->count += n;\n\tif (waitqueue_active(&ctx->wqh))\n\t\twake_up_locked_poll(&ctx->wqh, EPOLLIN);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"added to ring %p at [%u]\\n\"",
            "iocb",
            "tail"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refill_reqs_available",
          "args": [
            "ctx",
            "head",
            "tail"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "refill_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "941-964",
          "snippet": "static void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%p[%u]: %p: %p %Lx %lx %lx\\n\"",
            "ctx",
            "tail",
            "iocb",
            "iocb->ki_user_iocb",
            "iocb->ki_user_data",
            "res",
            "res2"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ev_page"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_EVENTS_OFFSET\t(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)\n#define AIO_EVENTS_PER_PAGE\t(PAGE_SIZE / sizeof(struct io_event))\n\nstatic void aio_complete(struct aio_kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\n\t/*\n\t * Add a completion event to the ring buffer. Must be done holding\n\t * ctx->completion_lock to prevent other code from messing with the tail\n\t * pointer since we might be called from irq context.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\n\tevent->obj = (u64)(unsigned long)iocb->ki_user_iocb;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_user_iocb, iocb->ki_user_data,\n\t\t res, res2);\n\n\t/* after flagging the request as done, we\n\t * must never even look at it again\n\t */\n\tsmp_wmb();\t/* make event visible before updating tail */\n\n\tctx->tail = tail;\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\n\t/*\n\t * Check if the user asked us to deliver the result through an\n\t * eventfd. The eventfd_signal() function is safe to be called\n\t * from IRQ context.\n\t */\n\tif (iocb->ki_eventfd) {\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\t\teventfd_ctx_put(iocb->ki_eventfd);\n\t}\n\n\t/*\n\t * We have to order our ring_info tail store above and test\n\t * of the wait list below outside the wait lock.  This is\n\t * like in wake_up_bit() where clearing a bit has to be\n\t * ordered with the unlocked test.\n\t */\n\tsmp_mb();\n\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\tiocb_put(iocb);\n}"
  },
  {
    "function_name": "iocb_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1051-1058",
    "snippet": "static inline void iocb_put(struct aio_kiocb *iocb)\n{\n\tif (refcount_read(&iocb->ki_refcnt) == 0 ||\n\t    refcount_dec_and_test(&iocb->ki_refcnt)) {\n\t\tpercpu_ref_put(&iocb->ki_ctx->reqs);\n\t\tkmem_cache_free(kiocb_cachep, iocb);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kiocb_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kiocb_cachep",
            "iocb"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&iocb->ki_ctx->reqs"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&iocb->ki_refcnt"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&iocb->ki_refcnt"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic inline void iocb_put(struct aio_kiocb *iocb)\n{\n\tif (refcount_read(&iocb->ki_refcnt) == 0 ||\n\t    refcount_dec_and_test(&iocb->ki_refcnt)) {\n\t\tpercpu_ref_put(&iocb->ki_ctx->reqs);\n\t\tkmem_cache_free(kiocb_cachep, iocb);\n\t}\n}"
  },
  {
    "function_name": "lookup_ioctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1024-1049",
    "snippet": "static struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = rcu_dereference(table->table[id]);\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tif (percpu_ref_tryget_live(&ctx->users))\n\t\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_tryget_live",
          "args": [
            "&ctx->users"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "table->table[id]"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "id",
            "&ring->id"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kioctx *lookup_ioctx(unsigned long ctx_id)\n{\n\tstruct aio_ring __user *ring  = (void __user *)ctx_id;\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx, *ret = NULL;\n\tstruct kioctx_table *table;\n\tunsigned id;\n\n\tif (get_user(id, &ring->id))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tif (!table || id >= table->nr)\n\t\tgoto out;\n\n\tctx = rcu_dereference(table->table[id]);\n\tif (ctx && ctx->user_id == ctx_id) {\n\t\tif (percpu_ref_tryget_live(&ctx->users))\n\t\t\tret = ctx;\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "aio_get_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1000-1022",
    "snippet": "static inline struct aio_kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct aio_kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\tINIT_LIST_HEAD(&req->ki_list);\n\trefcount_set(&req->ki_refcnt, 0);\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kiocb_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_reqs_available",
          "args": [
            "ctx",
            "1"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "put_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "887-902",
          "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&req->ki_refcnt",
            "0"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&req->ki_list"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&ctx->reqs"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!req"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "kiocb_cachep",
            "GFP_KERNEL|__GFP_ZERO"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_reqs_available",
          "args": [
            "ctx"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "get_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "904-932",
          "snippet": "static bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_refill_reqs_available",
          "args": [
            "ctx"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "user_refill_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "970-994",
          "snippet": "static void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\n\nstatic inline struct aio_kiocb *aio_get_req(struct kioctx *ctx)\n{\n\tstruct aio_kiocb *req;\n\n\tif (!get_reqs_available(ctx)) {\n\t\tuser_refill_reqs_available(ctx);\n\t\tif (!get_reqs_available(ctx))\n\t\t\treturn NULL;\n\t}\n\n\treq = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);\n\tif (unlikely(!req))\n\t\tgoto out_put;\n\n\tpercpu_ref_get(&ctx->reqs);\n\tINIT_LIST_HEAD(&req->ki_list);\n\trefcount_set(&req->ki_refcnt, 0);\n\treq->ki_ctx = ctx;\n\treturn req;\nout_put:\n\tput_reqs_available(ctx, 1);\n\treturn NULL;\n}"
  },
  {
    "function_name": "user_refill_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "970-994",
    "snippet": "static void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->completion_lock"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refill_reqs_available",
          "args": [
            "ctx",
            "head",
            "ctx->tail"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "refill_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "941-964",
          "snippet": "static void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->completion_lock"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void user_refill_reqs_available(struct kioctx *ctx)\n{\n\tspin_lock_irq(&ctx->completion_lock);\n\tif (ctx->completed_events) {\n\t\tstruct aio_ring *ring;\n\t\tunsigned head;\n\n\t\t/* Access of ring->head may race with aio_read_events_ring()\n\t\t * here, but that's okay since whether we read the old version\n\t\t * or the new version, and either will be valid.  The important\n\t\t * part is that head cannot pass tail since we prevent\n\t\t * aio_complete() from updating tail by holding\n\t\t * ctx->completion_lock.  Even if head is invalid, the check\n\t\t * against ctx->completed_events below will make sure we do the\n\t\t * safe/right thing.\n\t\t */\n\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\thead = ring->head;\n\t\tkunmap_atomic(ring);\n\n\t\trefill_reqs_available(ctx, head, ctx->tail);\n\t}\n\n\tspin_unlock_irq(&ctx->completion_lock);\n}"
  },
  {
    "function_name": "refill_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "941-964",
    "snippet": "static void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_reqs_available",
          "args": [
            "ctx",
            "completed"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "put_reqs_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "887-902",
          "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void refill_reqs_available(struct kioctx *ctx, unsigned head,\n                                  unsigned tail)\n{\n\tunsigned events_in_ring, completed;\n\n\t/* Clamp head since userland can write to it. */\n\thead %= ctx->nr_events;\n\tif (head <= tail)\n\t\tevents_in_ring = tail - head;\n\telse\n\t\tevents_in_ring = ctx->nr_events - (head - tail);\n\n\tcompleted = ctx->completed_events;\n\tif (events_in_ring < completed)\n\t\tcompleted -= events_in_ring;\n\telse\n\t\tcompleted = 0;\n\n\tif (!completed)\n\t\treturn;\n\n\tctx->completed_events -= completed;\n\tput_reqs_available(ctx, completed);\n}"
  },
  {
    "function_name": "get_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "904-932",
    "snippet": "static bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&ctx->reqs_available",
            "avail",
            "avail - ctx->req_batch"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ctx->reqs_available"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "ctx->cpu"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic bool get_reqs_available(struct kioctx *ctx)\n{\n\tstruct kioctx_cpu *kcpu;\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tif (!kcpu->reqs_available) {\n\t\tint old, avail = atomic_read(&ctx->reqs_available);\n\n\t\tdo {\n\t\t\tif (avail < ctx->req_batch)\n\t\t\t\tgoto out;\n\n\t\t\told = avail;\n\t\t\tavail = atomic_cmpxchg(&ctx->reqs_available,\n\t\t\t\t\t       avail, avail - ctx->req_batch);\n\t\t} while (avail != old);\n\n\t\tkcpu->reqs_available += ctx->req_batch;\n\t}\n\n\tret = true;\n\tkcpu->reqs_available--;\nout:\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "put_reqs_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "887-902",
    "snippet": "static void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "ctx->req_batch",
            "&ctx->reqs_available"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "ctx->cpu"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_reqs_available(struct kioctx *ctx, unsigned nr)\n{\n\tstruct kioctx_cpu *kcpu;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tkcpu = this_cpu_ptr(ctx->cpu);\n\tkcpu->reqs_available += nr;\n\n\twhile (kcpu->reqs_available >= ctx->req_batch * 2) {\n\t\tkcpu->reqs_available -= ctx->req_batch;\n\t\tatomic_add(ctx->req_batch, &ctx->reqs_available);\n\t}\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "exit_aio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "845-885",
    "snippet": "void exit_aio(struct mm_struct *mm)\n{\n\tstruct kioctx_table *table = rcu_dereference_raw(mm->ioctx_table);\n\tstruct ctx_rq_wait wait;\n\tint i, skipped;\n\n\tif (!table)\n\t\treturn;\n\n\tatomic_set(&wait.count, table->nr);\n\tinit_completion(&wait.comp);\n\n\tskipped = 0;\n\tfor (i = 0; i < table->nr; ++i) {\n\t\tstruct kioctx *ctx =\n\t\t\trcu_dereference_protected(table->table[i], true);\n\n\t\tif (!ctx) {\n\t\t\tskipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We don't need to bother with munmap() here - exit_mmap(mm)\n\t\t * is coming and it'll unmap everything. And we simply can't,\n\t\t * this is not necessarily our ->mm.\n\t\t * Since kill_ioctx() uses non-zero ->mmap_size as indicator\n\t\t * that it needs to unmap the area, just set it to 0.\n\t\t */\n\t\tctx->mmap_size = 0;\n\t\tkill_ioctx(mm, ctx, &wait);\n\t}\n\n\tif (!atomic_sub_and_test(skipped, &wait.count)) {\n\t\t/* Wait until all IO for the context are done. */\n\t\twait_for_completion(&wait.comp);\n\t}\n\n\tRCU_INIT_POINTER(mm->ioctx_table, NULL);\n\tkfree(table);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "mm->ioctx_table",
            "NULL"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&wait.comp"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub_and_test",
          "args": [
            "skipped",
            "&wait.count"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_ioctx",
          "args": [
            "mm",
            "ctx",
            "&wait"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "kill_ioctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "801-835",
          "snippet": "static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\t      struct ctx_rq_wait *wait)\n{\n\tstruct kioctx_table *table;\n\n\tspin_lock(&mm->ioctx_lock);\n\tif (atomic_xchg(&ctx->dead, 1)) {\n\t\tspin_unlock(&mm->ioctx_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != rcu_access_pointer(table->table[ctx->id]));\n\tRCU_INIT_POINTER(table->table[ctx->id], NULL);\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* free_ioctx_reqs() will do the necessary RCU synchronization */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->rq_wait = wait;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\t      struct ctx_rq_wait *wait)\n{\n\tstruct kioctx_table *table;\n\n\tspin_lock(&mm->ioctx_lock);\n\tif (atomic_xchg(&ctx->dead, 1)) {\n\t\tspin_unlock(&mm->ioctx_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != rcu_access_pointer(table->table[ctx->id]));\n\tRCU_INIT_POINTER(table->table[ctx->id], NULL);\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* free_ioctx_reqs() will do the necessary RCU synchronization */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->rq_wait = wait;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "table->table[i]",
            "true"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&wait.comp"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wait.count",
            "table->nr"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid exit_aio(struct mm_struct *mm)\n{\n\tstruct kioctx_table *table = rcu_dereference_raw(mm->ioctx_table);\n\tstruct ctx_rq_wait wait;\n\tint i, skipped;\n\n\tif (!table)\n\t\treturn;\n\n\tatomic_set(&wait.count, table->nr);\n\tinit_completion(&wait.comp);\n\n\tskipped = 0;\n\tfor (i = 0; i < table->nr; ++i) {\n\t\tstruct kioctx *ctx =\n\t\t\trcu_dereference_protected(table->table[i], true);\n\n\t\tif (!ctx) {\n\t\t\tskipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We don't need to bother with munmap() here - exit_mmap(mm)\n\t\t * is coming and it'll unmap everything. And we simply can't,\n\t\t * this is not necessarily our ->mm.\n\t\t * Since kill_ioctx() uses non-zero ->mmap_size as indicator\n\t\t * that it needs to unmap the area, just set it to 0.\n\t\t */\n\t\tctx->mmap_size = 0;\n\t\tkill_ioctx(mm, ctx, &wait);\n\t}\n\n\tif (!atomic_sub_and_test(skipped, &wait.count)) {\n\t\t/* Wait until all IO for the context are done. */\n\t\twait_for_completion(&wait.comp);\n\t}\n\n\tRCU_INIT_POINTER(mm->ioctx_table, NULL);\n\tkfree(table);\n}"
  },
  {
    "function_name": "kill_ioctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "801-835",
    "snippet": "static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\t      struct ctx_rq_wait *wait)\n{\n\tstruct kioctx_table *table;\n\n\tspin_lock(&mm->ioctx_lock);\n\tif (atomic_xchg(&ctx->dead, 1)) {\n\t\tspin_unlock(&mm->ioctx_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != rcu_access_pointer(table->table[ctx->id]));\n\tRCU_INIT_POINTER(table->table[ctx->id], NULL);\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* free_ioctx_reqs() will do the necessary RCU synchronization */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->rq_wait = wait;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&ctx->users"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "ctx->mmap_base",
            "ctx->mmap_size"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_nr_sub",
          "args": [
            "ctx->max_reqs"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "aio_nr_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "673-681",
          "snippet": "static void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(aio_nr_lock);",
            "unsigned long aio_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\n\nstatic void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ctx->wait"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "table->table[ctx->id]",
            "NULL"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ctx != rcu_access_pointer(table->table[ctx->id])"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "table->table[ctx->id]"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&ctx->dead",
            "1"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\t      struct ctx_rq_wait *wait)\n{\n\tstruct kioctx_table *table;\n\n\tspin_lock(&mm->ioctx_lock);\n\tif (atomic_xchg(&ctx->dead, 1)) {\n\t\tspin_unlock(&mm->ioctx_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\tWARN_ON(ctx != rcu_access_pointer(table->table[ctx->id]));\n\tRCU_INIT_POINTER(table->table[ctx->id], NULL);\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* free_ioctx_reqs() will do the necessary RCU synchronization */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->rq_wait = wait;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}"
  },
  {
    "function_name": "ioctx_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "686-794",
    "snippet": "static struct kioctx *ioctx_alloc(unsigned nr_events)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx;\n\tint err = -ENOMEM;\n\n\t/*\n\t * Store the original nr_events -- what userspace passed to io_setup(),\n\t * for counting against the global limit -- before it changes.\n\t */\n\tunsigned int max_reqs = nr_events;\n\n\t/*\n\t * We keep track of the number of available ringbuffer slots, to prevent\n\t * overflow (reqs_available), and we also use percpu counters for this.\n\t *\n\t * So since up to half the slots might be on other cpu's percpu counters\n\t * and unavailable, double nr_events so userspace sees what they\n\t * expected: additionally, we move req_batch slots to/from percpu\n\t * counters at a time, so make sure that isn't 0:\n\t */\n\tnr_events = max(nr_events, num_possible_cpus() * 4);\n\tnr_events *= 2;\n\n\t/* Prevent overflows */\n\tif (nr_events > (0x10000000U / sizeof(struct io_event))) {\n\t\tpr_debug(\"ENOMEM: nr_events too high\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_events || (unsigned long)max_reqs > aio_max_nr)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tctx = kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->max_reqs = max_reqs;\n\n\tspin_lock_init(&ctx->ctx_lock);\n\tspin_lock_init(&ctx->completion_lock);\n\tmutex_init(&ctx->ring_lock);\n\t/* Protect against page migration throughout kiotx setup by keeping\n\t * the ring_lock mutex held until setup is complete. */\n\tmutex_lock(&ctx->ring_lock);\n\tinit_waitqueue_head(&ctx->wait);\n\n\tINIT_LIST_HEAD(&ctx->active_reqs);\n\n\tif (percpu_ref_init(&ctx->users, free_ioctx_users, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tif (percpu_ref_init(&ctx->reqs, free_ioctx_reqs, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tctx->cpu = alloc_percpu(struct kioctx_cpu);\n\tif (!ctx->cpu)\n\t\tgoto err;\n\n\terr = aio_setup_ring(ctx, nr_events);\n\tif (err < 0)\n\t\tgoto err;\n\n\tatomic_set(&ctx->reqs_available, ctx->nr_events - 1);\n\tctx->req_batch = (ctx->nr_events - 1) / (num_possible_cpus() * 4);\n\tif (ctx->req_batch < 1)\n\t\tctx->req_batch = 1;\n\n\t/* limit the number of system wide aios */\n\tspin_lock(&aio_nr_lock);\n\tif (aio_nr + ctx->max_reqs > aio_max_nr ||\n\t    aio_nr + ctx->max_reqs < aio_nr) {\n\t\tspin_unlock(&aio_nr_lock);\n\t\terr = -EAGAIN;\n\t\tgoto err_ctx;\n\t}\n\taio_nr += ctx->max_reqs;\n\tspin_unlock(&aio_nr_lock);\n\n\tpercpu_ref_get(&ctx->users);\t/* io_setup() will drop this ref */\n\tpercpu_ref_get(&ctx->reqs);\t/* free_ioctx_users() will drop this */\n\n\terr = ioctx_add_table(ctx, mm);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\t/* Release the ring_lock mutex now that all setup is complete. */\n\tmutex_unlock(&ctx->ring_lock);\n\n\tpr_debug(\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\",\n\t\t ctx, ctx->user_id, mm, ctx->nr_events);\n\treturn ctx;\n\nerr_cleanup:\n\taio_nr_sub(ctx->max_reqs);\nerr_ctx:\n\tatomic_set(&ctx->dead, 1);\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\taio_free_ring(ctx);\nerr:\n\tmutex_unlock(&ctx->ring_lock);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n\tpr_debug(\"error allocating ioctx %d\\n\", err);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(aio_nr_lock);",
      "unsigned long aio_nr;",
      "unsigned long aio_max_nr = 0x10000;",
      "static struct kmem_cache\t*kioctx_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"error allocating ioctx %d\\n\"",
            "err"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kioctx_cachep",
            "ctx"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->users"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->reqs"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "ctx->cpu"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_free_ring",
          "args": [
            "ctx"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "aio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "286-310",
          "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "ctx->mmap_base",
            "ctx->mmap_size"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ctx->dead",
            "1"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_nr_sub",
          "args": [
            "ctx->max_reqs"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "aio_nr_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "673-681",
          "snippet": "static void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(aio_nr_lock);",
            "unsigned long aio_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\n\nstatic void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\"",
            "ctx",
            "ctx->user_id",
            "mm",
            "ctx->nr_events"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctx_add_table",
          "args": [
            "ctx",
            "mm"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ioctx_add_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "618-671",
          "snippet": "static int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!rcu_access_pointer(table->table[i])) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\trcu_assign_pointer(table->table[i], ctx);\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!rcu_access_pointer(table->table[i])) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\trcu_assign_pointer(table->table[i], ctx);\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&ctx->reqs"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_get",
          "args": [
            "&ctx->users"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ctx->reqs_available",
            "ctx->nr_events - 1"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_setup_ring",
          "args": [
            "ctx",
            "nr_events"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "aio_setup_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "445-540",
          "snippet": "static int aio_setup_ring(struct kioctx *ctx, unsigned int nr_events)\n{\n\tstruct aio_ring *ring;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tif (down_write_killable(&mm->mmap_sem)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -EINTR;\n\t}\n\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused, NULL);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AIO_RING_PAGES\t8",
            "#define AIO_RING_INCOMPAT_FEATURES\t0",
            "#define AIO_RING_COMPAT_FEATURES\t1",
            "#define AIO_RING_MAGIC\t\t\t0xa10a10a1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_RING_PAGES\t8\n#define AIO_RING_INCOMPAT_FEATURES\t0\n#define AIO_RING_COMPAT_FEATURES\t1\n#define AIO_RING_MAGIC\t\t\t0xa10a10a1\n\nstatic int aio_setup_ring(struct kioctx *ctx, unsigned int nr_events)\n{\n\tstruct aio_ring *ring;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tif (down_write_killable(&mm->mmap_sem)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -EINTR;\n\t}\n\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused, NULL);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structkioctx_cpu"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&ctx->reqs",
            "free_ioctx_reqs",
            "0",
            "GFP_KERNEL"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&ctx->users",
            "free_ioctx_users",
            "0",
            "GFP_KERNEL"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctx->active_reqs"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ctx->wait"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctx->completion_lock"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "kioctx_cachep",
            "GFP_KERNEL"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ENOMEM: nr_events too high\\n\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_events",
            "num_possible_cpus() * 4"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "392-432",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\nunsigned long aio_max_nr = 0x10000;\nstatic struct kmem_cache\t*kioctx_cachep;\n\nstatic struct kioctx *ioctx_alloc(unsigned nr_events)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx;\n\tint err = -ENOMEM;\n\n\t/*\n\t * Store the original nr_events -- what userspace passed to io_setup(),\n\t * for counting against the global limit -- before it changes.\n\t */\n\tunsigned int max_reqs = nr_events;\n\n\t/*\n\t * We keep track of the number of available ringbuffer slots, to prevent\n\t * overflow (reqs_available), and we also use percpu counters for this.\n\t *\n\t * So since up to half the slots might be on other cpu's percpu counters\n\t * and unavailable, double nr_events so userspace sees what they\n\t * expected: additionally, we move req_batch slots to/from percpu\n\t * counters at a time, so make sure that isn't 0:\n\t */\n\tnr_events = max(nr_events, num_possible_cpus() * 4);\n\tnr_events *= 2;\n\n\t/* Prevent overflows */\n\tif (nr_events > (0x10000000U / sizeof(struct io_event))) {\n\t\tpr_debug(\"ENOMEM: nr_events too high\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_events || (unsigned long)max_reqs > aio_max_nr)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tctx = kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->max_reqs = max_reqs;\n\n\tspin_lock_init(&ctx->ctx_lock);\n\tspin_lock_init(&ctx->completion_lock);\n\tmutex_init(&ctx->ring_lock);\n\t/* Protect against page migration throughout kiotx setup by keeping\n\t * the ring_lock mutex held until setup is complete. */\n\tmutex_lock(&ctx->ring_lock);\n\tinit_waitqueue_head(&ctx->wait);\n\n\tINIT_LIST_HEAD(&ctx->active_reqs);\n\n\tif (percpu_ref_init(&ctx->users, free_ioctx_users, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tif (percpu_ref_init(&ctx->reqs, free_ioctx_reqs, 0, GFP_KERNEL))\n\t\tgoto err;\n\n\tctx->cpu = alloc_percpu(struct kioctx_cpu);\n\tif (!ctx->cpu)\n\t\tgoto err;\n\n\terr = aio_setup_ring(ctx, nr_events);\n\tif (err < 0)\n\t\tgoto err;\n\n\tatomic_set(&ctx->reqs_available, ctx->nr_events - 1);\n\tctx->req_batch = (ctx->nr_events - 1) / (num_possible_cpus() * 4);\n\tif (ctx->req_batch < 1)\n\t\tctx->req_batch = 1;\n\n\t/* limit the number of system wide aios */\n\tspin_lock(&aio_nr_lock);\n\tif (aio_nr + ctx->max_reqs > aio_max_nr ||\n\t    aio_nr + ctx->max_reqs < aio_nr) {\n\t\tspin_unlock(&aio_nr_lock);\n\t\terr = -EAGAIN;\n\t\tgoto err_ctx;\n\t}\n\taio_nr += ctx->max_reqs;\n\tspin_unlock(&aio_nr_lock);\n\n\tpercpu_ref_get(&ctx->users);\t/* io_setup() will drop this ref */\n\tpercpu_ref_get(&ctx->reqs);\t/* free_ioctx_users() will drop this */\n\n\terr = ioctx_add_table(ctx, mm);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\t/* Release the ring_lock mutex now that all setup is complete. */\n\tmutex_unlock(&ctx->ring_lock);\n\n\tpr_debug(\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\",\n\t\t ctx, ctx->user_id, mm, ctx->nr_events);\n\treturn ctx;\n\nerr_cleanup:\n\taio_nr_sub(ctx->max_reqs);\nerr_ctx:\n\tatomic_set(&ctx->dead, 1);\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\taio_free_ring(ctx);\nerr:\n\tmutex_unlock(&ctx->ring_lock);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n\tpr_debug(\"error allocating ioctx %d\\n\", err);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "aio_nr_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "673-681",
    "snippet": "static void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(aio_nr_lock);",
      "unsigned long aio_nr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "aio_nr - nr > aio_nr"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&aio_nr_lock"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(aio_nr_lock);\nunsigned long aio_nr;\n\nstatic void aio_nr_sub(unsigned nr)\n{\n\tspin_lock(&aio_nr_lock);\n\tif (WARN_ON(aio_nr - nr > aio_nr))\n\t\taio_nr = 0;\n\telse\n\t\taio_nr -= nr;\n\tspin_unlock(&aio_nr_lock);\n}"
  },
  {
    "function_name": "ioctx_add_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "618-671",
    "snippet": "static int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!rcu_access_pointer(table->table[i])) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\trcu_assign_pointer(table->table[i], ctx);\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "old",
            "rcu"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "mm->ioctx_table",
            "table"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "table->table",
            "old->table",
            "old->nr * sizeof(struct kioctx *)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "mm->ioctx_table",
            "table"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr",
            "GFP_KERNEL"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "table->table[i]",
            "ctx"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "table->table[i]"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int ioctx_add_table(struct kioctx *ctx, struct mm_struct *mm)\n{\n\tunsigned i, new_nr;\n\tstruct kioctx_table *table, *old;\n\tstruct aio_ring *ring;\n\n\tspin_lock(&mm->ioctx_lock);\n\ttable = rcu_dereference_raw(mm->ioctx_table);\n\n\twhile (1) {\n\t\tif (table)\n\t\t\tfor (i = 0; i < table->nr; i++)\n\t\t\t\tif (!rcu_access_pointer(table->table[i])) {\n\t\t\t\t\tctx->id = i;\n\t\t\t\t\trcu_assign_pointer(table->table[i], ctx);\n\t\t\t\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\t\t\t\t/* While kioctx setup is in progress,\n\t\t\t\t\t * we are protected from page migration\n\t\t\t\t\t * changes ring_pages by ->ring_lock.\n\t\t\t\t\t */\n\t\t\t\t\tring = kmap_atomic(ctx->ring_pages[0]);\n\t\t\t\t\tring->id = ctx->id;\n\t\t\t\t\tkunmap_atomic(ring);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\tnew_nr = (table ? table->nr : 1) * 4;\n\t\tspin_unlock(&mm->ioctx_lock);\n\n\t\ttable = kzalloc(sizeof(*table) + sizeof(struct kioctx *) *\n\t\t\t\tnew_nr, GFP_KERNEL);\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\n\t\ttable->nr = new_nr;\n\n\t\tspin_lock(&mm->ioctx_lock);\n\t\told = rcu_dereference_raw(mm->ioctx_table);\n\n\t\tif (!old) {\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t} else if (table->nr > old->nr) {\n\t\t\tmemcpy(table->table, old->table,\n\t\t\t       old->nr * sizeof(struct kioctx *));\n\n\t\t\trcu_assign_pointer(mm->ioctx_table, table);\n\t\t\tkfree_rcu(old, rcu);\n\t\t} else {\n\t\t\tkfree(table);\n\t\t\ttable = old;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "free_ioctx_users",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "598-616",
    "snippet": "static void free_ioctx_users(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, users);\n\tstruct aio_kiocb *req;\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\n\twhile (!list_empty(&ctx->active_reqs)) {\n\t\treq = list_first_entry(&ctx->active_reqs,\n\t\t\t\t       struct aio_kiocb, ki_list);\n\t\treq->ki_cancel(&req->rw);\n\t\tlist_del_init(&req->ki_list);\n\t}\n\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\tpercpu_ref_kill(&ctx->reqs);\n\tpercpu_ref_put(&ctx->reqs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&ctx->reqs"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&ctx->reqs"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->ki_list"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->ki_cancel",
          "args": [
            "&req->rw"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ctx->active_reqs",
            "structaio_kiocb",
            "ki_list"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->active_reqs"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ctx->ctx_lock"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structkioctx",
            "users"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void free_ioctx_users(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, users);\n\tstruct aio_kiocb *req;\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\n\twhile (!list_empty(&ctx->active_reqs)) {\n\t\treq = list_first_entry(&ctx->active_reqs,\n\t\t\t\t       struct aio_kiocb, ki_list);\n\t\treq->ki_cancel(&req->rw);\n\t\tlist_del_init(&req->ki_list);\n\t}\n\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\tpercpu_ref_kill(&ctx->reqs);\n\tpercpu_ref_put(&ctx->reqs);\n}"
  },
  {
    "function_name": "free_ioctx_reqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "580-591",
    "snippet": "static void free_ioctx_reqs(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, reqs);\n\n\t/* At this point we know that there are no any in-flight requests */\n\tif (ctx->rq_wait && atomic_dec_and_test(&ctx->rq_wait->count))\n\t\tcomplete(&ctx->rq_wait->comp);\n\n\t/* Synchronize against RCU protected table->table[] dereferences */\n\tINIT_RCU_WORK(&ctx->free_rwork, free_ioctx);\n\tqueue_rcu_work(system_wq, &ctx->free_rwork);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_rcu_work",
          "args": [
            "system_wq",
            "&ctx->free_rwork"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RCU_WORK",
          "args": [
            "&ctx->free_rwork",
            "free_ioctx"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ctx->rq_wait->comp"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "aio_poll_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "1609-1637",
          "snippet": "static void aio_poll_complete_work(struct work_struct *work)\n{\n\tstruct poll_iocb *req = container_of(work, struct poll_iocb, work);\n\tstruct aio_kiocb *iocb = container_of(req, struct aio_kiocb, poll);\n\tstruct poll_table_struct pt = { ._key = req->events };\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\t__poll_t mask = 0;\n\n\tif (!READ_ONCE(req->cancelled))\n\t\tmask = vfs_poll(req->file, &pt) & req->events;\n\n\t/*\n\t * Note that ->ki_cancel callers also delete iocb from active_reqs after\n\t * calling ->ki_cancel.  We need the ctx_lock roundtrip here to\n\t * synchronize with them.  In the cancellation case the list_del_init\n\t * itself is not actually needed, but harmless so we keep it in to\n\t * avoid further branches in the fast path.\n\t */\n\tspin_lock_irq(&ctx->ctx_lock);\n\tif (!mask && !READ_ONCE(req->cancelled)) {\n\t\tadd_wait_queue(req->head, &req->wait);\n\t\tspin_unlock_irq(&ctx->ctx_lock);\n\t\treturn;\n\t}\n\tlist_del_init(&iocb->ki_list);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\taio_poll_complete(iocb, mask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_poll_complete_work(struct work_struct *work)\n{\n\tstruct poll_iocb *req = container_of(work, struct poll_iocb, work);\n\tstruct aio_kiocb *iocb = container_of(req, struct aio_kiocb, poll);\n\tstruct poll_table_struct pt = { ._key = req->events };\n\tstruct kioctx *ctx = iocb->ki_ctx;\n\t__poll_t mask = 0;\n\n\tif (!READ_ONCE(req->cancelled))\n\t\tmask = vfs_poll(req->file, &pt) & req->events;\n\n\t/*\n\t * Note that ->ki_cancel callers also delete iocb from active_reqs after\n\t * calling ->ki_cancel.  We need the ctx_lock roundtrip here to\n\t * synchronize with them.  In the cancellation case the list_del_init\n\t * itself is not actually needed, but harmless so we keep it in to\n\t * avoid further branches in the fast path.\n\t */\n\tspin_lock_irq(&ctx->ctx_lock);\n\tif (!mask && !READ_ONCE(req->cancelled)) {\n\t\tadd_wait_queue(req->head, &req->wait);\n\t\tspin_unlock_irq(&ctx->ctx_lock);\n\t\treturn;\n\t}\n\tlist_del_init(&iocb->ki_list);\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\taio_poll_complete(iocb, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ctx->rq_wait->count"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structkioctx",
            "reqs"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void free_ioctx_reqs(struct percpu_ref *ref)\n{\n\tstruct kioctx *ctx = container_of(ref, struct kioctx, reqs);\n\n\t/* At this point we know that there are no any in-flight requests */\n\tif (ctx->rq_wait && atomic_dec_and_test(&ctx->rq_wait->count))\n\t\tcomplete(&ctx->rq_wait->comp);\n\n\t/* Synchronize against RCU protected table->table[] dereferences */\n\tINIT_RCU_WORK(&ctx->free_rwork, free_ioctx);\n\tqueue_rcu_work(system_wq, &ctx->free_rwork);\n}"
  },
  {
    "function_name": "free_ioctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "567-578",
    "snippet": "static void free_ioctx(struct work_struct *work)\n{\n\tstruct kioctx *ctx = container_of(to_rcu_work(work), struct kioctx,\n\t\t\t\t\t  free_rwork);\n\tpr_debug(\"freeing %p\\n\", ctx);\n\n\taio_free_ring(ctx);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kioctx_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kioctx_cachep",
            "ctx"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->users"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&ctx->reqs"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "ctx->cpu"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_free_ring",
          "args": [
            "ctx"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "aio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "286-310",
          "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"freeing %p\\n\"",
            "ctx"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_rcu_work(work)",
            "structkioctx",
            "free_rwork"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_rcu_work",
          "args": [
            "work"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kioctx_cachep;\n\nstatic void free_ioctx(struct work_struct *work)\n{\n\tstruct kioctx *ctx = container_of(to_rcu_work(work), struct kioctx,\n\t\t\t\t\t  free_rwork);\n\tpr_debug(\"freeing %p\\n\", ctx);\n\n\taio_free_ring(ctx);\n\tfree_percpu(ctx->cpu);\n\tpercpu_ref_exit(&ctx->reqs);\n\tpercpu_ref_exit(&ctx->users);\n\tkmem_cache_free(kioctx_cachep, ctx);\n}"
  },
  {
    "function_name": "kiocb_set_cancel_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "546-559",
    "snippet": "void kiocb_set_cancel_fn(struct kiocb *iocb, kiocb_cancel_fn *cancel)\n{\n\tstruct aio_kiocb *req = container_of(iocb, struct aio_kiocb, rw);\n\tstruct kioctx *ctx = req->ki_ctx;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(!list_empty(&req->ki_list)))\n\t\treturn;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\tlist_add_tail(&req->ki_list, &ctx->active_reqs);\n\treq->ki_cancel = cancel;\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->ki_list",
            "&ctx->active_reqs"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->ctx_lock",
            "flags"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&req->ki_list)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&req->ki_list"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "iocb",
            "structaio_kiocb",
            "rw"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid kiocb_set_cancel_fn(struct kiocb *iocb, kiocb_cancel_fn *cancel)\n{\n\tstruct aio_kiocb *req = container_of(iocb, struct aio_kiocb, rw);\n\tstruct kioctx *ctx = req->ki_ctx;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(!list_empty(&req->ki_list)))\n\t\treturn;\n\n\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\tlist_add_tail(&req->ki_list, &ctx->active_reqs);\n\treq->ki_cancel = cancel;\n\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n}"
  },
  {
    "function_name": "aio_setup_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "445-540",
    "snippet": "static int aio_setup_ring(struct kioctx *ctx, unsigned int nr_events)\n{\n\tstruct aio_ring *ring;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tif (down_write_killable(&mm->mmap_sem)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -EINTR;\n\t}\n\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused, NULL);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_RING_PAGES\t8",
      "#define AIO_RING_INCOMPAT_FEATURES\t0",
      "#define AIO_RING_COMPAT_FEATURES\t1",
      "#define AIO_RING_MAGIC\t\t\t0xa10a10a1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ring"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ctx->ring_pages[0]"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"mmap address: 0x%08lx\\n\"",
            "ctx->mmap_base"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_free_ring",
          "args": [
            "ctx"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "aio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "286-310",
          "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)ctx->mmap_base"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mmap_pgoff",
          "args": [
            "ctx->aio_ring_file",
            "0",
            "ctx->mmap_size",
            "PROT_READ | PROT_WRITE",
            "MAP_SHARED",
            "0",
            "&unused",
            "NULL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"attempting mmap of %lu bytes\\n\"",
            "ctx->mmap_size"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i != nr_pages"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/aops.c",
          "lines": "816-837",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tput_page(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"pid(%d) page[%d]->count=%d\\n\"",
            "current->pid",
            "i",
            "page_count(page)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "file->f_mapping",
            "i",
            "GFP_HIGHUSER | __GFP_ZERO"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_aio_ring_file",
          "args": [
            "ctx"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "put_aio_ring_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "267-284",
          "snippet": "static void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tstruct address_space *i_mapping;\n\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(file_inode(aio_ring_file), 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\ti_mapping = aio_ring_file->f_mapping;\n\t\tspin_lock(&i_mapping->private_lock);\n\t\ti_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tstruct address_space *i_mapping;\n\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(file_inode(aio_ring_file), 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\ti_mapping = aio_ring_file->f_mapping;\n\t\tspin_lock(&i_mapping->private_lock);\n\t\ti_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_pages",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aio_private_file",
          "args": [
            "ctx",
            "nr_pages"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "aio_private_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "217-233",
          "snippet": "static struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct file *file;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tfile = alloc_file_pseudo(inode, aio_mnt, \"[aio]\",\n\t\t\t\tO_RDWR, &aio_ring_fops);\n\tif (IS_ERR(file))\n\t\tiput(inode);\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aio_mnt;",
            "static const struct file_operations aio_ring_fops;",
            "static const struct address_space_operations aio_ctx_aops;",
            "static const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n};",
            "static const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct vfsmount *aio_mnt;\nstatic const struct file_operations aio_ring_fops;\nstatic const struct address_space_operations aio_ctx_aops;\nstatic const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n};\nstatic const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};\n\nstatic struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct file *file;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tfile = alloc_file_pseudo(inode, aio_mnt, \"[aio]\",\n\t\t\t\tO_RDWR, &aio_ring_fops);\n\tif (IS_ERR(file))\n\t\tiput(inode);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "size"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_RING_PAGES\t8\n#define AIO_RING_INCOMPAT_FEATURES\t0\n#define AIO_RING_COMPAT_FEATURES\t1\n#define AIO_RING_MAGIC\t\t\t0xa10a10a1\n\nstatic int aio_setup_ring(struct kioctx *ctx, unsigned int nr_events)\n{\n\tstruct aio_ring *ring;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size, unused;\n\tint nr_pages;\n\tint i;\n\tstruct file *file;\n\n\t/* Compensate for the ring buffer's head/tail overlap entry */\n\tnr_events += 2;\t/* 1 is required, 2 for good luck */\n\n\tsize = sizeof(struct aio_ring);\n\tsize += sizeof(struct io_event) * nr_events;\n\n\tnr_pages = PFN_UP(size);\n\tif (nr_pages < 0)\n\t\treturn -EINVAL;\n\n\tfile = aio_private_file(ctx, nr_pages);\n\tif (IS_ERR(file)) {\n\t\tctx->aio_ring_file = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->aio_ring_file = file;\n\tnr_events = (PAGE_SIZE * nr_pages - sizeof(struct aio_ring))\n\t\t\t/ sizeof(struct io_event);\n\n\tctx->ring_pages = ctx->internal_pages;\n\tif (nr_pages > AIO_RING_PAGES) {\n\t\tctx->ring_pages = kcalloc(nr_pages, sizeof(struct page *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!ctx->ring_pages) {\n\t\t\tput_aio_ring_file(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpage = find_or_create_page(file->f_mapping,\n\t\t\t\t\t   i, GFP_HIGHUSER | __GFP_ZERO);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpr_debug(\"pid(%d) page[%d]->count=%d\\n\",\n\t\t\t current->pid, i, page_count(page));\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\n\t\tctx->ring_pages[i] = page;\n\t}\n\tctx->nr_pages = i;\n\n\tif (unlikely(i != nr_pages)) {\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->mmap_size = nr_pages * PAGE_SIZE;\n\tpr_debug(\"attempting mmap of %lu bytes\\n\", ctx->mmap_size);\n\n\tif (down_write_killable(&mm->mmap_sem)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -EINTR;\n\t}\n\n\tctx->mmap_base = do_mmap_pgoff(ctx->aio_ring_file, 0, ctx->mmap_size,\n\t\t\t\t       PROT_READ | PROT_WRITE,\n\t\t\t\t       MAP_SHARED, 0, &unused, NULL);\n\tup_write(&mm->mmap_sem);\n\tif (IS_ERR((void *)ctx->mmap_base)) {\n\t\tctx->mmap_size = 0;\n\t\taio_free_ring(ctx);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"mmap address: 0x%08lx\\n\", ctx->mmap_base);\n\n\tctx->user_id = ctx->mmap_base;\n\tctx->nr_events = nr_events; /* trusted copy */\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->nr = nr_events;\t/* user copy */\n\tring->id = ~0U;\n\tring->head = ring->tail = 0;\n\tring->magic = AIO_RING_MAGIC;\n\tring->compat_features = AIO_RING_COMPAT_FEATURES;\n\tring->incompat_features = AIO_RING_INCOMPAT_FEATURES;\n\tring->header_length = sizeof(struct aio_ring);\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_migratepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "361-435",
    "snippet": "static int aio_migratepage(struct address_space *mapping, struct page *new,\n\t\t\tstruct page *old, enum migrate_mode mode)\n{\n\tstruct kioctx *ctx;\n\tunsigned long flags;\n\tpgoff_t idx;\n\tint rc;\n\n\t/*\n\t * We cannot support the _NO_COPY case here, because copy needs to\n\t * happen under the ctx->completion_lock. That does not work with the\n\t * migration workflow of MIGRATE_SYNC_NO_COPY.\n\t */\n\tif (mode == MIGRATE_SYNC_NO_COPY)\n\t\treturn -EINVAL;\n\n\trc = 0;\n\n\t/* mapping->private_lock here protects against the kioctx teardown.  */\n\tspin_lock(&mapping->private_lock);\n\tctx = mapping->private_data;\n\tif (!ctx) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* The ring_lock mutex.  The prevents aio_read_events() from writing\n\t * to the ring's head, and prevents page migration from mucking in\n\t * a partially initialized kiotx.\n\t */\n\tif (!mutex_trylock(&ctx->ring_lock)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tidx = old->index;\n\tif (idx < (pgoff_t)ctx->nr_pages) {\n\t\t/* Make sure the old page hasn't already been changed */\n\t\tif (ctx->ring_pages[idx] != old)\n\t\t\trc = -EAGAIN;\n\t} else\n\t\trc = -EINVAL;\n\n\tif (rc != 0)\n\t\tgoto out_unlock;\n\n\t/* Writeback must be complete */\n\tBUG_ON(PageWriteback(old));\n\tget_page(new);\n\n\trc = migrate_page_move_mapping(mapping, new, old, NULL, mode, 1);\n\tif (rc != MIGRATEPAGE_SUCCESS) {\n\t\tput_page(new);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Take completion_lock to prevent other writes to the ring buffer\n\t * while the old page is copied to the new.  This prevents new\n\t * events from being lost.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\tmigrate_page_copy(new, old);\n\tBUG_ON(ctx->ring_pages[idx] != old);\n\tctx->ring_pages[idx] = new;\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\t/* The old page is no longer accessible. */\n\tput_page(old);\n\nout_unlock:\n\tmutex_unlock(&ctx->ring_lock);\nout:\n\tspin_unlock(&mapping->private_lock);\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "old"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ctx->ring_pages[idx] != old"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_copy",
          "args": [
            "new",
            "old"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ctx->completion_lock",
            "flags"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_move_mapping",
          "args": [
            "mapping",
            "new",
            "old",
            "NULL",
            "mode",
            "1"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(old)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "old"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&ctx->ring_lock"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_migratepage(struct address_space *mapping, struct page *new,\n\t\t\tstruct page *old, enum migrate_mode mode)\n{\n\tstruct kioctx *ctx;\n\tunsigned long flags;\n\tpgoff_t idx;\n\tint rc;\n\n\t/*\n\t * We cannot support the _NO_COPY case here, because copy needs to\n\t * happen under the ctx->completion_lock. That does not work with the\n\t * migration workflow of MIGRATE_SYNC_NO_COPY.\n\t */\n\tif (mode == MIGRATE_SYNC_NO_COPY)\n\t\treturn -EINVAL;\n\n\trc = 0;\n\n\t/* mapping->private_lock here protects against the kioctx teardown.  */\n\tspin_lock(&mapping->private_lock);\n\tctx = mapping->private_data;\n\tif (!ctx) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* The ring_lock mutex.  The prevents aio_read_events() from writing\n\t * to the ring's head, and prevents page migration from mucking in\n\t * a partially initialized kiotx.\n\t */\n\tif (!mutex_trylock(&ctx->ring_lock)) {\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tidx = old->index;\n\tif (idx < (pgoff_t)ctx->nr_pages) {\n\t\t/* Make sure the old page hasn't already been changed */\n\t\tif (ctx->ring_pages[idx] != old)\n\t\t\trc = -EAGAIN;\n\t} else\n\t\trc = -EINVAL;\n\n\tif (rc != 0)\n\t\tgoto out_unlock;\n\n\t/* Writeback must be complete */\n\tBUG_ON(PageWriteback(old));\n\tget_page(new);\n\n\trc = migrate_page_move_mapping(mapping, new, old, NULL, mode, 1);\n\tif (rc != MIGRATEPAGE_SUCCESS) {\n\t\tput_page(new);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Take completion_lock to prevent other writes to the ring buffer\n\t * while the old page is copied to the new.  This prevents new\n\t * events from being lost.\n\t */\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\tmigrate_page_copy(new, old);\n\tBUG_ON(ctx->ring_pages[idx] != old);\n\tctx->ring_pages[idx] = new;\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\n\t/* The old page is no longer accessible. */\n\tput_page(old);\n\nout_unlock:\n\tmutex_unlock(&ctx->ring_lock);\nout:\n\tspin_unlock(&mapping->private_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "aio_ring_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "349-354",
    "snippet": "static int aio_ring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_ops = &aio_ring_vm_ops;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct aio_ring_vm_ops = {\n\t.mremap\t\t= aio_ring_mremap,\n#if IS_ENABLED(CONFIG_MMU)\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= filemap_page_mkwrite,\n#endif\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic const struct vm_operations_struct aio_ring_vm_ops = {\n\t.mremap\t\t= aio_ring_mremap,\n#if IS_ENABLED(CONFIG_MMU)\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= filemap_page_mkwrite,\n#endif\n};\n\nstatic int aio_ring_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tvma->vm_flags |= VM_DONTEXPAND;\n\tvma->vm_ops = &aio_ring_vm_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_ring_mremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "312-338",
    "snippet": "static int aio_ring_mremap(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct kioctx_table *table;\n\tint i, res = -EINVAL;\n\n\tspin_lock(&mm->ioctx_lock);\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\tfor (i = 0; i < table->nr; i++) {\n\t\tstruct kioctx *ctx;\n\n\t\tctx = rcu_dereference(table->table[i]);\n\t\tif (ctx && ctx->aio_ring_file == file) {\n\t\t\tif (!atomic_read(&ctx->dead)) {\n\t\t\t\tctx->user_id = ctx->mmap_base = vma->vm_start;\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\tspin_unlock(&mm->ioctx_lock);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ctx->dead"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "table->table[i]"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "mm->ioctx_table"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->ioctx_lock"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int aio_ring_mremap(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct kioctx_table *table;\n\tint i, res = -EINVAL;\n\n\tspin_lock(&mm->ioctx_lock);\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\tfor (i = 0; i < table->nr; i++) {\n\t\tstruct kioctx *ctx;\n\n\t\tctx = rcu_dereference(table->table[i]);\n\t\tif (ctx && ctx->aio_ring_file == file) {\n\t\t\tif (!atomic_read(&ctx->dead)) {\n\t\t\t\tctx->user_id = ctx->mmap_base = vma->vm_start;\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\tspin_unlock(&mm->ioctx_lock);\n\treturn res;\n}"
  },
  {
    "function_name": "aio_free_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "286-310",
    "snippet": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->ring_pages"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/dir.c",
          "lines": "67-71",
          "snippet": "static inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/pagemap.h>\n\nstatic inline void nilfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"pid(%d) [%d] page->count=%d\\n\"",
            "current->pid",
            "i",
            "page_count(ctx->ring_pages[i])"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "ctx->ring_pages[i]"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_aio_ring_file",
          "args": [
            "ctx"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "put_aio_ring_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
          "lines": "267-284",
          "snippet": "static void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tstruct address_space *i_mapping;\n\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(file_inode(aio_ring_file), 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\ti_mapping = aio_ring_file->f_mapping;\n\t\tspin_lock(&i_mapping->private_lock);\n\t\ti_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/kmap_types.h>",
            "#include <linux/mount.h>",
            "#include <linux/percpu-refcount.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/migrate.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/highmem.h>",
            "#include <linux/aio.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/uio.h>",
            "#include <linux/refcount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/aio_abi.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tstruct address_space *i_mapping;\n\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(file_inode(aio_ring_file), 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\ti_mapping = aio_ring_file->f_mapping;\n\t\tspin_lock(&i_mapping->private_lock);\n\t\ti_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\t/* Disconnect the kiotx from the ring file.  This prevents future\n\t * accesses to the kioctx from page migration.\n\t */\n\tput_aio_ring_file(ctx);\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tstruct page *page;\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tpage = ctx->ring_pages[i];\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tctx->ring_pages[i] = NULL;\n\t\tput_page(page);\n\t}\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages) {\n\t\tkfree(ctx->ring_pages);\n\t\tctx->ring_pages = NULL;\n\t}\n}"
  },
  {
    "function_name": "put_aio_ring_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "267-284",
    "snippet": "static void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tstruct address_space *i_mapping;\n\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(file_inode(aio_ring_file), 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\ti_mapping = aio_ring_file->f_mapping;\n\t\tspin_lock(&i_mapping->private_lock);\n\t\ti_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "aio_ring_file"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&i_mapping->private_lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&i_mapping->private_lock"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "file_inode(aio_ring_file)",
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "aio_ring_file"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic void put_aio_ring_file(struct kioctx *ctx)\n{\n\tstruct file *aio_ring_file = ctx->aio_ring_file;\n\tstruct address_space *i_mapping;\n\n\tif (aio_ring_file) {\n\t\ttruncate_setsize(file_inode(aio_ring_file), 0);\n\n\t\t/* Prevent further access to the kioctx from migratepages */\n\t\ti_mapping = aio_ring_file->f_mapping;\n\t\tspin_lock(&i_mapping->private_lock);\n\t\ti_mapping->private_data = NULL;\n\t\tctx->aio_ring_file = NULL;\n\t\tspin_unlock(&i_mapping->private_lock);\n\n\t\tfput(aio_ring_file);\n\t}\n}"
  },
  {
    "function_name": "aio_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "250-264",
    "snippet": "static int __init aio_setup(void)\n{\n\tstatic struct file_system_type aio_fs = {\n\t\t.name\t\t= \"aio\",\n\t\t.mount\t\t= aio_mount,\n\t\t.kill_sb\t= kill_anon_super,\n\t};\n\taio_mnt = kern_mount(&aio_fs);\n\tif (IS_ERR(aio_mnt))\n\t\tpanic(\"Failed to create aio fs mount.\");\n\n\tkiocb_cachep = KMEM_CACHE(aio_kiocb, SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\tkioctx_cachep = KMEM_CACHE(kioctx,SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*kiocb_cachep;",
      "static struct kmem_cache\t*kioctx_cachep;",
      "static struct vfsmount *aio_mnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "kioctx",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "aio_kiocb",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to create aio fs mount.\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "aio_mnt"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&aio_fs"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache\t*kiocb_cachep;\nstatic struct kmem_cache\t*kioctx_cachep;\nstatic struct vfsmount *aio_mnt;\n\nstatic int __init aio_setup(void)\n{\n\tstatic struct file_system_type aio_fs = {\n\t\t.name\t\t= \"aio\",\n\t\t.mount\t\t= aio_mount,\n\t\t.kill_sb\t= kill_anon_super,\n\t};\n\taio_mnt = kern_mount(&aio_fs);\n\tif (IS_ERR(aio_mnt))\n\t\tpanic(\"Failed to create aio fs mount.\");\n\n\tkiocb_cachep = KMEM_CACHE(aio_kiocb, SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\tkioctx_cachep = KMEM_CACHE(kioctx,SLAB_HWCACHE_ALIGN|SLAB_PANIC);\n\treturn 0;\n}"
  },
  {
    "function_name": "aio_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "235-244",
    "snippet": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstruct dentry *root = mount_pseudo(fs_type, \"aio:\", NULL, NULL,\n\t\t\t\t\t   AIO_RING_MAGIC);\n\n\tif (!IS_ERR(root))\n\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n\treturn root;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AIO_RING_MAGIC\t\t\t0xa10a10a1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"aio:\"",
            "NULL",
            "NULL",
            "AIO_RING_MAGIC"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define AIO_RING_MAGIC\t\t\t0xa10a10a1\n\nstatic struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstruct dentry *root = mount_pseudo(fs_type, \"aio:\", NULL, NULL,\n\t\t\t\t\t   AIO_RING_MAGIC);\n\n\tif (!IS_ERR(root))\n\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n\treturn root;\n}"
  },
  {
    "function_name": "aio_private_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "217-233",
    "snippet": "static struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct file *file;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tfile = alloc_file_pseudo(inode, aio_mnt, \"[aio]\",\n\t\t\t\tO_RDWR, &aio_ring_fops);\n\tif (IS_ERR(file))\n\t\tiput(inode);\n\treturn file;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *aio_mnt;",
      "static const struct file_operations aio_ring_fops;",
      "static const struct address_space_operations aio_ctx_aops;",
      "static const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n};",
      "static const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file_pseudo",
          "args": [
            "inode",
            "aio_mnt",
            "\"[aio]\"",
            "O_RDWR",
            "&aio_ring_fops"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "213-237",
          "snippet": "struct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file_pseudo(struct inode *inode, struct vfsmount *mnt,\n\t\t\t\tconst char *name, int flags,\n\t\t\t\tconst struct file_operations *fops)\n{\n\tstatic const struct dentry_operations anon_ops = {\n\t\t.d_dname = simple_dname\n\t};\n\tstruct qstr this = QSTR_INIT(name, strlen(name));\n\tstruct path path;\n\tstruct file *file;\n\n\tpath.dentry = d_alloc_pseudo(mnt->mnt_sb, &this);\n\tif (!path.dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!mnt->mnt_sb->s_d_op)\n\t\td_set_d_op(path.dentry, &anon_ops);\n\tpath.mnt = mntget(mnt);\n\td_instantiate(path.dentry, inode);\n\tfile = alloc_file(&path, flags, fops);\n\tif (IS_ERR(file)) {\n\t\tihold(inode);\n\t\tpath_put(&path);\n\t}\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_anon_inode",
          "args": [
            "aio_mnt->mnt_sb"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_anon_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1123-1149",
          "snippet": "struct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct inode *alloc_anon_inode(struct super_block *s)\n{\n\tstatic const struct address_space_operations anon_aops = {\n\t\t.set_page_dirty = anon_set_page_dirty,\n\t};\n\tstruct inode *inode = new_inode_pseudo(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mapping->a_ops = &anon_aops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because mark_inode_dirty() will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_flags |= S_PRIVATE;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic struct vfsmount *aio_mnt;\nstatic const struct file_operations aio_ring_fops;\nstatic const struct address_space_operations aio_ctx_aops;\nstatic const struct file_operations aio_ring_fops = {\n\t.mmap = aio_ring_mmap,\n};\nstatic const struct address_space_operations aio_ctx_aops = {\n\t.set_page_dirty = __set_page_dirty_no_writeback,\n#if IS_ENABLED(CONFIG_MIGRATION)\n\t.migratepage\t= aio_migratepage,\n#endif\n};\n\nstatic struct file *aio_private_file(struct kioctx *ctx, loff_t nr_pages)\n{\n\tstruct file *file;\n\tstruct inode *inode = alloc_anon_inode(aio_mnt->mnt_sb);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tinode->i_mapping->a_ops = &aio_ctx_aops;\n\tinode->i_mapping->private_data = ctx;\n\tinode->i_size = PAGE_SIZE * nr_pages;\n\n\tfile = alloc_file_pseudo(inode, aio_mnt, \"[aio]\",\n\t\t\t\tO_RDWR, &aio_ring_fops);\n\tif (IS_ERR(file))\n\t\tiput(inode);\n\treturn file;\n}"
  },
  {
    "function_name": "io_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1285-1313",
    "snippet": "SYSCALL_DEFINE2(io_setup, unsigned, nr_events, aio_context_t __user *, ctxp)\n{\n\tstruct kioctx *ioctx = NULL;\n\tunsigned long ctx;\n\tlong ret;\n\n\tret = get_user(ctx, ctxp);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (unlikely(ctx || nr_events == 0)) {\n\t\tpr_debug(\"EINVAL: ctx %lu nr_events %u\\n\",\n\t\t         ctx, nr_events);\n\t\tgoto out;\n\t}\n\n\tioctx = ioctx_alloc(nr_events);\n\tret = PTR_ERR(ioctx);\n\tif (!IS_ERR(ioctx)) {\n\t\tret = put_user(ioctx->user_id, ctxp);\n\t\tif (ret)\n\t\t\tkill_ioctx(current->mm, ioctx, NULL);\n\t\tpercpu_ref_put(&ioctx->users);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE2(io_setup, unsigned, nr_events, aio_context_t __user *, ctxp)\n{\n\tstruct kioctx *ioctx = NULL;\n\tunsigned long ctx;\n\tlong ret;\n\n\tret = get_user(ctx, ctxp);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (unlikely(ctx || nr_events == 0)) {\n\t\tpr_debug(\"EINVAL: ctx %lu nr_events %u\\n\",\n\t\t         ctx, nr_events);\n\t\tgoto out;\n\t}\n\n\tioctx = ioctx_alloc(nr_events);\n\tret = PTR_ERR(ioctx);\n\tif (!IS_ERR(ioctx)) {\n\t\tret = put_user(ioctx->user_id, ctxp);\n\t\tif (ret)\n\t\t\tkill_ioctx(current->mm, ioctx, NULL);\n\t\tpercpu_ref_put(&ioctx->users);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "io_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1316-1345",
    "snippet": "SYSCALL_DEFINE2(io_setup, unsigned, nr_events, u32 __user *, ctx32p)\n{\n\tstruct kioctx *ioctx = NULL;\n\tunsigned long ctx;\n\tlong ret;\n\n\tret = get_user(ctx, ctx32p);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (unlikely(ctx || nr_events == 0)) {\n\t\tpr_debug(\"EINVAL: ctx %lu nr_events %u\\n\",\n\t\t         ctx, nr_events);\n\t\tgoto out;\n\t}\n\n\tioctx = ioctx_alloc(nr_events);\n\tret = PTR_ERR(ioctx);\n\tif (!IS_ERR(ioctx)) {\n\t\t/* truncating is ok because it's a user address */\n\t\tret = put_user((u32)ioctx->user_id, ctx32p);\n\t\tif (ret)\n\t\t\tkill_ioctx(current->mm, ioctx, NULL);\n\t\tpercpu_ref_put(&ioctx->users);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE2(io_setup, unsigned, nr_events, u32 __user *, ctx32p)\n{\n\tstruct kioctx *ioctx = NULL;\n\tunsigned long ctx;\n\tlong ret;\n\n\tret = get_user(ctx, ctx32p);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (unlikely(ctx || nr_events == 0)) {\n\t\tpr_debug(\"EINVAL: ctx %lu nr_events %u\\n\",\n\t\t         ctx, nr_events);\n\t\tgoto out;\n\t}\n\n\tioctx = ioctx_alloc(nr_events);\n\tret = PTR_ERR(ioctx);\n\tif (!IS_ERR(ioctx)) {\n\t\t/* truncating is ok because it's a user address */\n\t\tret = put_user((u32)ioctx->user_id, ctx32p);\n\t\tif (ret)\n\t\t\tkill_ioctx(current->mm, ioctx, NULL);\n\t\tpercpu_ref_put(&ioctx->users);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "io_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1354-1382",
    "snippet": "SYSCALL_DEFINE1(io_destroy, aio_context_t, ctx)\n{\n\tstruct kioctx *ioctx = lookup_ioctx(ctx);\n\tif (likely(NULL != ioctx)) {\n\t\tstruct ctx_rq_wait wait;\n\t\tint ret;\n\n\t\tinit_completion(&wait.comp);\n\t\tatomic_set(&wait.count, 1);\n\n\t\t/* Pass requests_done to kill_ioctx() where it can be set\n\t\t * in a thread-safe way. If we try to set it here then we have\n\t\t * a race condition if two io_destroy() called simultaneously.\n\t\t */\n\t\tret = kill_ioctx(current->mm, ioctx, &wait);\n\t\tpercpu_ref_put(&ioctx->users);\n\n\t\t/* Wait until all IO for the context are done. Otherwise kernel\n\t\t * keep using user-space buffers even if user thinks the context\n\t\t * is destroyed.\n\t\t */\n\t\tif (!ret)\n\t\t\twait_for_completion(&wait.comp);\n\n\t\treturn ret;\n\t}\n\tpr_debug(\"EINVAL: invalid context id\\n\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE1(io_destroy, aio_context_t, ctx)\n{\n\tstruct kioctx *ioctx = lookup_ioctx(ctx);\n\tif (likely(NULL != ioctx)) {\n\t\tstruct ctx_rq_wait wait;\n\t\tint ret;\n\n\t\tinit_completion(&wait.comp);\n\t\tatomic_set(&wait.count, 1);\n\n\t\t/* Pass requests_done to kill_ioctx() where it can be set\n\t\t * in a thread-safe way. If we try to set it here then we have\n\t\t * a race condition if two io_destroy() called simultaneously.\n\t\t */\n\t\tret = kill_ioctx(current->mm, ioctx, &wait);\n\t\tpercpu_ref_put(&ioctx->users);\n\n\t\t/* Wait until all IO for the context are done. Otherwise kernel\n\t\t * keep using user-space buffers even if user thinks the context\n\t\t * is destroyed.\n\t\t */\n\t\tif (!ret)\n\t\t\twait_for_completion(&wait.comp);\n\n\t\treturn ret;\n\t}\n\tpr_debug(\"EINVAL: invalid context id\\n\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "io_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1888-1925",
    "snippet": "SYSCALL_DEFINE3(io_submit, aio_context_t, ctx_id, long, nr,\n\t\tstruct iocb __user * __user *, iocbpp)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i = 0;\n\tstruct blk_plug plug;\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr > ctx->nr_events)\n\t\tnr = ctx->nr_events;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\n\t\tif (unlikely(get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tpercpu_ref_put(&ctx->users);\n\treturn i ? i : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE3(io_submit, aio_context_t, ctx_id, long, nr,\n\t\tstruct iocb __user * __user *, iocbpp)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i = 0;\n\tstruct blk_plug plug;\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr > ctx->nr_events)\n\t\tnr = ctx->nr_events;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\n\t\tif (unlikely(get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, user_iocb, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tpercpu_ref_put(&ctx->users);\n\treturn i ? i : ret;\n}"
  },
  {
    "function_name": "io_submit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1928-1965",
    "snippet": "SYSCALL_DEFINE3(io_submit, compat_aio_context_t, ctx_id,\n\t\t       int, nr, compat_uptr_t __user *, iocbpp)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i = 0;\n\tstruct blk_plug plug;\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr > ctx->nr_events)\n\t\tnr = ctx->nr_events;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < nr; i++) {\n\t\tcompat_uptr_t user_iocb;\n\n\t\tif (unlikely(get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, compat_ptr(user_iocb), true);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tpercpu_ref_put(&ctx->users);\n\treturn i ? i : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE3(io_submit, compat_aio_context_t, ctx_id,\n\t\t       int, nr, compat_uptr_t __user *, iocbpp)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i = 0;\n\tstruct blk_plug plug;\n\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nr > ctx->nr_events)\n\t\tnr = ctx->nr_events;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < nr; i++) {\n\t\tcompat_uptr_t user_iocb;\n\n\t\tif (unlikely(get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = io_submit_one(ctx, compat_ptr(user_iocb), true);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\n\tpercpu_ref_put(&ctx->users);\n\treturn i ? i : ret;\n}"
  },
  {
    "function_name": "io_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "1996-2033",
    "snippet": "SYSCALL_DEFINE3(io_cancel, aio_context_t, ctx_id, struct iocb __user *, iocb,\n\t\tstruct io_event __user *, result)\n{\n\tstruct kioctx *ctx;\n\tstruct aio_kiocb *kiocb;\n\tint ret = -EINVAL;\n\tu32 key;\n\n\tif (unlikely(get_user(key, &iocb->aio_key)))\n\t\treturn -EFAULT;\n\tif (unlikely(key != KIOCB_KEY))\n\t\treturn -EINVAL;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tkiocb = lookup_kiocb(ctx, iocb);\n\tif (kiocb) {\n\t\tret = kiocb->ki_cancel(&kiocb->rw);\n\t\tlist_del_init(&kiocb->ki_list);\n\t}\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\tif (!ret) {\n\t\t/*\n\t\t * The result argument is no longer used - the io_event is\n\t\t * always delivered via the ring buffer. -EINPROGRESS indicates\n\t\t * cancellation is progress:\n\t\t */\n\t\tret = -EINPROGRESS;\n\t}\n\n\tpercpu_ref_put(&ctx->users);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define KIOCB_KEY\t\t0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define KIOCB_KEY\t\t0\n\nSYSCALL_DEFINE3(io_cancel, aio_context_t, ctx_id, struct iocb __user *, iocb,\n\t\tstruct io_event __user *, result)\n{\n\tstruct kioctx *ctx;\n\tstruct aio_kiocb *kiocb;\n\tint ret = -EINVAL;\n\tu32 key;\n\n\tif (unlikely(get_user(key, &iocb->aio_key)))\n\t\treturn -EFAULT;\n\tif (unlikely(key != KIOCB_KEY))\n\t\treturn -EINVAL;\n\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&ctx->ctx_lock);\n\tkiocb = lookup_kiocb(ctx, iocb);\n\tif (kiocb) {\n\t\tret = kiocb->ki_cancel(&kiocb->rw);\n\t\tlist_del_init(&kiocb->ki_list);\n\t}\n\tspin_unlock_irq(&ctx->ctx_lock);\n\n\tif (!ret) {\n\t\t/*\n\t\t * The result argument is no longer used - the io_event is\n\t\t * always delivered via the ring buffer. -EINPROGRESS indicates\n\t\t * cancellation is progress:\n\t\t */\n\t\tret = -EINPROGRESS;\n\t}\n\n\tpercpu_ref_put(&ctx->users);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "io_getevents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "2066-2082",
    "snippet": "SYSCALL_DEFINE5(io_getevents, aio_context_t, ctx_id,\n\t\tlong, min_nr,\n\t\tlong, nr,\n\t\tstruct io_event __user *, events,\n\t\tstruct timespec __user *, timeout)\n{\n\tstruct timespec64\tts;\n\tint\t\t\tret;\n\n\tif (timeout && unlikely(get_timespec64(&ts, timeout)))\n\t\treturn -EFAULT;\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &ts : NULL);\n\tif (!ret && signal_pending(current))\n\t\tret = -EINTR;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(io_getevents, aio_context_t, ctx_id,\n\t\tlong, min_nr,\n\t\tlong, nr,\n\t\tstruct io_event __user *, events,\n\t\tstruct timespec __user *, timeout)\n{\n\tstruct timespec64\tts;\n\tint\t\t\tret;\n\n\tif (timeout && unlikely(get_timespec64(&ts, timeout)))\n\t\treturn -EFAULT;\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &ts : NULL);\n\tif (!ret && signal_pending(current))\n\t\tret = -EINTR;\n\treturn ret;\n}"
  },
  {
    "function_name": "io_pgetevents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "2089-2132",
    "snippet": "SYSCALL_DEFINE6(io_pgetevents,\n\t\taio_context_t, ctx_id,\n\t\tlong, min_nr,\n\t\tlong, nr,\n\t\tstruct io_event __user *, events,\n\t\tstruct timespec __user *, timeout,\n\t\tconst struct __aio_sigset __user *, usig)\n{\n\tstruct __aio_sigset\tksig = { NULL, };\n\tsigset_t\t\tksigmask, sigsaved;\n\tstruct timespec64\tts;\n\tint ret;\n\n\tif (timeout && unlikely(get_timespec64(&ts, timeout)))\n\t\treturn -EFAULT;\n\n\tif (usig && copy_from_user(&ksig, usig, sizeof(ksig)))\n\t\treturn -EFAULT;\n\n\tif (ksig.sigmask) {\n\t\tif (ksig.sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, ksig.sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &ts : NULL);\n\tif (signal_pending(current)) {\n\t\tif (ksig.sigmask) {\n\t\t\tcurrent->saved_sigmask = sigsaved;\n\t\t\tset_restore_sigmask();\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = -ERESTARTNOHAND;\n\t} else {\n\t\tif (ksig.sigmask)\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE6(io_pgetevents,\n\t\taio_context_t, ctx_id,\n\t\tlong, min_nr,\n\t\tlong, nr,\n\t\tstruct io_event __user *, events,\n\t\tstruct timespec __user *, timeout,\n\t\tconst struct __aio_sigset __user *, usig)\n{\n\tstruct __aio_sigset\tksig = { NULL, };\n\tsigset_t\t\tksigmask, sigsaved;\n\tstruct timespec64\tts;\n\tint ret;\n\n\tif (timeout && unlikely(get_timespec64(&ts, timeout)))\n\t\treturn -EFAULT;\n\n\tif (usig && copy_from_user(&ksig, usig, sizeof(ksig)))\n\t\treturn -EFAULT;\n\n\tif (ksig.sigmask) {\n\t\tif (ksig.sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, ksig.sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &ts : NULL);\n\tif (signal_pending(current)) {\n\t\tif (ksig.sigmask) {\n\t\t\tcurrent->saved_sigmask = sigsaved;\n\t\t\tset_restore_sigmask();\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = -ERESTARTNOHAND;\n\t} else {\n\t\tif (ksig.sigmask)\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "io_getevents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "2135-2151",
    "snippet": "SYSCALL_DEFINE5(io_getevents, compat_aio_context_t, ctx_id,\n\t\t       compat_long_t, min_nr,\n\t\t       compat_long_t, nr,\n\t\t       struct io_event __user *, events,\n\t\t       struct old_timespec32 __user *, timeout)\n{\n\tstruct timespec64 t;\n\tint ret;\n\n\tif (timeout && get_old_timespec32(&t, timeout))\n\t\treturn -EFAULT;\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &t : NULL);\n\tif (!ret && signal_pending(current))\n\t\tret = -EINTR;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(io_getevents, compat_aio_context_t, ctx_id,\n\t\t       compat_long_t, min_nr,\n\t\t       compat_long_t, nr,\n\t\t       struct io_event __user *, events,\n\t\t       struct old_timespec32 __user *, timeout)\n{\n\tstruct timespec64 t;\n\tint ret;\n\n\tif (timeout && get_old_timespec32(&t, timeout))\n\t\treturn -EFAULT;\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &t : NULL);\n\tif (!ret && signal_pending(current))\n\t\tret = -EINTR;\n\treturn ret;\n}"
  },
  {
    "function_name": "io_pgetevents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/aio.c",
    "lines": "2159-2201",
    "snippet": "SYSCALL_DEFINE6(io_pgetevents,\n\t\tcompat_aio_context_t, ctx_id,\n\t\tcompat_long_t, min_nr,\n\t\tcompat_long_t, nr,\n\t\tstruct io_event __user *, events,\n\t\tstruct old_timespec32 __user *, timeout,\n\t\tconst struct __compat_aio_sigset __user *, usig)\n{\n\tstruct __compat_aio_sigset ksig = { NULL, };\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 t;\n\tint ret;\n\n\tif (timeout && get_old_timespec32(&t, timeout))\n\t\treturn -EFAULT;\n\n\tif (usig && copy_from_user(&ksig, usig, sizeof(ksig)))\n\t\treturn -EFAULT;\n\n\tif (ksig.sigmask) {\n\t\tif (ksig.sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, ksig.sigmask))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &t : NULL);\n\tif (signal_pending(current)) {\n\t\tif (ksig.sigmask) {\n\t\t\tcurrent->saved_sigmask = sigsaved;\n\t\t\tset_restore_sigmask();\n\t\t}\n\t\tif (!ret)\n\t\t\tret = -ERESTARTNOHAND;\n\t} else {\n\t\tif (ksig.sigmask)\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <asm/kmap_types.h>",
      "#include <linux/mount.h>",
      "#include <linux/percpu-refcount.h>",
      "#include <linux/ramfs.h>",
      "#include <linux/migrate.h>",
      "#include <linux/compat.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/highmem.h>",
      "#include <linux/aio.h>",
      "#include <linux/timer.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mmu_context.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/uio.h>",
      "#include <linux/refcount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/aio_abi.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/kmap_types.h>\n#include <linux/mount.h>\n#include <linux/percpu-refcount.h>\n#include <linux/ramfs.h>\n#include <linux/migrate.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/eventfd.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/highmem.h>\n#include <linux/aio.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mmu_context.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/backing-dev.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/aio_abi.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE6(io_pgetevents,\n\t\tcompat_aio_context_t, ctx_id,\n\t\tcompat_long_t, min_nr,\n\t\tcompat_long_t, nr,\n\t\tstruct io_event __user *, events,\n\t\tstruct old_timespec32 __user *, timeout,\n\t\tconst struct __compat_aio_sigset __user *, usig)\n{\n\tstruct __compat_aio_sigset ksig = { NULL, };\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 t;\n\tint ret;\n\n\tif (timeout && get_old_timespec32(&t, timeout))\n\t\treturn -EFAULT;\n\n\tif (usig && copy_from_user(&ksig, usig, sizeof(ksig)))\n\t\treturn -EFAULT;\n\n\tif (ksig.sigmask) {\n\t\tif (ksig.sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, ksig.sigmask))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_io_getevents(ctx_id, min_nr, nr, events, timeout ? &t : NULL);\n\tif (signal_pending(current)) {\n\t\tif (ksig.sigmask) {\n\t\t\tcurrent->saved_sigmask = sigsaved;\n\t\t\tset_restore_sigmask();\n\t\t}\n\t\tif (!ret)\n\t\t\tret = -ERESTARTNOHAND;\n\t} else {\n\t\tif (ksig.sigmask)\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\n\treturn ret;\n}"
  }
]