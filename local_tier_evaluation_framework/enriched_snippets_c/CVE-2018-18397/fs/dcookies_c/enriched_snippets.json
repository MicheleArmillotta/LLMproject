[
  {
    "function_name": "dcookie_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "340-351",
    "snippet": "void dcookie_unregister(struct dcookie_user * user)\n{\n\tmutex_lock(&dcookie_mutex);\n\n\tlist_del(&user->next);\n\tkfree(user);\n\n\tif (!is_live())\n\t\tdcookie_exit();\n\n\tmutex_unlock(&dcookie_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(dcookie_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dcookie_exit",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "dcookie_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "289-308",
          "snippet": "static void dcookie_exit(void)\n{\n\tstruct list_head * list;\n\tstruct list_head * pos;\n\tstruct list_head * pos2;\n\tstruct dcookie_struct * dcs;\n\tsize_t i;\n\n\tfor (i = 0; i < hash_size; ++i) {\n\t\tlist = dcookie_hashtable + i;\n\t\tlist_for_each_safe(pos, pos2, list) {\n\t\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\t\tlist_del(&dcs->hash_list);\n\t\t\tfree_dcookie(dcs);\n\t\t}\n\t}\n\n\tkfree(dcookie_hashtable);\n\tkmem_cache_destroy(dcookie_cache);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dcookie_cache",
            "static struct list_head *dcookie_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\nstatic struct list_head *dcookie_hashtable;\n\nstatic void dcookie_exit(void)\n{\n\tstruct list_head * list;\n\tstruct list_head * pos;\n\tstruct list_head * pos2;\n\tstruct dcookie_struct * dcs;\n\tsize_t i;\n\n\tfor (i = 0; i < hash_size; ++i) {\n\t\tlist = dcookie_hashtable + i;\n\t\tlist_for_each_safe(pos, pos2, list) {\n\t\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\t\tlist_del(&dcs->hash_list);\n\t\t\tfree_dcookie(dcs);\n\t\t}\n\t}\n\n\tkfree(dcookie_hashtable);\n\tkmem_cache_destroy(dcookie_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_live",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "is_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "46-49",
          "snippet": "static inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dcookie_users);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LIST_HEAD(dcookie_users);\n\nstatic inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "user"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&user->next"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_MUTEX(dcookie_mutex);\n\nvoid dcookie_unregister(struct dcookie_user * user)\n{\n\tmutex_lock(&dcookie_mutex);\n\n\tlist_del(&user->next);\n\tkfree(user);\n\n\tif (!is_live())\n\t\tdcookie_exit();\n\n\tmutex_unlock(&dcookie_mutex);\n}"
  },
  {
    "function_name": "dcookie_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "315-337",
    "snippet": "struct dcookie_user * dcookie_register(void)\n{\n\tstruct dcookie_user * user;\n\n\tmutex_lock(&dcookie_mutex);\n\n\tuser = kmalloc(sizeof(struct dcookie_user), GFP_KERNEL);\n\tif (!user)\n\t\tgoto out;\n\n\tif (!is_live() && dcookie_init())\n\t\tgoto out_free;\n\n\tlist_add(&user->next, &dcookie_users);\n\nout:\n\tmutex_unlock(&dcookie_mutex);\n\treturn user;\nout_free:\n\tkfree(user);\n\tuser = NULL;\n\tgoto out;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dcookie_users);",
      "static DEFINE_MUTEX(dcookie_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "user"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&user->next",
            "&dcookie_users"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dcookie_init",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "dcookie_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "222-273",
          "snippet": "static int dcookie_init(void)\n{\n\tstruct list_head * d;\n\tunsigned int i, hash_bits;\n\tint err = -ENOMEM;\n\n\tdcookie_cache = kmem_cache_create(\"dcookie_cache\",\n\t\tsizeof(struct dcookie_struct),\n\t\t0, 0, NULL);\n\n\tif (!dcookie_cache)\n\t\tgoto out;\n\n\tdcookie_hashtable = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!dcookie_hashtable)\n\t\tgoto out_kmem;\n\n\terr = 0;\n\n\t/*\n\t * Find the power-of-two list-heads that can fit into the allocation..\n\t * We don't guarantee that \"sizeof(struct list_head)\" is necessarily\n\t * a power-of-two.\n\t */\n\thash_size = PAGE_SIZE / sizeof(struct list_head);\n\thash_bits = 0;\n\tdo {\n\t\thash_bits++;\n\t} while ((hash_size >> hash_bits) != 0);\n\thash_bits--;\n\n\t/*\n\t * Re-calculate the actual number of entries and the mask\n\t * from the number of bits we can fit.\n\t */\n\thash_size = 1UL << hash_bits;\n\n\t/* And initialize the newly allocated array */\n\td = dcookie_hashtable;\n\ti = hash_size;\n\tdo {\n\t\tINIT_LIST_HEAD(d);\n\t\td++;\n\t\ti--;\n\t} while (i);\n\nout:\n\treturn err;\nout_kmem:\n\tkmem_cache_destroy(dcookie_cache);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dcookie_cache",
            "static struct list_head *dcookie_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\nstatic struct list_head *dcookie_hashtable;\n\nstatic int dcookie_init(void)\n{\n\tstruct list_head * d;\n\tunsigned int i, hash_bits;\n\tint err = -ENOMEM;\n\n\tdcookie_cache = kmem_cache_create(\"dcookie_cache\",\n\t\tsizeof(struct dcookie_struct),\n\t\t0, 0, NULL);\n\n\tif (!dcookie_cache)\n\t\tgoto out;\n\n\tdcookie_hashtable = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!dcookie_hashtable)\n\t\tgoto out_kmem;\n\n\terr = 0;\n\n\t/*\n\t * Find the power-of-two list-heads that can fit into the allocation..\n\t * We don't guarantee that \"sizeof(struct list_head)\" is necessarily\n\t * a power-of-two.\n\t */\n\thash_size = PAGE_SIZE / sizeof(struct list_head);\n\thash_bits = 0;\n\tdo {\n\t\thash_bits++;\n\t} while ((hash_size >> hash_bits) != 0);\n\thash_bits--;\n\n\t/*\n\t * Re-calculate the actual number of entries and the mask\n\t * from the number of bits we can fit.\n\t */\n\thash_size = 1UL << hash_bits;\n\n\t/* And initialize the newly allocated array */\n\td = dcookie_hashtable;\n\ti = hash_size;\n\tdo {\n\t\tINIT_LIST_HEAD(d);\n\t\td++;\n\t\ti--;\n\t} while (i);\n\nout:\n\treturn err;\nout_kmem:\n\tkmem_cache_destroy(dcookie_cache);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_live",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "is_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "46-49",
          "snippet": "static inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dcookie_users);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LIST_HEAD(dcookie_users);\n\nstatic inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct dcookie_user)",
            "GFP_KERNEL"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LIST_HEAD(dcookie_users);\nstatic DEFINE_MUTEX(dcookie_mutex);\n\nstruct dcookie_user * dcookie_register(void)\n{\n\tstruct dcookie_user * user;\n\n\tmutex_lock(&dcookie_mutex);\n\n\tuser = kmalloc(sizeof(struct dcookie_user), GFP_KERNEL);\n\tif (!user)\n\t\tgoto out;\n\n\tif (!is_live() && dcookie_init())\n\t\tgoto out_free;\n\n\tlist_add(&user->next, &dcookie_users);\n\nout:\n\tmutex_unlock(&dcookie_mutex);\n\treturn user;\nout_free:\n\tkfree(user);\n\tuser = NULL;\n\tgoto out;\n}"
  },
  {
    "function_name": "dcookie_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "289-308",
    "snippet": "static void dcookie_exit(void)\n{\n\tstruct list_head * list;\n\tstruct list_head * pos;\n\tstruct list_head * pos2;\n\tstruct dcookie_struct * dcs;\n\tsize_t i;\n\n\tfor (i = 0; i < hash_size; ++i) {\n\t\tlist = dcookie_hashtable + i;\n\t\tlist_for_each_safe(pos, pos2, list) {\n\t\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\t\tlist_del(&dcs->hash_list);\n\t\t\tfree_dcookie(dcs);\n\t\t}\n\t}\n\n\tkfree(dcookie_hashtable);\n\tkmem_cache_destroy(dcookie_cache);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dcookie_cache",
      "static struct list_head *dcookie_hashtable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dcookie_cache"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dcookie_hashtable"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_dcookie",
          "args": [
            "dcs"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "free_dcookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "276-286",
          "snippet": "static void free_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct dentry *d = dcs->path.dentry;\n\n\tspin_lock(&d->d_lock);\n\td->d_flags &= ~DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tpath_put(&dcs->path);\n\tkmem_cache_free(dcookie_cache, dcs);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dcookie_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\n\nstatic void free_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct dentry *d = dcs->path.dentry;\n\n\tspin_lock(&d->d_lock);\n\td->d_flags &= ~DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tpath_put(&dcs->path);\n\tkmem_cache_free(dcookie_cache, dcs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&dcs->hash_list"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structdcookie_struct",
            "hash_list"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "pos2",
            "list"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\nstatic struct list_head *dcookie_hashtable;\n\nstatic void dcookie_exit(void)\n{\n\tstruct list_head * list;\n\tstruct list_head * pos;\n\tstruct list_head * pos2;\n\tstruct dcookie_struct * dcs;\n\tsize_t i;\n\n\tfor (i = 0; i < hash_size; ++i) {\n\t\tlist = dcookie_hashtable + i;\n\t\tlist_for_each_safe(pos, pos2, list) {\n\t\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\t\tlist_del(&dcs->hash_list);\n\t\t\tfree_dcookie(dcs);\n\t\t}\n\t}\n\n\tkfree(dcookie_hashtable);\n\tkmem_cache_destroy(dcookie_cache);\n}"
  },
  {
    "function_name": "free_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "276-286",
    "snippet": "static void free_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct dentry *d = dcs->path.dentry;\n\n\tspin_lock(&d->d_lock);\n\td->d_flags &= ~DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tpath_put(&dcs->path);\n\tkmem_cache_free(dcookie_cache, dcs);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dcookie_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dcookie_cache",
            "dcs"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&dcs->path"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&d->d_lock"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&d->d_lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\n\nstatic void free_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct dentry *d = dcs->path.dentry;\n\n\tspin_lock(&d->d_lock);\n\td->d_flags &= ~DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tpath_put(&dcs->path);\n\tkmem_cache_free(dcookie_cache, dcs);\n}"
  },
  {
    "function_name": "dcookie_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "222-273",
    "snippet": "static int dcookie_init(void)\n{\n\tstruct list_head * d;\n\tunsigned int i, hash_bits;\n\tint err = -ENOMEM;\n\n\tdcookie_cache = kmem_cache_create(\"dcookie_cache\",\n\t\tsizeof(struct dcookie_struct),\n\t\t0, 0, NULL);\n\n\tif (!dcookie_cache)\n\t\tgoto out;\n\n\tdcookie_hashtable = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!dcookie_hashtable)\n\t\tgoto out_kmem;\n\n\terr = 0;\n\n\t/*\n\t * Find the power-of-two list-heads that can fit into the allocation..\n\t * We don't guarantee that \"sizeof(struct list_head)\" is necessarily\n\t * a power-of-two.\n\t */\n\thash_size = PAGE_SIZE / sizeof(struct list_head);\n\thash_bits = 0;\n\tdo {\n\t\thash_bits++;\n\t} while ((hash_size >> hash_bits) != 0);\n\thash_bits--;\n\n\t/*\n\t * Re-calculate the actual number of entries and the mask\n\t * from the number of bits we can fit.\n\t */\n\thash_size = 1UL << hash_bits;\n\n\t/* And initialize the newly allocated array */\n\td = dcookie_hashtable;\n\ti = hash_size;\n\tdo {\n\t\tINIT_LIST_HEAD(d);\n\t\td++;\n\t\ti--;\n\t} while (i);\n\nout:\n\treturn err;\nout_kmem:\n\tkmem_cache_destroy(dcookie_cache);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dcookie_cache",
      "static struct list_head *dcookie_hashtable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dcookie_cache"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "d"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"dcookie_cache\"",
            "sizeof(struct dcookie_struct)",
            "0",
            "0",
            "NULL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\nstatic struct list_head *dcookie_hashtable;\n\nstatic int dcookie_init(void)\n{\n\tstruct list_head * d;\n\tunsigned int i, hash_bits;\n\tint err = -ENOMEM;\n\n\tdcookie_cache = kmem_cache_create(\"dcookie_cache\",\n\t\tsizeof(struct dcookie_struct),\n\t\t0, 0, NULL);\n\n\tif (!dcookie_cache)\n\t\tgoto out;\n\n\tdcookie_hashtable = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!dcookie_hashtable)\n\t\tgoto out_kmem;\n\n\terr = 0;\n\n\t/*\n\t * Find the power-of-two list-heads that can fit into the allocation..\n\t * We don't guarantee that \"sizeof(struct list_head)\" is necessarily\n\t * a power-of-two.\n\t */\n\thash_size = PAGE_SIZE / sizeof(struct list_head);\n\thash_bits = 0;\n\tdo {\n\t\thash_bits++;\n\t} while ((hash_size >> hash_bits) != 0);\n\thash_bits--;\n\n\t/*\n\t * Re-calculate the actual number of entries and the mask\n\t * from the number of bits we can fit.\n\t */\n\thash_size = 1UL << hash_bits;\n\n\t/* And initialize the newly allocated array */\n\td = dcookie_hashtable;\n\ti = hash_size;\n\tdo {\n\t\tINIT_LIST_HEAD(d);\n\t\td++;\n\t\ti--;\n\t} while (i);\n\nout:\n\treturn err;\nout_kmem:\n\tkmem_cache_destroy(dcookie_cache);\n\tgoto out;\n}"
  },
  {
    "function_name": "do_lookup_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "149-204",
    "snippet": "static int do_lookup_dcookie(u64 cookie64, char __user *buf, size_t len)\n{\n\tunsigned long cookie = (unsigned long)cookie64;\n\tint err = -EINVAL;\n\tchar * kbuf;\n\tchar * path;\n\tsize_t pathlen;\n\tstruct dcookie_struct * dcs;\n\n\t/* we could leak path information to users\n\t * without dir read permission without this\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&dcookie_mutex);\n\n\tif (!is_live()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(dcs = find_dcookie(cookie)))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tkbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\tgoto out;\n\n\t/* FIXME: (deleted) ? */\n\tpath = d_path(&dcs->path, kbuf, PAGE_SIZE);\n\n\tmutex_unlock(&dcookie_mutex);\n\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tgoto out_free;\n\t}\n\n\terr = -ERANGE;\n \n\tpathlen = kbuf + PAGE_SIZE - path;\n\tif (pathlen <= len) {\n\t\terr = pathlen;\n\t\tif (copy_to_user(buf, path, pathlen))\n\t\t\terr = -EFAULT;\n\t}\n\nout_free:\n\tkfree(kbuf);\n\treturn err;\nout:\n\tmutex_unlock(&dcookie_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(dcookie_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kbuf"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "path",
            "pathlen"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "&dcs->path",
            "kbuf",
            "PAGE_SIZE"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "256-285",
          "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_dcookie",
          "args": [
            "cookie"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "find_dcookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "65-83",
          "snippet": "static struct dcookie_struct * find_dcookie(unsigned long dcookie)\n{\n\tstruct dcookie_struct *found = NULL;\n\tstruct dcookie_struct * dcs;\n\tstruct list_head * pos;\n\tstruct list_head * list;\n\n\tlist = dcookie_hashtable + dcookie_hash(dcookie);\n\n\tlist_for_each(pos, list) {\n\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\tif (dcookie_value(dcs) == dcookie) {\n\t\t\tfound = dcs;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head *dcookie_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct list_head *dcookie_hashtable;\n\nstatic struct dcookie_struct * find_dcookie(unsigned long dcookie)\n{\n\tstruct dcookie_struct *found = NULL;\n\tstruct dcookie_struct * dcs;\n\tstruct list_head * pos;\n\tstruct list_head * list;\n\n\tlist = dcookie_hashtable + dcookie_hash(dcookie);\n\n\tlist_for_each(pos, list) {\n\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\tif (dcookie_value(dcs) == dcookie) {\n\t\t\tfound = dcs;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_live",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "is_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "46-49",
          "snippet": "static inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dcookie_users);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LIST_HEAD(dcookie_users);\n\nstatic inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_MUTEX(dcookie_mutex);\n\nstatic int do_lookup_dcookie(u64 cookie64, char __user *buf, size_t len)\n{\n\tunsigned long cookie = (unsigned long)cookie64;\n\tint err = -EINVAL;\n\tchar * kbuf;\n\tchar * path;\n\tsize_t pathlen;\n\tstruct dcookie_struct * dcs;\n\n\t/* we could leak path information to users\n\t * without dir read permission without this\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&dcookie_mutex);\n\n\tif (!is_live()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(dcs = find_dcookie(cookie)))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tkbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\tgoto out;\n\n\t/* FIXME: (deleted) ? */\n\tpath = d_path(&dcs->path, kbuf, PAGE_SIZE);\n\n\tmutex_unlock(&dcookie_mutex);\n\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tgoto out_free;\n\t}\n\n\terr = -ERANGE;\n \n\tpathlen = kbuf + PAGE_SIZE - path;\n\tif (pathlen <= len) {\n\t\terr = pathlen;\n\t\tif (copy_to_user(buf, path, pathlen))\n\t\t\terr = -EFAULT;\n\t}\n\nout_free:\n\tkfree(kbuf);\n\treturn err;\nout:\n\tmutex_unlock(&dcookie_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "get_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "116-143",
    "snippet": "int get_dcookie(const struct path *path, unsigned long *cookie)\n{\n\tint err = 0;\n\tstruct dcookie_struct * dcs;\n\n\tmutex_lock(&dcookie_mutex);\n\n\tif (!is_live()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (path->dentry->d_flags & DCACHE_COOKIE) {\n\t\tdcs = find_dcookie((unsigned long)path->dentry);\n\t} else {\n\t\tdcs = alloc_dcookie(path);\n\t\tif (!dcs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cookie = dcookie_value(dcs);\n\nout:\n\tmutex_unlock(&dcookie_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(dcookie_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dcookie_value",
          "args": [
            "dcs"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "dcookie_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "53-56",
          "snippet": "static inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_dcookie",
          "args": [
            "path"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dcookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "93-110",
          "snippet": "static struct dcookie_struct *alloc_dcookie(const struct path *path)\n{\n\tstruct dcookie_struct *dcs = kmem_cache_alloc(dcookie_cache,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tstruct dentry *d;\n\tif (!dcs)\n\t\treturn NULL;\n\n\td = path->dentry;\n\tspin_lock(&d->d_lock);\n\td->d_flags |= DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tdcs->path = *path;\n\tpath_get(path);\n\thash_dcookie(dcs);\n\treturn dcs;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dcookie_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\n\nstatic struct dcookie_struct *alloc_dcookie(const struct path *path)\n{\n\tstruct dcookie_struct *dcs = kmem_cache_alloc(dcookie_cache,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tstruct dentry *d;\n\tif (!dcs)\n\t\treturn NULL;\n\n\td = path->dentry;\n\tspin_lock(&d->d_lock);\n\td->d_flags |= DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tdcs->path = *path;\n\tpath_get(path);\n\thash_dcookie(dcs);\n\treturn dcs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_dcookie",
          "args": [
            "(unsigned long)path->dentry"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "find_dcookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "65-83",
          "snippet": "static struct dcookie_struct * find_dcookie(unsigned long dcookie)\n{\n\tstruct dcookie_struct *found = NULL;\n\tstruct dcookie_struct * dcs;\n\tstruct list_head * pos;\n\tstruct list_head * list;\n\n\tlist = dcookie_hashtable + dcookie_hash(dcookie);\n\n\tlist_for_each(pos, list) {\n\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\tif (dcookie_value(dcs) == dcookie) {\n\t\t\tfound = dcs;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head *dcookie_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct list_head *dcookie_hashtable;\n\nstatic struct dcookie_struct * find_dcookie(unsigned long dcookie)\n{\n\tstruct dcookie_struct *found = NULL;\n\tstruct dcookie_struct * dcs;\n\tstruct list_head * pos;\n\tstruct list_head * list;\n\n\tlist = dcookie_hashtable + dcookie_hash(dcookie);\n\n\tlist_for_each(pos, list) {\n\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\tif (dcookie_value(dcs) == dcookie) {\n\t\t\tfound = dcs;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_live",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "is_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "46-49",
          "snippet": "static inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(dcookie_users);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LIST_HEAD(dcookie_users);\n\nstatic inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dcookie_mutex"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_MUTEX(dcookie_mutex);\n\nint get_dcookie(const struct path *path, unsigned long *cookie)\n{\n\tint err = 0;\n\tstruct dcookie_struct * dcs;\n\n\tmutex_lock(&dcookie_mutex);\n\n\tif (!is_live()) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (path->dentry->d_flags & DCACHE_COOKIE) {\n\t\tdcs = find_dcookie((unsigned long)path->dentry);\n\t} else {\n\t\tdcs = alloc_dcookie(path);\n\t\tif (!dcs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cookie = dcookie_value(dcs);\n\nout:\n\tmutex_unlock(&dcookie_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "alloc_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "93-110",
    "snippet": "static struct dcookie_struct *alloc_dcookie(const struct path *path)\n{\n\tstruct dcookie_struct *dcs = kmem_cache_alloc(dcookie_cache,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tstruct dentry *d;\n\tif (!dcs)\n\t\treturn NULL;\n\n\td = path->dentry;\n\tspin_lock(&d->d_lock);\n\td->d_flags |= DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tdcs->path = *path;\n\tpath_get(path);\n\thash_dcookie(dcs);\n\treturn dcs;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dcookie_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_dcookie",
          "args": [
            "dcs"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "hash_dcookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "86-90",
          "snippet": "static void hash_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct list_head * list = dcookie_hashtable + dcookie_hash(dcookie_value(dcs));\n\tlist_add(&dcs->hash_list, list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head *dcookie_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct list_head *dcookie_hashtable;\n\nstatic void hash_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct list_head * list = dcookie_hashtable + dcookie_hash(dcookie_value(dcs));\n\tlist_add(&dcs->hash_list, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "path"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "469-473",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&d->d_lock"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&d->d_lock"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "dcookie_cache",
            "GFP_KERNEL"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct kmem_cache *dcookie_cache;\n\nstatic struct dcookie_struct *alloc_dcookie(const struct path *path)\n{\n\tstruct dcookie_struct *dcs = kmem_cache_alloc(dcookie_cache,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tstruct dentry *d;\n\tif (!dcs)\n\t\treturn NULL;\n\n\td = path->dentry;\n\tspin_lock(&d->d_lock);\n\td->d_flags |= DCACHE_COOKIE;\n\tspin_unlock(&d->d_lock);\n\n\tdcs->path = *path;\n\tpath_get(path);\n\thash_dcookie(dcs);\n\treturn dcs;\n}"
  },
  {
    "function_name": "hash_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "86-90",
    "snippet": "static void hash_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct list_head * list = dcookie_hashtable + dcookie_hash(dcookie_value(dcs));\n\tlist_add(&dcs->hash_list, list);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head *dcookie_hashtable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dcs->hash_list",
            "list"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dcookie_hash",
          "args": [
            "dcookie_value(dcs)"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "dcookie_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "59-62",
          "snippet": "static size_t dcookie_hash(unsigned long dcookie)\n{\n\treturn (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic size_t dcookie_hash(unsigned long dcookie)\n{\n\treturn (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dcookie_value",
          "args": [
            "dcs"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "dcookie_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "53-56",
          "snippet": "static inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct list_head *dcookie_hashtable;\n\nstatic void hash_dcookie(struct dcookie_struct * dcs)\n{\n\tstruct list_head * list = dcookie_hashtable + dcookie_hash(dcookie_value(dcs));\n\tlist_add(&dcs->hash_list, list);\n}"
  },
  {
    "function_name": "find_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "65-83",
    "snippet": "static struct dcookie_struct * find_dcookie(unsigned long dcookie)\n{\n\tstruct dcookie_struct *found = NULL;\n\tstruct dcookie_struct * dcs;\n\tstruct list_head * pos;\n\tstruct list_head * list;\n\n\tlist = dcookie_hashtable + dcookie_hash(dcookie);\n\n\tlist_for_each(pos, list) {\n\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\tif (dcookie_value(dcs) == dcookie) {\n\t\t\tfound = dcs;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head *dcookie_hashtable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dcookie_value",
          "args": [
            "dcs"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "dcookie_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "53-56",
          "snippet": "static inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structdcookie_struct",
            "hash_list"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "list"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dcookie_hash",
          "args": [
            "dcookie"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "dcookie_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
          "lines": "59-62",
          "snippet": "static size_t dcookie_hash(unsigned long dcookie)\n{\n\treturn (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/path.h>",
            "#include <linux/mutex.h>",
            "#include <linux/dcookies.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic size_t dcookie_hash(unsigned long dcookie)\n{\n\treturn (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct list_head *dcookie_hashtable;\n\nstatic struct dcookie_struct * find_dcookie(unsigned long dcookie)\n{\n\tstruct dcookie_struct *found = NULL;\n\tstruct dcookie_struct * dcs;\n\tstruct list_head * pos;\n\tstruct list_head * list;\n\n\tlist = dcookie_hashtable + dcookie_hash(dcookie);\n\n\tlist_for_each(pos, list) {\n\t\tdcs = list_entry(pos, struct dcookie_struct, hash_list);\n\t\tif (dcookie_value(dcs) == dcookie) {\n\t\t\tfound = dcs;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "dcookie_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "59-62",
    "snippet": "static size_t dcookie_hash(unsigned long dcookie)\n{\n\treturn (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic size_t dcookie_hash(unsigned long dcookie)\n{\n\treturn (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);\n}"
  },
  {
    "function_name": "dcookie_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "53-56",
    "snippet": "static inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline unsigned long dcookie_value(struct dcookie_struct * dcs)\n{\n\treturn (unsigned long)dcs->path.dentry;\n}"
  },
  {
    "function_name": "is_live",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "46-49",
    "snippet": "static inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(dcookie_users);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dcookie_users"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic LIST_HEAD(dcookie_users);\n\nstatic inline int is_live(void)\n{\n\treturn !(list_empty(&dcookie_users));\n}"
  },
  {
    "function_name": "lookup_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "206-209",
    "snippet": "SYSCALL_DEFINE3(lookup_dcookie, u64, cookie64, char __user *, buf, size_t, len)\n{\n\treturn do_lookup_dcookie(cookie64, buf, len);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(lookup_dcookie, u64, cookie64, char __user *, buf, size_t, len)\n{\n\treturn do_lookup_dcookie(cookie64, buf, len);\n}"
  },
  {
    "function_name": "lookup_dcookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcookies.c",
    "lines": "212-219",
    "snippet": "SYSCALL_DEFINE4(lookup_dcookie, u32, w0, u32, w1, char __user *, buf, compat_size_t, len)\n{\n#ifdef __BIG_ENDIAN\n\treturn do_lookup_dcookie(((u64)w0 << 32) | w1, buf, len);\n#else\n\treturn do_lookup_dcookie(((u64)w1 << 32) | w0, buf, len);\n#endif\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/path.h>",
      "#include <linux/mutex.h>",
      "#include <linux/dcookies.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include <linux/mount.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/path.h>\n#include <linux/mutex.h>\n#include <linux/dcookies.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE4(lookup_dcookie, u32, w0, u32, w1, char __user *, buf, compat_size_t, len)\n{\n#ifdef __BIG_ENDIAN\n\treturn do_lookup_dcookie(((u64)w0 << 32) | w1, buf, len);\n#else\n\treturn do_lookup_dcookie(((u64)w1 << 32) | w0, buf, len);\n#endif\n}"
  }
]